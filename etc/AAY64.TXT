                                                                  s$$$$$$s
 All_About_Your_64-Online Help V0.64                s$$$$$$p     $$$S  S$$
 (c) by Ninja/The Dreams in 1995-2005               $$$S   S$$   $$$S  S$P
 HQ - [http://www.the-dreams.de]                    $$$S   S$$   $$$$$$l
                                                    $$$S   S$$   $$$$  $$l
 6510 instruction set & Infos                       $$$S   S$$   $$$P   $$l
 6510 illegal instruction set                       Y$$$$$$$P
 65816 extended instruction set
                                                                      d$$$b
 VIC-Registers & Infos                                  s$$$$$$b    d$$$  $$b
 SID-Registers & Infos                                  $$$$        $$$$  $$$
 CIA-Registers & Infos                                  $$$$sss     $$$&%%&$$
                                                        $$$$""'     $$$$   $$
 Zeropage                                               $$$$        Y$$$   SP
 BASIC-ROM-Listing                                      Y$$$$$$$P
 Kernal-ROM-Listing
                                                                   o$$$$$Ss
                                                     s$$    $s    S$$S
 Hardware Expansions                                 $$$$  $$$     S$$$
                                                     $$$ $$ $$        S$$s
 Memory-Maps of different Programs                   $$$ "" $$           $$
 Format-Descriptions                                 $$$    $$    sS$$$$$$P
                                                     Y$$    $P

  +-------------------------------------------------------------------------
  |
  |      CENTRAL PROCESSING UNIT (CPU) 6510
  |
  +-------------------------------------------------------------------------
  |
  |  Related topics:
  |
  |   6510 illegal instruction set
  |   6510 instruction chart
  |
  |   65816 extended instruction set
  |   65816 instruction chart
  |
  |   6510/65816 Addressing modes
  |   Bugs and flaws of the 6510
  |
  |  Instructions set:
  |
  |     ADC   Add Memory to Accumulator with Carry
  |     AND   "AND" Memory with Accumulator
  |     ASL   Shift Left One Bit (Memory or Accumulator)
  |
  |     BCC   Branch on Carry Clear
  |     BCS   Branch on Carry Set
  |     BEQ   Branch on Result Zero
  |     BIT   Test Bits in Memory with Accumulator
  |     BMI   Branch on Result Minus
  |     BNE   Branch on Result not Zero
  |     BPL   Branch on Result Plus
  |     BRK   Force Break
  |     BVC   Branch on Overflow Clear
  |     BVS   Branch on Overflow Set
  |
  |     CLC   Clear Carry Flag
  |     CLD   Clear Decimal Mode
  |     CLI   Clear interrupt Disable Bit
  |     CLV   Clear Overflow Flag
  |     CMP   Compare Memory and Accumulator
  |     CPX   Compare Memory and Index X
  |     CPY   Compare Memory and Index Y
  |
  |     DEC   Decrement Memory by One
  |     DEX   Decrement Index X by One
  |     DEY   Decrement Index Y by One
  |
  |     EOR   "Exclusive-Or" Memory with Accumulator
  |
  |     INC   Increment Memory by One
  |     INX   Increment Index X by One
  |     INY   Increment Index Y by One
  |
  |     JMP   Jump to New Location
  |     JSR   Jump to New Location Saving Return Address
  |
  |     LDA   Load Accumulator with Memory
  |     LDX   Load Index X with Memory
  |     LDY   Load Index Y with Memory
  |     LSR   Shift Right One Bit (Memory or Accumulator)
  |
  |     NOP   No Operation
  |
  |     ORA   "OR" Memory with Accumulator
  |
  |     PHA   Push Accumulator on Stack
  |     PHP   Push Processor Status on Stack
  |     PLA   Pull Accumulator from Stack
  |     PLP   Pull Processor Status from Stack
  |
  |     ROL   Rotate One Bit Left (Memory or Accumulator)
  |     ROR   Rotate One Bit Right (Memory or Accumulator)
  |     RTI   Return from Interrupt
  |     RTS   Return from Subroutine
  |
  |     SBC   Subtract Memory from Accumulator with Borrow
  |     SEC   Set Carry Flag
  |     SED   Set Decimal Mode
  |     SEI   Set Interrupt Disable Status
  |     STA   Store Accumulator in Memory
  |     STX   Store Index X in Memory
  |     STY   Store Index Y in Memory
  |
  |     TAX   Transfer Accumulator to Index X
  |     TAY   Transfer Accumulator to Index Y
  |     TSX   Transfer Stack Pointer to Index X
  |     TXA   Transfer Index X to Accumulator
  |     TXS   Transfer Index X to Stack Pointer
  |     TYA   Transfer Index Y to Accumulator
  |
  +-------------------------------------------------------------------------



  ADC               Add memory to accumulator with carry                ADC

  Operation:  A + M + C -> A, C                         N V - B D I Z C
                                                        / / . . . . / /

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Immediate     |   ADC #$FF            |   $69   |    2    |    2     |
  |  ZeroPage      |   ADC $FF             |   $65   |    2    |    3     |
  |  ZeroPage,X    |   ADC $FF,X           |   $75   |    2    |    4     |
  |  Absolute      |   ADC $FFFF           |   $6D   |    3    |    4     |
  |  Absolute,X    |   ADC $FFFF,X         |   $7D   |    3    |    4*    |
  |  Absolute,Y    |   ADC $FFFF,Y         |   $79   |    3    |    4*    |
  |  (Indirect,X)  |   ADC ($FF,X)         |   $61   |    2    |    6     |
  |  (Indirect),Y  |   ADC ($FF),Y         |   $71   |    2    |    5*    |
  +----------------+-----------------------+---------+---------+----------+
  * Add 1 if page boundary is crossed.
  For penalty cycles on the 65816, check the desired addressing mode.

  Note: See CPU-Bugs for a description how flags are affected.

 65816 Extensions:

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | AbsoluteLong   |   ADC $FFFFFF         |   $6F   |    4    |     5    |
  | AbsoluteLong,X |   ADC $FFFFFF,X       |   $7F   |    4    |     5    |
  | (Indirect)     |   ADC ($FF)           |   $72   |    2    |     5    |
  | [Indirect Long]|   ADC [$FF]           |   $67   |    2    |     6    |
  | [Ind.Long],Y   |   ADC [$FF],Y         |   $77   |    2    |     6    |
  | Relative,S     |   ADC $FF,S           |   $63   |    2    |     4    |
  | (Indirect,S),Y |   ADC ($FF,S),Y       |   $73   |    2    |     7    |
  +----------------+-----------------------+---------+---------+----------+


  AND                  "AND" memory with accumulator                    AND

  Operation:  A /\ M -> A                               N V - B D I Z C
                                                        / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Immediate     |   AND #$FF            |   $29   |    2    |    2     |
  |  ZeroPage      |   AND $FF             |   $25   |    2    |    3     |
  |  ZeroPage,X    |   AND $FF,X           |   $35   |    2    |    4     |
  |  Absolute      |   AND $FFFF           |   $2D   |    3    |    4     |
  |  Absolute,X    |   AND $FFFF,X         |   $3D   |    3    |    4*    |
  |  Absolute,Y    |   AND $FFFF,Y         |   $39   |    3    |    4*    |
  |  (Indirect,X)  |   AND ($FF,X)         |   $21   |    2    |    6     |
  |  (Indirect),Y  |   AND ($FF),Y         |   $31   |    2    |    5*    |
  +----------------+-----------------------+---------+---------+----------+
  * Add 1 if page boundary is crossed.
  For penalty cycles on the 65816, check the desired addressing mode.

 65816 Extensions:

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | AbsoluteLong   |   AND $FFFFFF         |   $2F   |    4    |     5    |
  | AbsoluteLong,X |   AND $FFFFFF,X       |   $3F   |    4    |     5    |
  | (Indirect)     |   AND ($FF)           |   $32   |    2    |     5    |
  | [Indirect Long]|   AND [$FF]           |   $27   |    2    |     6    |
  | [Ind.Long],Y   |   AND [$FF],Y         |   $37   |    2    |     6    |
  | Relative,S     |   AND $FF,S           |   $23   |    2    |     4    |
  | (Indirect,S),Y |   AND ($FF,S),Y       |   $33   |    2    |     7    |
  +----------------+-----------------------+---------+---------+----------+


  ASL          ASL Shift Left One Bit (Memory or Accumulator)           ASL

                   +-+-+-+-+-+-+-+-+
  Operation:  C <- |7|6|5|4|3|2|1|0| <- 0               N V - B D I Z C
                   +-+-+-+-+-+-+-+-+                    / . . . . . / /

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Accumulator   |   ASL A               |   $0A   |    1    |    2     |
  |  ZeroPage      |   ASL $FF             |   $06   |    2    |    5     |
  |  ZeroPage,X    |   ASL $FF,X           |   $16   |    2    |    6     |
  |  Absolute      |   ASL $FFFF           |   $0E   |    3    |    6     |
  |  Absolute,X    |   ASL $FFFF,X         |   $1E   |    3    |    7     |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.


  BCC                     BCC Branch on Carry Clear                     BCC

  Operation:  Branch on C = 0                           N V - B D I Z C
                                                        . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Relative      |   BCC $FFFF           |   $90   |    2    |    2*    |
  +----------------+-----------------------+---------+---------+----------+
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page (see explanation).


  BCS                      BCS Branch on carry set                      BCS

  Operation:  Branch on C = 1                           N V - B D I Z C
                                                        . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Relative      |   BCS $FFFF           |   $B0   |    2    |    2*    |
  +----------------+-----------------------+---------+---------+----------+
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page (see explanation).


  BEQ                    BEQ Branch on result zero                      BEQ

  Operation:  Branch on Z = 1                           N V - B D I Z C
                                                        . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Relative      |   BEQ $FFFF           |   $F0   |    2    |    2*    |
  +----------------+-----------------------+---------+---------+----------+
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page (see explanation).


  BIT             BIT Test bits in memory with accumulator              BIT

  Operation:  A /\ M -> Z, M7 -> N, M6 -> V             N V - B D I Z C
                                                        M7M6. . . . / .
  Bit 6 and 7 are transferred to the status register.
  If the result of A /\ M is zero then Z = 1, otherwise Z=0.

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  ZeroPage      |   BIT $FF             |   $24   |    2    |    3     |
  |  Absolute      |   BIT $FFFF           |   $2C   |    3    |    4     |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.

 65816 Extensions:

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Immediate      |   BIT #$FF            |   $89   |    2    |    2     |
  | Direct Page,X  |   BIT $FF,X           |   $34   |    2    |    3     |
  | Absolute,X     |   BIT $FFFF,X         |   $3C   |    3    |    4     |
  +----------------+-----------------------+---------+---------+----------+


  BMI                    BMI Branch on result minus                     BMI

  Operation:  Branch on N = 1                           N V - B D I Z C
                                                        . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Relative      |   BMI $FFFF           |   $30   |    2    |    2*    |
  +----------------+-----------------------+---------+---------+----------+
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page (see explanation).


  BNE                   BNE Branch on result not zero                   BNE

  Operation:  Branch on Z = 0                           N V - B D I Z C
                                                        . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Relative      |   BNE $FFFF           |   $D0   |    2    |    2*    |
  +----------------+-----------------------+---------+---------+----------+
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page (see explanation).


  BPL                     BPL Branch on result plus                     BPL

  Operation:  Branch on N = 0                           N V - B D I Z C
                                                        . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Relative      |   BPL $FFFF           |   $10   |    2    |    2*    |
  +----------------+-----------------------+---------+---------+----------+
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page (see explanation).


  BRK                          BRK Force Break                          BRK

  Operation:  Forced Interrupt;                         N V - B D I Z C
              PC + 2 to Stack, P to Stack               . . . 1 0 1 . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied/Stack |   BRK                 |   $00   |    1    |    7     |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.

  1. A BRK command cannot be masked by setting I.
  2. Although even official documents say BRK uses implied addressing-mode,
     it is rather an immediate one, but the operand is thrown away. This is
     why PC+2 is pushed onto stack rather than PC+1. So, better use a NOP
     directly after BRK to avoid trouble.
  3. To be very precise: The B-flag is not set by BRK. It is rather set all
     the time, only when an external IRQ is recognized it will be cleared for
     some cycles, so you can distinguish between BRK and IRQ.


  BVC                   BVC Branch on overflow clear                    BVC

  Operation:  Branch on V = 0                           N V - B D I Z C
                                                        . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Relative      |   BVC $FFFF           |   $50   |    2    |    2*    |
  +----------------+-----------------------+---------+---------+----------+
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page (see explanation).


  BVS                    BVS Branch on overflow set                     BVS

  Operation:  Branch on V = 1                           N V - B D I Z C
                                                        . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Relative      |   BVS $FFFF           |   $70   |    2    |    2*    |
  +----------------+-----------------------+---------+---------+----------+
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page (see explanation).


  CLC                       CLC Clear carry flag                        CLC

  Operation:  0 -> C                                    N V - B D I Z C
                                                        . . . . . . . 0

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied       |   CLC                 |   $18   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  CLD                      CLD Clear decimal mode                       CLD

  Operation:  0 -> D                                    N V - B D I Z C
                                                        . . . . 0 . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied       |   CLD                 |   $D8   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  CLI                  CLI Clear interrupt disable bit                  CLI

  Operation: 0 -> I                                     N V - B D I Z C
                                                        . . . . . 0 . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied       |   CLI                 |   $58   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  CLV                      CLV Clear overflow flag                      CLV

  Operation: 0 -> V                                     N V - B D I Z C
                                                        . 0 . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied       |   CLV                 |   $B8   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  CMP                CMP Compare memory and accumulator                 CMP

  Operation:  A - M                                     N V - B D I Z C
                                                        / . . . . . / /

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Immediate     |   CMP #$FF            |   $C9   |    2    |    2     |
  |  ZeroPage      |   CMP $FF             |   $C5   |    2    |    3     |
  |  ZeroPage,X    |   CMP $FF,X           |   $D5   |    2    |    4     |
  |  Absolute      |   CMP $FFFF           |   $CD   |    3    |    4     |
  |  Absolute,X    |   CMP $FFFF,X         |   $DD   |    3    |    4*    |
  |  Absolute,Y    |   CMP $FFFF,Y         |   $D9   |    3    |    4*    |
  |  (Indirect,X)  |   CMP ($FF,X)         |   $C1   |    2    |    6     |
  |  (Indirect),Y  |   CMP ($FF),Y         |   $D1   |    2    |    5*    |
  +----------------+-----------------------+---------+---------+----------+
  * Add 1 if page boundary is crossed.
  For penalty cycles on the 65816, check the desired addressing mode.

 65816 Extensions:

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | AbsoluteLong   |   CMP $FFFFFF         |   $CF   |    4    |     5    |
  | AbsoluteLong,X |   CMP $FFFFFF,X       |   $DF   |    4    |     5    |
  | (Indirect)     |   CMP ($FF)           |   $D2   |    2    |     5    |
  | [Indirect Long]|   CMP [$FF]           |   $C7   |    2    |     6    |
  | [Ind.Long],Y   |   CMP [$FF],Y         |   $D7   |    2    |     6    |
  | Relative,S     |   CMP $FF,S           |   $C3   |    2    |     4    |
  | (Indirect,S),Y |   CMP ($FF,S),Y       |   $D3   |    2    |     7    |
  +----------------+-----------------------+---------+---------+----------+


  CPX                  CPX Compare Memory and Index X                   CPX

  Operation:  X - M                                     N V - B D I Z C
                                                        / . . . . . / /

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Immediate     |   CPX #$FF            |   $E0   |    2    |    2     |
  |  ZeroPage      |   CPX $FF             |   $E4   |    2    |    3     |
  |  Absolute      |   CPX $FFFF           |   $EC   |    3    |    4     |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.


  CPY                  CPY Compare memory and index Y                   CPY

  Operation:  Y - M                                     N V - B D I Z C
                                                        / . . . . . / /

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Immediate     |   CPY #$FF            |   $C0   |    2    |    2     |
  |  ZeroPage      |   CPY $FF             |   $C4   |    2    |    3     |
  |  Absolute      |   CPY $FFFF           |   $CC   |    3    |    4     |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.


  DEC                   DEC Decrement memory by one                     DEC

  Operation:  M - 1 -> M                                N V - B D I Z C
                                                        / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  ZeroPage      |   DEC $FF             |   $C6   |    2    |    5     |
  |  ZeroPage,X    |   DEC $FF,X           |   $D6   |    2    |    6     |
  |  Absolute      |   DEC $FFFF           |   $CE   |    3    |    6     |
  |  Absolute,X    |   DEC $FFFF,X         |   $DE   |    3    |    7     |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.

 65816 Extensions:

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Implied        |   DEC                 |   $3A   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  DEX                   DEX Decrement index X by one                    DEX

  Operation:  X - 1 -> X                                N V - B D I Z C
                                                        / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied       |   DEX                 |   $CA   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  DEY                   DEY Decrement index Y by one                    DEY

  Operation:  Y - 1 -> Y                                N V - B D I Z C
                                                        / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied       |   DEY                 |   $88   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  EOR            EOR "Exclusive-Or" memory with accumulator             EOR

  Operation:  A EOR M -> A                              N V - B D I Z C
                                                        / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Immediate     |   EOR #$FF            |   $49   |    2    |    2     |
  |  ZeroPage      |   EOR $FF             |   $45   |    2    |    3     |
  |  ZeroPage,X    |   EOR $FF,X           |   $55   |    2    |    4     |
  |  Absolute      |   EOR $FFFF           |   $4D   |    3    |    4     |
  |  Absolute,X    |   EOR $FFFF,X         |   $5D   |    3    |    4*    |
  |  Absolute,Y    |   EOR $FFFF,Y         |   $59   |    3    |    4*    |
  |  (Indirect,X)  |   EOR ($FF,X)         |   $41   |    2    |    6     |
  |  (Indirect),Y  |   EOR ($FF),Y         |   $51   |    2    |    5*    |
  +----------------+-----------------------+---------+---------+----------+
  * Add 1 if page boundary is crossed.
  For penalty cycles on the 65816, check the desired addressing mode.

 65816 Extensions:

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | AbsoluteLong   |   EOR $FFFFFF         |   $4F   |    4    |     5    |
  | AbsoluteLong,X |   EOR $FFFFFF,X       |   $5F   |    4    |     5    |
  | (Indirect)     |   EOR ($FF)           |   $52   |    2    |     5    |
  | [Indirect Long]|   EOR [$FF]           |   $47   |    2    |     6    |
  | [Ind.Long],Y   |   EOR [$FF],Y         |   $57   |    2    |     6    |
  | Relative,S     |   EOR $FF,S           |   $43   |    2    |     4    |
  | (Indirect,S),Y |   EOR ($FF,S),Y       |   $53   |    2    |     7    |
  +----------------+-----------------------+---------+---------+----------+


  INC                    INC Increment memory by one                    INC

  Operation:  M + 1 -> M                                N V - B D I Z C
                                                        / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  ZeroPage      |   INC $FF             |   $E6   |    2    |    5     |
  |  ZeroPage,X    |   INC $FF,X           |   $F6   |    2    |    6     |
  |  Absolute      |   INC $FFFF           |   $EE   |    3    |    6     |
  |  Absolute,X    |   INC $FFFF,X         |   $FE   |    3    |    7     |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.

 65816 Extensions:

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Implied        |   INC                 |   $1A   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  INX                    INX Increment Index X by one                   INX

  Operation:  X + 1 -> X                                N V - B D I Z C
                                                        / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied       |   INX                 |   $E8   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  INY                    INY Increment Index Y by one                   INY

  Operation:  X + 1 -> X                                N V - B D I Z C
                                                        / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied       |   INY                 |   $C8   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  JMP                     JMP Jump to new location                      JMP

  Operation:  (PC + 1) -> PCL                           N V - B D I Z C
              (PC + 2) -> PCH                           . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Absolute      |   JMP $FFFF           |   $4C   |    3    |    3     |
  | (Abs.Indirect) |   JMP ($FFFF)         |   $6C   |    3    |    5     |
  +----------------+-----------------------+---------+---------+----------+

 65816 Extensions:

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | (Abs.Ind.,X)   |   JMP ($FFFF,X)       |   $7C   |    3    |     6    |
  | AbsoluteLong   |   JMP $FFFFFF         |   $5C   |    4    |     4    |
  +----------------+-----------------------+---------+---------+----------+
   See also: JML


  JSR          JSR Jump to new location saving return address           JSR

  Operation:  PC + 2 to Stack, (PC + 1) -> PCL          N V - B D I Z C
                               (PC + 2) -> PCH          . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Absolute      |   JSR $FFFF           |   $20   |    3    |    6     |
  +----------------+-----------------------+---------+---------+----------+

 65816 Extensions:

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | (Abs.Ind.,X)   |   JSR ($FFFF,X)       |   $FC   |    3    |     6    |
  +----------------+-----------------------+---------+---------+----------+
   See also: JSL


  LDA                  LDA Load accumulator with memory                 LDA

  Operation:  M -> A                                    N V - B D I Z C
                                                        / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Immediate     |   LDA #$FF            |   $A9   |    2    |    2     |
  |  ZeroPage      |   LDA $FF             |   $A5   |    2    |    3     |
  |  ZeroPage,X    |   LDA $FF,X           |   $B5   |    2    |    4     |
  |  Absolute      |   LDA $FFFF           |   $AD   |    3    |    4     |
  |  Absolute,X    |   LDA $FFFF,X         |   $BD   |    3    |    4*    |
  |  Absolute,Y    |   LDA $FFFF,Y         |   $B9   |    3    |    4*    |
  |  (Indirect,X)  |   LDA ($FF,X)         |   $A1   |    2    |    6     |
  |  (Indirect),Y  |   LDA ($FF),Y         |   $B1   |    2    |    5*    |
  +----------------+-----------------------+---------+---------+----------+
  * Add 1 if page boundary is crossed.
  For penalty cycles on the 65816, check the desired addressing mode.

 65816 Extensions:

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | AbsoluteLong   |   LDA $FFFFFF         |   $AF   |    4    |     5    |
  | AbsoluteLong,X |   LDA $FFFFFF,X       |   $BF   |    4    |     5    |
  | (Indirect)     |   LDA ($FF)           |   $B2   |    2    |     5    |
  | [Indirect Long]|   LDA [$FF]           |   $A7   |    2    |     6    |
  | [Ind.Long],Y   |   LDA [$FF],Y         |   $B7   |    2    |     6    |
  | Relative,S     |   LDA $FF,S           |   $A3   |    2    |     4    |
  | (Indirect,S),Y |   LDA ($FF,S),Y       |   $B3   |    2    |     7    |
  +----------------+-----------------------+---------+---------+----------+


  LDX                   LDX Load index X with memory                    LDX

  Operation:  M -> X                                    N V - B D I Z C
                                                        / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Immediate     |   LDX #$FF            |   $A2   |    2    |    2     |
  |  ZeroPage      |   LDX $FF             |   $A6   |    2    |    3     |
  |  ZeroPage,Y    |   LDX $FF,Y           |   $B6   |    2    |    4     |
  |  Absolute      |   LDX $FFFF           |   $AE   |    3    |    4     |
  |  Absolute,Y    |   LDX $FFFF,Y         |   $BE   |    3    |    4*    |
  +----------------+-----------------------+---------+---------+----------+
  * Add 1 when page boundary is crossed.
  For penalty cycles on the 65816, check the desired addressing mode.


  LDY                   LDY Load index Y with memory                    LDY

  Operation:  M -> Y                                    N V - B D I Z C
                                                        / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Immediate     |   LDY #$FF            |   $A0   |    2    |    2     |
  |  ZeroPage      |   LDY $FF             |   $A4   |    2    |    3     |
  |  ZeroPage,X    |   LDY $FF,X           |   $B4   |    2    |    4     |
  |  Absolute      |   LDY $FFFF           |   $AC   |    3    |    4     |
  |  Absolute,X    |   LDY $FFFF,X         |   $BC   |    3    |    4*    |
  +----------------+-----------------------+---------+---------+----------+
  * Add 1 when page boundary is crossed.
  For penalty cycles on the 65816, check the desired addressing mode.


  LSR          LSR Shift right one bit (memory or accumulator)          LSR

                   +-+-+-+-+-+-+-+-+
  Operation:  0 -> |7|6|5|4|3|2|1|0| -> C               N V - B D I Z C
                   +-+-+-+-+-+-+-+-+                    0 . . . . . / /

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Accumulator   |   LSR A               |   $4A   |    1    |    2     |
  |  ZeroPage      |   LSR $FF             |   $46   |    2    |    5     |
  |  ZeroPage,X    |   LSR $FF,X           |   $56   |    2    |    6     |
  |  Absolute      |   LSR $FFFF           |   $4E   |    3    |    6     |
  |  Absolute,X    |   LSR $FFFF,X         |   $5E   |    3    |    7     |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.


  NOP                         NOP No operation                          NOP

  Operation:  No Operation                              N V - B D I Z C
                                                        . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied       |   NOP                 |   $EA   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+

 Illegal Versions:

  Can be used like BIT to skip the next one or two bytes,
  but this one doesn't change flags.

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied       |   NOP                 |   $1A   |    1    |    2     |
  |  Implied       |   NOP                 |   $3A   |    1    |    2     |
  |  Implied       |   NOP                 |   $5A   |    1    |    2     |
  |  Implied       |   NOP                 |   $7A   |    1    |    2     |
  |  Implied       |   NOP                 |   $DA   |    1    |    2     |
  |  Implied       |   NOP                 |   $FA   |    1    |    2     |
  |  Immediate     |   NOP #$FF            |   $80   |    2    |    2     |
  |  Immediate     |   NOP #$FF            |   $82   |    2    |    2     |
  |  Immediate     |   NOP #$FF            |   $89   |    2    |    2     |
  |  Immediate     |   NOP #$FF            |   $C2   |    2    |    2     |
  |  Immediate     |   NOP #$FF            |   $E2   |    2    |    2     |
  |  ZeroPage      |   NOP $FF             |   $04   |    2    |    3     |
  |  ZeroPage      |   NOP $FF             |   $44   |    2    |    3     |
  |  ZeroPage      |   NOP $FF             |   $64   |    2    |    3     |
  |  ZeroPage,X    |   NOP $FF,X           |   $14   |    2    |    4     |
  |  ZeroPage,X    |   NOP $FF,X           |   $34   |    2    |    4     |
  |  ZeroPage,X    |   NOP $FF,X           |   $54   |    2    |    4     |
  |  ZeroPage,X    |   NOP $FF,X           |   $74   |    2    |    4     |
  |  ZeroPage,X    |   NOP $FF,X           |   $D4   |    2    |    4     |
  |  ZeroPage,X    |   NOP $FF,X           |   $F4   |    2    |    4     |
  |  Absolute      |   NOP $FFFF           |   $0C   |    3    |    4     |
  |  Absolute,X    |   NOP $FFFF,X         |   $1C   |    3    |    4*    |
  |  Absolute,X    |   NOP $FFFF,X         |   $3C   |    3    |    4*    |
  |  Absolute,X    |   NOP $FFFF,X         |   $5C   |    3    |    4*    |
  |  Absolute,X    |   NOP $FFFF,X         |   $7C   |    3    |    4*    |
  |  Absolute,X    |   NOP $FFFF,X         |   $DC   |    3    |    4*    |
  |  Absolute,X    |   NOP $FFFF,X         |   $FC   |    3    |    4*    |
  +----------------+-----------------------+---------+---------+----------+
  * Add 1 if page boundary is crossed.


  ORA                 ORA "OR" memory with accumulator                  ORA

  Operation: A V M -> A                                 N V - B D I Z C
                                                        / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Immediate     |   ORA #$FF            |   $09   |    2    |    2     |
  |  ZeroPage      |   ORA $FF             |   $05   |    2    |    3     |
  |  ZeroPage,X    |   ORA $FF,X           |   $15   |    2    |    4     |
  |  Absolute      |   ORA $FFFF           |   $0D   |    3    |    4     |
  |  Absolute,X    |   ORA $FFFF,X         |   $1D   |    3    |    4*    |
  |  Absolute,Y    |   ORA $FFFF,Y         |   $19   |    3    |    4*    |
  |  (Indirect,X)  |   ORA ($FF,X)         |   $01   |    2    |    6     |
  |  (Indirect),Y  |   ORA ($FF),Y         |   $11   |    2    |    5*    |
  +----------------+-----------------------+---------+---------+----------+
  * Add 1 on page crossing
  For penalty cycles on the 65816, check the desired addressing mode.

 65816 Extensions:

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | AbsoluteLong   |   ORA $FFFFFF         |   $0F   |    4    |     5    |
  | AbsoluteLong,X |   ORA $FFFFFF,X       |   $1F   |    4    |     5    |
  | (Indirect)     |   ORA ($FF)           |   $12   |    2    |     5    |
  | [Indirect Long]|   ORA [$FF]           |   $07   |    2    |     6    |
  | [Ind.Long],Y   |   ORA [$FF],Y         |   $17   |    2    |     6    |
  | Relative,S     |   ORA $FF,S           |   $03   |    2    |     4    |
  | (Indirect,S),Y |   ORA ($FF,S),Y       |   $13   |    2    |     7    |
  +----------------+-----------------------+---------+---------+----------+


  PHA                   PHA Push accumulator on stack                   PHA

  Operation:  A to Stack                                N V - B D I Z C
                                                        . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied/Stack |   PHA                 |   $48   |    1    |    3     |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.


  PHP                 PHP Push processor status on stack                PHP

  Operation:  P to Stack                                N V - B D I Z C
                                                        . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied/Stack |   PHP                 |   $08   |    1    |    3     |
  +----------------+-----------------------+---------+---------+----------+


  PLA                 PLA Pull accumulator from stack                   PLA

  Operation:  A from Stack                              N V - B D I Z C
                                                        / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied/Stack |   PLA                 |   $68   |    1    |    4     |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.


  PLP               PLP Pull processor status from stack                PLP

  Operation:  P from Stack                              N V - B D I Z C
                                                          From Stack

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied/Stack |   PLP                 |   $28   |    1    |    4     |
  +----------------+-----------------------+---------+---------+----------+


  ROL          ROL Rotate one bit left (memory or accumulator)          ROL

               +------------------------------+
               |                              |
               |   +-+-+-+-+-+-+-+-+    +-+   |
  Operation:   +-< |7|6|5|4|3|2|1|0| <- |C| <-+         N V - B D I Z C
                   +-+-+-+-+-+-+-+-+    +-+             / . . . . . / /

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Accumulator   |   ROL A               |   $2A   |    1    |    2     |
  |  ZeroPage      |   ROL $FF             |   $26   |    2    |    5     |
  |  ZeroPage,X    |   ROL $FF,X           |   $36   |    2    |    6     |
  |  Absolute      |   ROL $FFFF           |   $2E   |    3    |    6     |
  |  Absolute,X    |   ROL $FFFF,X         |   $3E   |    3    |    7     |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.


  ROR          ROR Rotate one bit right (memory or accumulator)         ROR

               +------------------------------+
               |                              |
               |   +-+    +-+-+-+-+-+-+-+-+   |
  Operation:   +-> |C| -> |7|6|5|4|3|2|1|0| >-+         N V - B D I Z C
                   +-+    +-+-+-+-+-+-+-+-+             / . . . . . / /

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Accumulator   |   ROR A               |   $6A   |    1    |    2     |
  |  ZeroPage      |   ROR $FF             |   $66   |    2    |    5     |
  |  ZeroPage,X    |   ROR $FF,X           |   $76   |    2    |    6     |
  |  Absolute      |   ROR $FFFF           |   $6E   |    3    |    6     |
  |  Absolute,X    |   ROR $FFFF,X         |   $7E   |    3    |    7     |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.

    Note: ROR instruction is available on MCS650X microprocessors after
          June, 1976.


  RTI                    RTI Return from interrupt                      RTI

  Operation:  P from Stack, PC from Stack               N V - B D I Z C
                                                          From Stack

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied/Stack |   RTI                 |   $40   |    1    |    6     |
  +----------------+-----------------------+---------+---------+----------+


  RTS                    RTS Return from subroutine                     RTS

  Operation:  PC from Stack, PC + 1 -> PC               N V - B D I Z C
                                                        . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied/Stack |   RTS                 |   $60   |    1    |    6     |
  +----------------+-----------------------+---------+---------+----------+
   See also: RTL


  SBC          SBC Subtract memory from accumulator with borrow         SBC

  Operation:  A - M - ~C -> A                           N V - B D I Z C
         -                                              / / . . . . / /
    Note:C = Borrow
  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Immediate     |   SBC #$FF            |   $E9   |    2    |    2     |
  |  ZeroPage      |   SBC $FF             |   $E5   |    2    |    3     |
  |  ZeroPage,X    |   SBC $FF,X           |   $F5   |    2    |    4     |
  |  Absolute      |   SBC $FFFF           |   $ED   |    3    |    4     |
  |  Absolute,X    |   SBC $FFFF,X         |   $FD   |    3    |    4*    |
  |  Absolute,Y    |   SBC $FFFF,Y         |   $F9   |    3    |    4*    |
  |  (Indirect,X)  |   SBC ($FF,X)         |   $E1   |    2    |    6     |
  |  (Indirect),Y  |   SBC ($FF),Y         |   $F1   |    2    |    5*    |
  +----------------+-----------------------+---------+---------+----------+
  * Add 1 when page boundary is crossed.
  For penalty cycles on the 65816, check the desired addressing mode.

  Note: See CPU-Bugs for a description how flags are affected.

 Illegal Version:

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Immediate     |   SBC #$FF            |   $EB   |    2    |    2     |
  +----------------+-----------------------+---------+---------+----------+
  There doesn't seem to be a difference to the legal SBC.

 65816 Extensions:

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | AbsoluteLong   |   SBC $FFFFFF         |   $EF   |    4    |     5    |
  | AbsoluteLong,X |   SBC $FFFFFF,X       |   $FF   |    4    |     5    |
  | (Indirect)     |   SBC ($FF)           |   $F2   |    2    |     5    |
  | [Indirect Long]|   SBC [$FF]           |   $E7   |    2    |     6    |
  | [Ind.Long],Y   |   SBC [$FF],Y         |   $F7   |    2    |     6    |
  | Relative,S     |   SBC $FF,S           |   $E3   |    2    |     4    |
  | (Indirect,S),Y |   SBC ($FF,S),Y       |   $F3   |    2    |     7    |
  +----------------+-----------------------+---------+---------+----------+


  SEC                        SEC Set carry flag                         SEC

  Operation:  1 -> C                                    N V - B D I Z C
                                                        . . . . . . . 1

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied       |   SEC                 |   $38   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  SED                       SED Set decimal mode                        SED

  Operation:  1 -> D                                    N V - B D I Z C
                                                        . . . . 1 . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied       |   SED                 |   $F8   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  SEI                 SEI Set interrupt disable status                  SEI

  Operation:  1 -> I                                    N V - B D I Z C
                                                        . . . . . 1 . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied       |   SEI                 |   $78   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  STA                  STA Store accumulator in memory                  STA

  Operation:  A -> M                                    N V - B D I Z C
                                                        . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  ZeroPage      |   STA $FF             |   $85   |    2    |    3     |
  |  ZeroPage,X    |   STA $FF,X           |   $95   |    2    |    4     |
  |  Absolute      |   STA $FFFF           |   $8D   |    3    |    4     |
  |  Absolute,X    |   STA $FFFF,X         |   $9D   |    3    |    5     |
  |  Absolute,Y    |   STA $FFFF,Y         |   $99   |    3    |    5     |
  |  (Indirect,X)  |   STA ($FF,X)         |   $81   |    2    |    6     |
  |  (Indirect),Y  |   STA ($FF),Y         |   $91   |    2    |    6     |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.

 65816 Extensions:

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | AbsoluteLong   |   STA $FFFFFF         |   $8F   |    4    |     5    |
  | AbsoluteLong,X |   STA $FFFFFF,X       |   $9F   |    4    |     5    |
  | (Indirect)     |   STA ($FF)           |   $92   |    2    |     5    |
  | [Indirect Long]|   STA [$FF]           |   $87   |    2    |     6    |
  | [Ind.Long],Y   |   STA [$FF],Y         |   $97   |    2    |     6    |
  | Relative,S     |   STA $FF,S           |   $83   |    2    |     4    |
  | (Indirect,S),Y |   STA ($FF,S),Y       |   $93   |    2    |     7    |
  +----------------+-----------------------+---------+---------+----------+


  STX                    STX Store index X in memory                    STX

  Operation: X -> M                                     N V - B D I Z C
                                                        . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  ZeroPage      |   STX $FF             |   $86   |    2    |    3     |
  |  ZeroPage,Y    |   STX $FF,Y           |   $96   |    2    |    4     |
  |  Absolute      |   STX $FFFF           |   $8E   |    3    |    4     |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.


  STY                    STY Store index Y in memory                    STY

  Operation: Y -> M                                     N V - B D I Z C
                                                        . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  ZeroPage      |   STY $FF             |   $84   |    2    |    3     |
  |  ZeroPage,X    |   STY $FF,X           |   $94   |    2    |    4     |
  |  Absolute      |   STY $FFFF           |   $8C   |    3    |    4     |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.


  TAX                TAX Transfer accumulator to index X                TAX

  Operation:  A -> X                                    N V - B D I Z C
                                                        / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied       |   TAX                 |   $AA   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  TAY                TAY Transfer accumulator to index Y                TAY

  Operation:  A -> Y                                    N V - B D I Z C
                                                        / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied       |   TAY                 |   $A8   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  TSX              TSX Transfer stack pointer to index X                TSX

  Operation:  S -> X                                    N V - B D I Z C
                                                        / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied       |   TSX                 |   $BA   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  TXA                TXA Transfer index X to accumulator                TXA

  Operation:  X -> A                                    N V - B D I Z C
                                                        / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied       |   TXA                 |   $8A   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+

  TXS              TXS Transfer index X to stack pointer                TXS

  Operation:  X -> S                                    N V - B D I Z C
                                                        . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied       |   TXS                 |   $9A   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  TYA                TYA Transfer index Y to accumulator                TYA

  Operation:  Y -> A                                    N V - B D I Z C
                                                        / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied       |   TYA                 |   $98   |    1    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  +-------------------------------------------------------------------------
  |
  |      CENTRAL PROCESSING UNIT (CPU) 65816
  |
  +-------------------------------------------------------------------------
  |
  |  Related topics:
  |
  |   6510 instruction set
  |   6510 illegal instruction set
  |   6510 instruction chart
  |
  |   65816 instruction chart
  |
  |   6510/65816 Addressing modes
  |
  |  Instructions set:
  |
  |     BRA   Branch Always
  |     BRL   Branch Always Long
  |
  |     COP   Coprocessor
  |
  |     JML   Jump Long
  |     JSL   Jump Subroutine Long
  |
  |     MVN   Block Move Negative
  |     MVP   Block Move Positive
  |
  |     PEA   Push Effective Absolute Address on Stack (or Push Immediate Data on Stack)
  |     PEI   Push Effective Indirect Address on Stack
  |     PER   Push Effective Program Counter Relative Address on Stack
  |     PHB   Push Data Bank Register on Stack
  |     PHD   Push Direct Register on Stack
  |     PHK   Push Program Bank Register on Stack
  |     PHX   Push Index X on Stack
  |     PHY   Push index Y on Stack
  |     PLB   Pull Data Bank Register from Stack
  |     PLD   Pull Direct Register from Stack
  |     PLX   Pull Index X from Stack
  |     PLY   Pull Index Y form Stack
  |
  |     REP   Reset Status Bits
  |     RTL   Return from Subroutine Long
  |
  |     SEP   Set Processor Status Bits
  |     STP   Stop the Clock
  |     STZ   Store Zero in Memory
  |
  |     TCD   Transfer Accumulator to Direct Register
  |     TCS   Transfer Accumulator to Stack Pointer Register
  |     TDC   Transfer Direct Register to Accumulator
  |     TRB   Test and Reset Bit
  |     TSB   Test and Set Bit
  |     TSC   Transfer Stack Pointer Register to Accumulator
  |     TXY   Transfer Index X to Index Y
  |     TYX   Transfer Index Y to Index X
  |
  |     WAI   Wait for Interrupt
  |     WDM   Reserved for Future Expansion
  |
  |     XBA   Exchange AH and AL
  |     XCE   Exchange Carry and Emulation Bits
  |
  +-------------------------------------------------------------------------



  BRL                       BRL Branch Always Long                      BRL

 65816 only!
                                                        N V M X D I Z C
  Operation:  PC+r -> PC where -32768 < r < 32767       . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | RelativeLong   |   BRL $FFFFFF         |   $82   |    3    |     3    |
  +----------------+-----------------------+---------+---------+----------+


  COP                          COP Coprocessor                          COP

 65816 only!
                                                        N V M X D I Z C
  Operation:  Coprocessor Instruction                   . . . . 0 1 . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Immediate/Stack|   COP #$FF            |   $02   |    2    |    7/8   |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.


  JML                           JML Jump Long                           JML

 65816 only!
                                                        N V M X D I Z C
  Operation:  W -> PC, B -> PB                          . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | (Abs.Ind.Long) |   JML ($FFFF)         |   $DC   |    3    |     6    |
  +----------------+-----------------------+---------+---------+----------+


  JSL                      JSL Jump Subroutine Long                     JSL

 65816 only!
                                                        N V M X D I Z C
  Operation:  PB -> Bs, S-1 -S, PC -> Ws, S-2 -> S,     . . . . . . . .
              W -> PC,  B -> PB

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | AbsoluteLong   |   JSL $FFFFFF         |   $22   |    4    |     8    |
  +----------------+-----------------------+---------+---------+----------+
   Note: JSL is equivalent to JSR with long addressing forced.


  MVN                      MVN Block Move Negative                      MVN

 65816 only!
                                                        N V M X D I Z C
  Operation:                                            . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Block Negative |   MVN $FF,$FF         |   $54   |    3    |  7/byte  |
  +----------------+-----------------------+---------+---------+----------+
   X-Register = Source Address
   Y-Register = Destination Address
   Accumulator = Number of Bytes to move -1
   $FF,$FF = Source Bank, Destination Bank

   Attention: In memory the order of the Bank-bytes is the other way
   around (i.e. Dest, Src)! Some assemblers use this order as syntax,
   although it is not correct.

   Keep also in mind that the Data-Bank-Register will be set to Dest-Bank.

   MVN is used when the destination start address is lower (more negative)
   than the source start address.


  MVP                      MVP Block Move Positive                      MVP

 65816 only!
                                                        N V M X D I Z C
  Operation:                                            . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Block Positive |   MVP $FF,$FF         |   $44   |    3    |  7/byte  |
  +----------------+-----------------------+---------+---------+----------+
   X-Register = Source Address
   Y-Register = Destination Address
   Accumulator = Number of Bytes to move -1
   $FF,$FF = Source Bank, Destination Bank

   Attention: In memory the order of the Bank-bytes is the other way
   around (i.e. Dest, Src)! Some assemblers use this order as syntax,
   although it is not correct.

   Keep also in mind that the Data-Bank-Register will be set to Dest-Bank.

   MVP is used when the destination start address is higher (more positive)
   than the source start address.


  REP                       REP Reset Status Bits                       REP

 65816 only!
                                                        N V M X D I Z C
  Operation:  P /\ /B -> P                              / / / / / / / /

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Immediate      |   REP #$FF            |   $C2   |    2    |     3    |
  +----------------+-----------------------+---------+---------+----------+


  RTL                  RTL Return from Subroutine Long                  RTL

 65816 only!
                                                        N V M X D I Z C
  Operation:  S+2 -> S, Ws+1 -> PC, S+1 -> S, Bs -> PB  . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Implied/Stack  |   RTL                 |   $6B   |    1    |     6    |
  +----------------+-----------------------+---------+---------+----------+


  SEP                   SEP Set Processor Status Bits                   SEP

 65816 only!
                                                        N V M X D I Z C
  Operation:  P V B -> P                                / / / / / / / /

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Immediate      |   SEP #$FF            |   $E2   |    2    |     3    |
  +----------------+-----------------------+---------+---------+----------+


  STP                         STP Stop the Clock                        STP

 65816 only!
                                                        N V M X D I Z C
  Operation:  Stop the clock. Needs reset to continue.  . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Implied        |   STP                 |   $DB   |    1    |    3+    |
  +----------------+-----------------------+---------+---------+----------+


  WAI                       WAI Wait for Interrupt                      WAI

 65816 only!
                                                        N V M X D I Z C
  Operation:  Wait for interrupt. RDY held low until    . . . . . . . .
              Interrupt.

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Implied        |   WAI                 |   $CB   |    1    |    3+    |
  +----------------+-----------------------+---------+---------+----------+


  WDM                 WDM Reserved for Future Expansion                 WDM

 65816 only!
                                                        N V M X D I Z C
  Operation:  At the moment treated like NOP.           . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Immediate      |   WDM #$FF            |   $42   |    2    |     2    |
  +----------------+-----------------------+---------+---------+----------+
  WDM is the first byte of a multi-byte instruction set to be built in future
  versions of the processor. This instruction should NOT be used by now.
  (WDM -> William D. Mensch jr., 65816 designer)


  XBA                       XBA Exchange AH and AL                      XBA

 65816 only!
                                                        N V M X D I Z C
  Operation:  Swap AH and AL. Status bits reflect       / . . . . . / .
              final condition of AL.

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Implied        |   XBA                 |   $EB   |    1    |     3    |
  +----------------+-----------------------+---------+---------+----------+


  BRA                         BRA Branch Always                         BRA

 65816 only!
                                                        N V M X D I Z C
  Operation:  PC+r -> PC                                . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Relative       |   BRA $FFFF           |   $80   |    2    |     2    |
  +----------------+-----------------------+---------+---------+----------+


  PEA            PEA Push Effective Absolute Address on Stack           PEA
                     (or Push Immediate Data on Stack)

 65816 only!
                                                        N V M X D I Z C
  Operation:  W -> Ws, S-2 ->S                          . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Immediate/Stack|   PEA #$FFFF          |   $F4   |    3    |     5    |
  +----------------+-----------------------+---------+---------+----------+

  Note: Sometimes PEA is said to have Absolute-addressing-mode. But it
  definately behaves like Immediate.


  PEI            PEI Push Effective Indirect Address on Stack           PEI

 65816 only!
                                                        N V M X D I Z C
  Operation:  W -> Ws, S-2 ->S                          . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |(Indirect)/Stack|   PEI ($FF)           |   $D4   |    2    |     6    |
  +----------------+-----------------------+---------+---------+----------+
  Add one cycle if low byte of direct page is <>0.


  PER    PER Push Effective Program Counter Relative Address on Stack   PER

 65816 only!
                                                        N V M X D I Z C
  Operation:  W -> Ws, S-2 ->S                          . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | RelativeLong/S |   PER $FFFFFF         |   $62   |    3    |     6    |
  +----------------+-----------------------+---------+---------+----------+


  PHB                PHB Push Data Bank Register on Stack               PHB

 65816 only!
                                                        N V M X D I Z C
  Operation:  DB->Bs, S-1 ->S                           . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Implied/Stack  |   PHB                 |   $8B   |    1    |     3    |
  +----------------+-----------------------+---------+---------+----------+


  PHD                 PHD Push Direct Register on Stack                 PHD

 65816 only!
                                                        N V M X D I Z C
  Operation:  D ->Ws, S-2 ->S                           . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Implied/Stack  |   PHD                 |   $0B   |    1    |     4    |
  +----------------+-----------------------+---------+---------+----------+


  PHK              PHK Push Program Bank Register on Stack              PHK

 65816 only!
                                                        N V M X D I Z C
  Operation:  PB->Bs, S-1 ->S                           . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Implied/Stack  |   PHK                 |   $4B   |    1    |     3    |
  +----------------+-----------------------+---------+---------+----------+


  PHX                     PHX Push Index X on Stack                     PHX

 65816 only!
                                                        N V M X D I Z C
  Operation:  X-Ws, S-2 -> S                            . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Implied/Stack  |   PHX                 |   $DA   |    1    |    3/4   |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.


  PHY                     PHY Push index Y on Stack                     PHY

 65816 only!
                                                        N V M X D I Z C
  Operation:  Y ->Ws, S-2 ->S                           . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Implied/Stack  |   PHY                 |   $5A   |    1    |    3/4   |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.


  PLB               PLB Pull Data Bank Register from Stack              PLB

 65816 only!
                                                        N V M X D I Z C
  Operation:  S+1 ->S, Bs -> DB                         / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Implied/Stack  |   PLB                 |   $AB   |    1    |     4    |
  +----------------+-----------------------+---------+---------+----------+


  PLD                PLD Pull Direct Register from Stack                PLD

 65816 only!
                                                        N V M X D I Z C
  Operation:  S+2 ->S, Ws -> D                          / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Implied/Stack  |   PLD                 |   $2B   |    1    |     5    |
  +----------------+-----------------------+---------+---------+----------+


  PLX                    PLX Pull Index X from Stack                    PLX

 65816 only!
                                                        N V M X D I Z C
  Operation:  S+2 ->S, Ws->X                            / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Implied/Stack  |   PLX                 |   $FA   |    1    |    4/5   |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.


  PLY                    PLY Pull Index Y form Stack                    PLY

 65816 only!
                                                        N V M X D I Z C
  Operation:  S+2 ->S, Ws->Y                            / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Implied/Stack  |   PLY                 |   $7A   |    1    |    4/5   |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.


  TCD            TCD Transfer Accumulator to Direct Register            TCD

 65816 only!
                                                        N V M X D I Z C
  Operation:  A -> D                                    / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Implied        |   TCD                 |   $5B   |    1    |     2    |
  +----------------+-----------------------+---------+---------+----------+


  TCS         TCS Transfer Accumulator to Stack Pointer Register        TCS

 65816 only!
                                                        N V M X D I Z C
  Operation:  A -> S                                    . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Implied        |   TCS                 |   $1B   |    1    |    2/    |
  +----------------+-----------------------+---------+---------+----------+


  TDC            TDC Transfer Direct Register to Accumulator            TDC

 65816 only!
                                                        N V M X D I Z C
  Operation:  D -> A                                    / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Implied        |   TDC                 |   $7B   |    1    |     2    |
  +----------------+-----------------------+---------+---------+----------+


  TSC         TSC Transfer Stack Pointer Register to Accumulator        TSC

 65816 only!
                                                        N V M X D I Z C
  Operation:  S -> A                                    / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Implied        |   TSC                 |   $3B   |    1    |     2    |
  +----------------+-----------------------+---------+---------+----------+


  TXY                  TXY Transfer Index X to Index Y                  TXY

 65816 only!
                                                        N V M X D I Z C
  Operation:  X -> Y                                    / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Implied        |   TXY                 |   $9B   |    1    |     2    |
  +----------------+-----------------------+---------+---------+----------+


  TYX                  TYX Transfer Index Y to Index X                  TYX

 65816 only!
                                                        N V M X D I Z C
  Operation:  Y -> X                                    / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Implied        |   TYX                 |   $BB   |    1    |     2    |
  +----------------+-----------------------+---------+---------+----------+


  XCE               XCE Exchange Carry and Emulation Bits               XCE

 65816 only!
                                                        N V M X D I Z C
  Operation:                                            . . . . . . . /

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Implied        |   XCE                 |   $FB   |    1    |     2    |
  +----------------+-----------------------+---------+---------+----------+


  STZ                      STZ Store zero in memory                     STZ

 65816 only!
                                                        N V M X D I Z C
  Operation:  0 -> M                                    . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Absolute       |   STZ $FFFF           |   $9C   |    3    |    4     |
  | Absolute,X     |   STZ $FFFF,X         |   $9E   |    3    |    5     |
  | Direct Page    |   STZ $FF             |   $64   |    2    |    3     |
  | Direct Page,X  |   STZ $FF,X           |   $74   |    2    |    4     |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.


  TSB                       TSB Test and Set Bit                        TSB

 65816 only!
                                                        N V M X D I Z C
  Operation:  A V W -> W                                . . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Absolute       |   TSB $FFFF           |   $0C   |    3    |    4     |
  | Direct Page    |   TSB $FF             |   $04   |    2    |    3     |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.


  TRB                      TRB Test and Reset Bit                       TRB

 65816 only!
                                                        N V M X D I Z C
  Operation:  /A /\ W -> W                              . . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  | Absolute       |   TRB $FFFF           |   $1C   |    3    |    4     |
  | Direct Page    |   TRB $FF             |   $14   |    2    |    3     |
  +----------------+-----------------------+---------+---------+----------+
  For penalty cycles on the 65816, check the desired addressing mode.


  +-------------------------------------------------------------------------
  |
  |      6510 CPU ILLEGAL INSTRUCTION SET
  |
  +-------------------------------------------------------------------------
  |
  |  Related topics:
  |
  |   6510 instruction set
  |   6510 instruction chart
  |
  |   65816 extended instruction set
  |   65816 instruction chart
  |
  |   6510/65816 Addressing modes
  |
  |  Instructions set:
  |
  |     ANC   AND #immediate, copy accu-bit 7 to carry
  |     ANE   Instable!
  |     ARR   AND #immediate, ROR accu
  |     ASR   AND #immediate, LSR accu
  |
  |     DCP   DEC memory, CMP memory
  |
  |     ISB   INC memory, SBC memory
  |
  |     JAM   Locks up machine
  |
  |     LAE   Instable!
  |     LAX   LDA memory, TAX
  |     LXA   Instable!
  |
  |     NOP   No operation
  |
  |     RLA   ROL memory, AND memory
  |     RRA   ROR memory, ADC memory
  |
  |     SAX   Accu AND X-Register into memory
  |     SBC   Subtract memory from accumulator with borrow
  |     SBX   Accu AND X-Register, subtract operand, result into X-Register
  |     SHA   Instable!
  |     SHS   Instable!
  |     SHX   Instable!
  |     SHY   Instable!
  |     SLO   ASL memory, ORA memory
  |     SRE   LSR memory, EOR memory
  |
  +-------------------------------------------------------------------------



  JAM                                                                   JAM

                                                        N V - B D I Z C
  Operation:  [locks up machine]                         who cares? :)

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Implied       |   JAM                 |   $02   |    1    |    -     |
  |  Implied       |   JAM                 |   $12   |    1    |    -     |
  |  Implied       |   JAM                 |   $22   |    1    |    -     |
  |  Implied       |   JAM                 |   $32   |    1    |    -     |
  |  Implied       |   JAM                 |   $42   |    1    |    -     |
  |  Implied       |   JAM                 |   $52   |    1    |    -     |
  |  Implied       |   JAM                 |   $62   |    1    |    -     |
  |  Implied       |   JAM                 |   $72   |    1    |    -     |
  |  Implied       |   JAM                 |   $92   |    1    |    -     |
  |  Implied       |   JAM                 |   $B2   |    1    |    -     |
  |  Implied       |   JAM                 |   $D2   |    1    |    -     |
  |  Implied       |   JAM                 |   $F2   |    1    |    -     |
  +----------------+-----------------------+---------+---------+----------+

  Also known as CRS, KIL, HLT.

  Note: Data Bus will be set to $FF


  SLO                   SLO ASL memory, ORA memory                      SLO

                                                        N V - B D I Z C
  Operation:  A <- (M << 1) \/ A                        / . . . . . / /

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  ZeroPage      |   SLO $FF             |   $07   |    2    |    5     |
  |  ZeroPage,X    |   SLO $FF,X           |   $17   |    2    |    6     |
  |  Absolute      |   SLO $FFFF           |   $0F   |    3    |    6     |
  |  Absolute,X    |   SLO $FFFF,X         |   $1F   |    3    |    7     |
  |  Absolute,Y    |   SLO $FFFF,Y         |   $1B   |    3    |    7     |
  |  (Indirect,X)  |   SLO ($FF,X)         |   $03   |    2    |    8     |
  |  (Indirect),Y  |   SLO ($FF),Y         |   $13   |    2    |    8     |
  +----------------+-----------------------+---------+---------+----------+

  Also known as ASO.


  ANC           ANC AND #immediate, copy accu-bit 7 to carry            ANC

                                                        N V - B D I Z C
  Operation:  A <- A /\ M, C <- A7                      / . . . . . / A7

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Immediate     |   ANC #$FF            |   $0B   |    2    |    2     |
  |  Immediate     |   ANC #$FF            |   $2B   |    2    |    2     |
  +----------------+-----------------------+---------+---------+----------+


  RLA                   RLA ROL memory, AND memory                      RLA

                                                        N V - B D I Z C
  Operation:  A <- (M << 1) /\ (A)                      / . . . . . / /

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  ZeroPage      |   RLA $FF             |   $27   |    2    |    5     |
  |  ZeroPage,X    |   RLA $FF,X           |   $37   |    2    |    6     |
  |  Absolute      |   RLA $FFFF           |   $2F   |    3    |    6     |
  |  Absolute,X    |   RLA $FFFF,X         |   $3F   |    3    |    7     |
  |  Absolute,Y    |   RLA $FFFF,Y         |   $3B   |    3    |    7     |
  |  (Indirect,X)  |   RLA ($FF,X)         |   $23   |    2    |    8     |
  |  (Indirect),Y  |   RLA ($FF),Y         |   $33   |    2    |    8     |
  +----------------+-----------------------+---------+---------+----------+


  SRE                   SRE LSR memory, EOR memory                      SRE

                                                        N V - B D I Z C
  Operation:  A <- (M >> 1) \-/ A                       / . . . . . / /

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  ZeroPage      |   SRE $FF             |   $47   |    2    |    5     |
  |  ZeroPage,X    |   SRE $FF,X           |   $57   |    2    |    6     |
  |  Absolute      |   SRE $FFFF           |   $4F   |    3    |    6     |
  |  Absolute,X    |   SRE $FFFF,X         |   $5F   |    3    |    7     |
  |  Absolute,Y    |   SRE $FFFF,Y         |   $5B   |    3    |    7     |
  |  (Indirect,X)  |   SRE ($FF,X)         |   $43   |    2    |    8     |
  |  (Indirect),Y  |   SRE ($FF),Y         |   $53   |    2    |    8     |
  +----------------+-----------------------+---------+---------+----------+

  Also known as LSE.


  ASR                   ASR AND #immediate, LSR accu                    ASR

                                                        N V - B D I Z C
  Operation:  A <- [(A /\ M) >> 1]                      / . . . . . / /

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Immediate     |   ASR #$FF            |   $4B   |    2    |    2     |
  +----------------+-----------------------+---------+---------+----------+

  Also known as ALR.


  RRA                   RRA ROR memory, ADC memory                      RRA

                                                        N V - B D I Z C
  Operation:  A <- (M >> 1) + (A) + C                   / / . . . . / /

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  ZeroPage      |   RRA $FF             |   $67   |    2    |    5     |
  |  ZeroPage,X    |   RRA $FF,X           |   $77   |    2    |    6     |
  |  Absolute      |   RRA $FFFF           |   $6F   |    3    |    6     |
  |  Absolute,X    |   RRA $FFFF,X         |   $7F   |    3    |    7     |
  |  Absolute,Y    |   RRA $FFFF,Y         |   $7B   |    3    |    7     |
  |  (Indirect,X)  |   RRA ($FF,X)         |   $63   |    2    |    8     |
  |  (Indirect),Y  |   RRA ($FF),Y         |   $73   |    2    |    8     |
  +----------------+-----------------------+---------+---------+----------+


  ARR                   ARR AND #immediate, ROR accu                    ARR

                                                        N V - B D I Z C
  Operation:  A <- [(A /\ M) >> 1]                      / / . . . . / /

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Immediate     |   ARR #$FF            |   $6B   |    2    |    2     |
  +----------------+-----------------------+---------+---------+----------+

  Note: Part of this command are some ADC mechanisms. Following effects
  appear after AND but before ROR: the V-Flag is set according to
  [(A and #mem)+#mem], Bit 0 does NOT go into carry, but Bit 7 is
  exchanged with the carry.


  SAX                SAX Accu AND X-Register into memory                SAX

                                                        N V - B D I Z C
  Operation:  M <- (A) /\ (X)                           . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  ZeroPage      |   SAX $FF             |   $87   |    2    |    3     |
  |  ZeroPage,Y    |   SAX $FF,Y           |   $97   |    2    |    4     |
  |  Absolute      |   SAX $FFFF           |   $8F   |    3    |    4     |
  |  (Indirect,X)  |   SAX ($FF,X)         |   $83   |    2    |    6     |
  +----------------+-----------------------+---------+---------+----------+

  Note: The A /\ X operation is a result of A and X put onto the bus
  at the same time.


  ANE                                                                   ANE

                                                        N V - B D I Z C
  Operation:  M <- [(A)/\$EE] \/ (X)/\(M)               / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Immediate     |   ANE #$FF            |   $8B   |    2    |    2     |
  +----------------+-----------------------+---------+---------+----------+

  Also known as XAA: A <- [(X) /\ (M)]

  Warning: This opcode is said to be unstable!


  SHA                                                                   SHA

                                                        N V - B D I Z C
  Operation:  M <- (A) /\ (X) /\ (PCH+1)                . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Absolute,X    |   SHA $FFFF,X         |   $93   |    3    |    5     |
  |  Absolute,Y    |   SHA $FFFF,Y         |   $9F   |    3    |    5     |
  +----------------+-----------------------+---------+---------+----------+

  Also known as AHX

  Note: Sometimes the "/\ (PCH+1)" drops off. Also page boundary crossing
  won't work as expected (the bank where the value is stored may be equal
  to the value stored).

  Warning: This opcode is said to be unstable!


  SHS                                                                   SHS

  Operation:  X <- (A) /\ (X), S <- (X)                 N V - B D I Z C
              M <- (X) /\ (PCH+1)                       . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Absolute,Y    |   SHS $FFFF,Y         |   $9B   |    3    |    5     |
  +----------------+-----------------------+---------+---------+----------+

  Also known as TAS.

  Warning: This opcode is said to be unstable!


  SHY                                                                   SHY

                                                        N V - B D I Z C
  Operation:  M <- (Y) /\ (PCH+1)                       . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Absolute,X    |   SHY $FFFF,X         |   $9C   |    3    |    5     |
  +----------------+-----------------------+---------+---------+----------+

  Note: Sometimes the "/\ (PCH+1)" drops off. Also page boundary crossing
  won't work as expected (the bank where the value is stored may be equal
  to the value stored).

  Warning: This opcode is said to be unstable!


  SHX                                                                   SHX

                                                        N V - B D I Z C
  Operation:  M <- (X) /\ (PCH+1)                       . . . . . . . .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Absolute,Y    |   SHX $FFFF,Y         |   $9E   |    3    |    5     |
  +----------------+-----------------------+---------+---------+----------+

  Note: Sometimes the "/\ (PCH+1)" drops off. Also page boundary crossing
  won't work as expected (the bank where the value is stored may be equal
  to the value stored).

  Warning: This opcode is said to be unstable!


  LAX                        LAX LDA memory, TAX                        LAX

                                                        N V - B D I Z C
  Operation:  A <- M, X <- A                            / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  ZeroPage      |   LAX $FF             |   $A7   |    2    |    3     |
  |  ZeroPage,Y    |   LAX $FF,Y           |   $B7   |    2    |    4     |
  |  Absolute      |   LAX $FFFF           |   $AF   |    3    |    4     |
  |  Absolute,Y    |   LAX $FFFF,Y         |   $BF   |    3    |    4*    |
  |  (Indirect,X)  |   LAX ($FF,X)         |   $A3   |    2    |    6     |
  |  (Indirect),Y  |   LAX ($FF),Y         |   $B3   |    2    |    5*    |
  +----------------+-----------------------+---------+---------+----------+
  * Add 1 if page boundary is crossed.


  LXA                                                                   LXA

  Operation:  X04 <- (X04) /\ M04                       N V - B D I Z C
              A04 <- (A04) /\ M04                       / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Immediate     |   LXA #$FF            |   $AB   |    2    |    2     |
  +----------------+-----------------------+---------+---------+----------+

  Also known as LAX #$FF (immediate).

  Warning: This opcode is said to be unstable!


  LAE            LAE Stack-Pointer AND with memory, TSX, TXA            LAE

                                                        N V - B D I Z C
  Operation:  S,X,A <- (S /\ M)                         / . . . . . / .

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Absolute,Y    |   LAE $FFFF,Y         |   $BB   |    3    |    4*    |
  +----------------+-----------------------+---------+---------+----------+
  * Add 1 if page boundary is crossed.

  Also known as LAS, LAR.

  Warning: This opcode is said to be unstable!


  DCP                    DCP DEC memory, CMP memory                     DCP

                                                        N V - B D I Z C
  Operation:  M <- (M)-1, (A-M) -> NZC                  / . . . . . / /

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  ZeroPage      |   DCP $FF             |   $C7   |    2    |    5     |
  |  ZeroPage,X    |   DCP $FF,X           |   $D7   |    2    |    6     |
  |  Absolute      |   DCP $FFFF           |   $CF   |    3    |    6     |
  |  Absolute,X    |   DCP $FFFF,X         |   $DF   |    3    |    7     |
  |  Absolute,Y    |   DCP $FFFF,Y         |   $DB   |    3    |    7     |
  |  (Indirect,X)  |   DCP ($FF,X)         |   $C3   |    2    |    8     |
  |  (Indirect),Y  |   DCP ($FF),Y         |   $D3   |    2    |    8     |
  +----------------+-----------------------+---------+---------+----------+


  SBX SBX Accu AND X-Register, subtract operand, result into X-Register SBX

                                                        N V - B D I Z C
  Operation:  X <- (X)/\(A) - M                         / . . . . . / /

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  Immediate     |   SBX #$FF            |   $CB   |    2    |    2     |
  +----------------+-----------------------+---------+---------+----------+

  Note: Performs CMP and DEX at the same time, so the subtraction
  ignores flags 'C' and 'D' (like CMP, unlike SBC).

  Also known as AXS.


  ISB                    ISB INC memory, SBC memory                     ISB

                                                        N V - B D I Z C
  Operation:  M <- (M) + 1, A <- (A) - M - ~C           / / . . . . / /

  +----------------+-----------------------+---------+---------+----------+
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  +----------------+-----------------------+---------+---------+----------+
  |  ZeroPage      |   ISB $FF             |   $E7   |    2    |    5     |
  |  ZeroPage,X    |   ISB $FF,X           |   $F7   |    2    |    6     |
  |  Absolute      |   ISB $FFFF           |   $EF   |    3    |    6     |
  |  Absolute,X    |   ISB $FFFF,X         |   $FF   |    3    |    7     |
  |  Absolute,Y    |   ISB $FFFF,Y         |   $FB   |    3    |    7     |
  |  (Indirect,X)  |   ISB ($FF,X)         |   $E3   |    2    |    8     |
  |  (Indirect),Y  |   ISB ($FF),Y         |   $F3   |    2    |    8     |
  +----------------+-----------------------+---------+---------+----------+

  Also known as ISC.


6510 instruction chart:

 Hi                                                                   Low
   +-------+--------+-------+---------+--------+--------+--------+--------+
   |   0   |    1   |   2   |    3    |    4   |   5    |   6    |    7   |
 --+-------+--------+-------+---------+--------+--------+--------+--------+
 0 | BRK s |ORA(z,x)| JAM i | SLO(z,x)| NOP z  | ORA z  | ASL z  | SLO z  |
   |  2 7  |  2 6   |  1 -  |   2 8   |  2 3   |  2 3   |  2 5   |  2 5   |
   +-------+--------+-------+---------+--------+--------+--------+--------+
 1 | BPL r |ORA(z),y| JAM i | SLO(z),y| NOP z,x| ORA z,x| ASL z,x| SLO z,x|
   |  2 2* |  2 5*  |  1 -  |   2 8   |  2 4   |  2 4   |  2 6   |  2 6   |
   +-------+--------+-------+---------+--------+--------+--------+--------+
 2 | JSR a |AND(z,x)| JAM i | RLA(z,x)| BIT z  | AND z  | ROL z  | RLA z  |
   |  3 6  |  2 6   |  1 -  |   2 8   |  2 3   |  2 3   |  2 5   |  2 5   |
   +-------+--------+-------+---------+--------+--------+--------+--------+
 3 | BMI r |AND(z),y| JAM i | RLA(z),y| NOP z,x| AND z,x| ROL z,x| RLA z,x|
   |  2 2* |  2 5*  |  1 -  |   2 8   |  2 4   |  2 4   |  2 6   |  2 6   |
   +-------+--------+-------+---------+--------+--------+--------+--------+
 4 | RTI s |EOR(z,x)| JAM i | SRE(z,x)| NOP z  | EOR z  | LSR z  | SRE z  |
   |  1 6  |  2 6   |  1 -  |   2 8   |  2 3   |  2 3   |  2 5   |  2 5   |
   +-------+--------+-------+---------+--------+--------+--------+--------+
 5 | BVC r |EOR(z),y| JAM i | SRE(z),y| NOP z,x| EOR z,x| LSR z,x| SRE z,x|
   |  2 2* |  2 5*  |  1 -  |   2 8   |  2 4   |  2 4   |  2 6   |  2 6   |
   +-------+--------+-------+---------+--------+--------+--------+--------+
 6 | RTS s |ADC(z,x)| JAM i | RRA(z,x)| NOP z  | ADC z  | ROR z  | RRA z  |
   |  1 6  |  2 6   |  1 -  |   2 8   |  2 3   |  2 3   |  2 5   |  2 5   |
   +-------+--------+-------+---------+--------+--------+--------+--------+
 7 | BVS r |ADC(z),y| JAM i | RRA(z),y| NOP z,x| ADC z,x| ROR z,x| RRA z,x|
   |  2 2* |  2 5*  |  1 -  |   2 8   |  2 4   |  2 4   |  2 6   |  2 6   |
   +-------+--------+-------+---------+--------+--------+--------+--------+
 8 | NOP # |STA(z,x)| NOP # | SAX(z,x)| STY z  | STA z  | STX z  | SAX z  |
   |  2 2  |  2 6   |  2 2  |   2 6   |  2 3   |  2 3   |  2 3   |  2 3   |
   +-------+--------+-------+---------+--------+--------+--------+--------+
 9 | BCC r |STA(z),y| JAM i | SHA a,x | STYz,x | STA z,x| STX z,y| SAX z,y|
   |  2 2* |  2 6   |  1 -  |!  3 5  !|  2 4   |  2 4   |  2 4   |  2 4   |
   +-------+--------+-------+---------+--------+--------+--------+--------+
 A | LDY # |LDA(z,x)| LDX # | LAX(z,x)| LDY z  | LDA z  | LDX z  | LAX z  |
   |  2 2  |  2 6   |  2 2  |   2 6   |  2 3   |  2 3   |  2 3   |  2 3   |
   +-------+--------+-------+---------+--------+--------+--------+--------+
 B | BCS r |LDA(z),y| JAM i | LAX(z),y| LDY z,x| LDA z,x| LDX z,y| LAX z,y|
   |  2 2* |  2 5*  |  1 -  |   2 5*  |  2 4   |  2 4   |  2 4   |  2 4   |
   +-------+--------+-------+---------+--------+--------+--------+--------+
 C | CPY # |CMP(z,x)| NOP # | DCP(z,x)| CPY z  | CMP z  | DEC z  | DCP z  |
   |  2 2  |  2 6   |  2 2  |   2 8   |  2 3   |  2 3   |  2 5   |  2 5   |
   +-------+--------+-------+---------+--------+--------+--------+--------+
 D | BNE r |CMP(z),y| JAM i | DCP(z),y| NOP z,x| CMP z,x| DEC z,x| DCP z,x|
   |  2 2* |  2 5*  |  1 -  |   2 8   |  2 4   |  2 4   |  2 6   |  2 6   |
   +-------+--------+-------+---------+--------+--------+--------+--------+
 E | CPX # |SBC(z,x)| NOP # | ISB(z,x)| CPX z  | SBC z  | INC z  | ISB z  |
   |  2 2  |  2 6   |  2 2  |   2 8   |  2 3   |  2 3   |  2 5   |  2 5   |
   +-------+--------+-------+---------+--------+--------+--------+--------+
 F | BEQ r |SBC(z),y| JAM i | ISB(z),y| NOP z,x| SBC z,x| INC z,x| ISB z,x|
   |  2 2* |  2 5*  |  1 -  |   2 8   |  2 4   |  2 4   |  2 6   |  2 6   |
   +-------+--------+-------+---------+--------+--------+--------+--------+
   |   0   |    1   |   2   |    3    |    4   |   5    |   6    |    7   |
   +-------+--------+-------+---------+--------+--------+--------+--------+

 Hi                                                                 Low
   +-------+--------+-------+-------+--------+--------+--------+--------+
   |   8   |   9    |   A   |   B   |   C    |   D    |    E   |    F   |
 --+-------+--------+-------+-------+--------+--------+--------+--------+
 0 | PHP s | ORA #  | ASL A | ANC # | NOP a  | ORA a  | ASL a  | SLO a  |
   |  1 3  |  2 2   |  1 2  |  2 2  |  3 4   |  3 4   |  3 6   |  3 6   |
   +-------+--------+-------+-------+--------+--------+--------+--------+
 1 | CLC i | ORA a,y| NOP i |SLO a,y| NOP a,x| ORA a,x| ASL a,x| SLO a,x|
   |  1 2  |  3 4*  |  1 2  |  3 7  |  3 4*  |  3 4*  |  3 7   |  3 7   |
   +-------+--------+-------+-------+--------+--------+--------+--------+
 2 | PLP s | AND #  | ROL A | ANC # | BIT a  | AND a  | ROL a  | RLA a  |
   |  1 4  |  2 2   |  1 2  |  2 2  |  3 4   |  3 4   |  3 6   |  3 6   |
   +-------+--------+-------+-------+--------+--------+--------+--------+
 3 | SEC i | AND a,y| NOP i |RLA a,y| NOP a,x| AND a,x| ROL a,x| RLA a,x|
   |  1 2  |  3 4*  |  1 2  |  3 7  |  3 4*  |  3 4*  |  3 7   |  3 7   |
   +-------+--------+-------+-------+--------+--------+--------+--------+
 4 | PHA s | EOR #  | LSR A | ASR # | JMP a  | EOR a  | LSR a  | SRE a  |
   |  1 3  |  2 2   |  1 2  |  2 2  |  3 3   |  3 4   |  3 6   |  3 6   |
   +-------+--------+-------+-------+--------+--------+--------+--------+
 5 | CLI i | EOR a,y| NOP i |SRE a,y| NOP a,x| EOR a,x| LSR a,x| SRE a,x|
   |  1 2  |  3 4*  |  1 2  |  3 7  |  3 4*  |  3 4*  |  3 7   |  3 7   |
   +-------+--------+-------+-------+--------+--------+--------+--------+
 6 | PLA s | ADC #  | ROR A | ARR # | JMP (a)| ADC a  | ROR a  | RRA a  |
   |  1 4  |  2 2   |  1 2  |  2 2  |  3 5   |  3 4   |  3 6   |  3 6   |
   +-------+--------+-------+-------+--------+--------+--------+--------+
 7 | SEI i | ADC a,y| NOP i |RRA a,y| NOP a,x| ADC a,x| ROR a,x| RRA a,x|
   |  1 2  |  3 4*  |  1 2  |  3 7  |  3 4*  |  3 4*  |  3 7   |  3 7   |
   +-------+--------+-------+-------+--------+--------+--------+--------+
 8 | DEY i | NOP #  | TXA i | ANE # | STY a  | STA a  | STX a  | SAX a  |
   |  1 2  |  2 2   |  1 2  |  2 2  |  3 4   |  3 4   |  3 4   |  3 4   |
   +-------+--------+-------+-------+--------+--------+--------+--------+
 9 | TYA i | STA a,y| TXS i |SHS a,x| SHY a,y| STA a,x| SHX a,y| SHA a,y|
   |  1 2  |  3 5   |  1 2  |! 3 5 !|! 3 5  !|  3 5   |! 3 5  !|! 3 5  !|
   +-------+--------+-------+-------+--------+--------+--------+--------+
 A | TAY i | LDA #  | TAX i | LXA # | LDY a  | LDA a  | LDX a  | LAX a  |
   |  1 2  |  2 2   |  1 2  |! 2 2 !|  3 4   |  3 4   |  3 4   |  3 4   |
   +-------+--------+-------+-------+--------+--------+--------+--------+
 B | CLV i | LDA a,y| TSX i |LAE a,y| LDY a,x| LDA a,x| LDX a,y| LAX a,y|
   |  1 2  |  3 4*  |  1 2  |! 3 4*!|  3 4   |  3 4*  |  3 4*  |  3 4*  |
   +-------+--------+-------+-------+--------+--------+--------+--------+
 C | INY i | CMP #  | DEX i | SBX # | CPY a  | CMP a  | DEC a  | DCP a  |
   | 1 2   |  2 2   |  1 2  |  2 2  |  3 4   |  3 4   |  3 4   |  3 6   |
   +-------+--------+-------+-------+--------+--------+--------+--------+
 D | CLD i | CMP a,y| NOP i |DCP a,y| NOP a,x| CMP a,x| DEC a,x| DCP a,x|
   |  1 2  |  3 4*  |  1 2  |  3 7  |  3 4*  |  3 4*  |  3 7   |  3 7   |
   +-------+--------+-------+-------+--------+--------+--------+--------+
 E | INX i | SBC #  | NOP i | SBC # | CPX a  | SBC a  | INC a  | ISB a  |
   |  1 2  |  2 2   |  1 2  |  2 2  |  3 4   |  3 4   |  3 6   |  3 6   |
   +-------+--------+-------+-------+--------+--------+--------+--------+
 F | SED i | SBC a,y| NOP i |ISB a,y| NOP a,x| SBC a,x| INC a,x| ISB a,x|
   |  1 2  |  3 4*  |  1 2  |  3 7  |  3 4*  |  3 4*  |  3 7   |  3 7   |
   +-------+--------+-------+-------+--------+--------+--------+--------+
   |   8   |   9    |   A   |   B   |   C    |   D    |    E   |    F   |
   +-------+--------+-------+-------+--------+--------+--------+--------+

   * = Opcode may need more cycles      ! = Unstable opcode!


65816 instruction chart:

 Hi                                                                      Low
   +-------+--------+--------+----------+--------+--------+--------+---------+
   |   0   |    1   |   2    |    3     |    4   |   5    |   6    |    7    |
 --+-------+--------+--------+----------+--------+--------+--------+---------+
 0 | BRK s |ORA(d,x)| COP s  | ORA d,s  | TSB d  | ORA d  | ASL d  | ORA [d] |
   |  2 8  |  2 6   |  2 8   |   2 4    |  2 5   |  2 3   |  2 5   |   2 6   |
   +-------+--------+--------+----------+--------+--------+--------+---------+
 1 | BPL r |ORA(d),y| ORA(d) |ORA(d,s),y| TRB d  | ORA d,x| ASL d,x|ORA [d],y|
   |  2 2  |  2 5   |  2 5   |   2 7    |  2 5   |  2 4   |  2 6   |   2 6   |
   +-------+--------+--------+----------+--------+--------+--------+---------+
 2 | JSR a |AND(d,x)| JSL al | AND d,s  | BIT d  | AND d  | ROL d  | AND [d] |
   |  3 6  |  2 6   |  4 8   |   2 4    |  2 3   |  2 3   |  2 5   |  2 6    |
   +-------+--------+--------+----------+--------+--------+--------+---------+
 3 | BMI r |AND(d),y| AND (d)|AND(d,s),y| BIT d,x| AND d,x| ROL d,x|AND [d],y|
   |  2 2  |  2 5   |  2 5   |   2 7    |  2 4   |  2 4   |  2 6   |  2 6    |
   +-------+--------+--------+----------+--------+--------+--------+---------+
 4 | RTI s |EOR(d,x)| reserve| EOR d,s  | MVP xya| EOR d  | LSR d  | EOR [d] |
   |  1 7  |  2 6   |  2 2   |   2 4    |  3 7   |  2 3   |  2 5   |  2 6    |
   +-------+--------+--------+----------+--------+--------+--------+---------+
 5 | BVC r |EOR(d),y| EOR (d)|EOR(d,s),y| MVN xya| EOR d,x| LSR d,x|EOR [d],y|
   |  2 2  |  2 5   |  2 5   |   2 7    |  3 7   |  2 4   |  2 6   |  2 6    |
   +-------+--------+--------+----------+--------+--------+--------+---------+
 6 | RTS s |ADC(d,x)| PER s  | ADC d,s  | STZ d  | ADC d  | ROR d  | ADC [d] |
   |  1 6  |  2 6   |  3 6   |   2 4    |  2 3   |  2 3   |  2 5   |  2 6    |
   +-------+--------+--------+----------+--------+--------+--------+---------+
 7 | BVS r |ADC(d),y| ADC (d)|ADC(d,s),y| STZ d,x| ADC d,x| ROR d,x|ADC [d],y|
   |  2 2  |  2 5   |  2 5   |   2 7    |  2 4   |  2 4   |  2 6   |  2 6    |
   +-------+--------+--------+----------+--------+--------+--------+---------+
 8 | BRA r |STA(d,x)| BRL rl | STA d,s  | STY d  | STA d  | STX d  | STA [d] |
   |  2 2  |  2 6   |  3 3   |   2 4    |  2 3   |  2 3   |  2 3   |  2 6    |
   +-------+--------+--------+----------+--------+--------+--------+---------+
 9 | BCC r |STA(d),y| STA (d)|STA(d,s),y| STYd,x | STA d,x| STX d,y|STA [d],y|
   |  2 2  |  2 6   |  2 5   |   2 7    |  2 4   |  2 4   |  2 4   |  2 6    |
   +-------+--------+--------+----------+--------+--------+--------+---------+
 A | LDY # |LDA(d,x)|  LDX # | LDA d,s  | LDY d  | LDA d  | LDX d  | LDA [d] |
   |  2 2  |  2 6   |  2 2   |   2 4    |  2 3   |  2 3   |  2 3   |  2 6    |
   +-------+--------+--------+----------+--------+--------+--------+---------+
 B | BCS r |LDA(d),y| LDA (d)|LDA(d,s),y| LDY d,x| LDA d,x| LDX d,y|LDA [d],y|
   |  2 2  |  2 5   |  2 5   |   2 7    |  2 4   |  2 4   |  2 4   |  2 6    |
   +-------+--------+--------+----------+--------+--------+--------+---------+
 C | CPY # |CMP(d,x)| REP #  | CMP d,s  | CPY d  | CMP d  | DEC d  | CMP [d] |
   |  2 2  |  2 6   |  2 3   |   2 4    |  2 3   |  2 3   |  2 5   |  2 6    |
   +-------+--------+--------+----------+--------+--------+--------+---------+
 D | BNE r |CMP(d),y| CMP (d)|CMP(d,s),y| PEI s  | CMP d,x| DEC d,x|CMP [d],y|
   |  2 2  |  2 5   |  2 5   |   2 7    |  2 6   |  2 4   |  2 6   |  2 6    |
   +-------+--------+--------+----------+--------+--------+--------+---------+
 E | CPX # |SBC(d,x)| SEP #  | SBC d,s  | CPX d  | SBC d  | INC d  | SBC [d] |
   |  2 2  |  2 6   |  2 3   |   2 4    |  2 3   |  2 3   |  2 5   |  2 6    |
   +-------+--------+--------+----------+--------+--------+--------+---------+
 F | BEQ r |SBC(d),y| SBC (d)|SBC(d,s),y| PEA s  | SBC d,x| INC d,x|SBC [d],y|
   |  2 2  |  2 5   |  2 5   |   2 7    |  3 5   |  2 4   |  2 6   |   2 6   |
   +-------+--------+--------+----------+--------+--------+--------+---------+
   |   0   |    1   |   2    |    3     |    4   |   5    |   6    |    7    |
   +-------+--------+--------+----------+--------+--------+--------+---------+

 Hi                                                                  Low
   +-------+--------+-------+-------+--------+--------+--------+---------+
   |   8   |   9    |   A   |   B   |   C    |   D    |    E   |    F    |
 --+-------+--------+-------+-------+--------+--------+--------+---------+
 0 | PHP s | ORA #  | ASL A | PHD s | TSB a  | ORA a  | ASL a  | ORA al  |
   |  1 3  |  2 2   |  1 2  |  1 4  |  3 6   |  3 4   |  3 6   |   4 5   |
   +-------+--------+-------+-------+--------+--------+--------+---------+
 1 | CLC i | ORA a,y| INC A | TCS i | TRB a  | ORA a,x| ASL a,x| ORA al,x|
   |  1 2  |  3 4   |  1 2  |  1 2  |  3 6   |  3 4   |  3 7   |   4 5   |
   +-------+--------+-------+-------+--------+--------+--------+---------+
 2 | PLP s | AND #  | ROL A | PLD s | BIT a  | AND a  | ROL a  | AND al  |
   |  1 4  |  2 2   |  1 2  |  1 5  |  3 4   |  3 4   |  3 6   |   4 5   |
   +-------+--------+-------+-------+--------+--------+--------+---------+
 3 | SEC i | AND a,y| DEC A | TSC i | BIT a,x| AND a,x| ROL a,x| AND al,x|
   |  1 2  |  3 4   |  1 2  |  1 2  |  3 4   |  3 4   |  3 7   |   4 5   |
   +-------+--------+-------+-------+--------+--------+--------+---------+
 4 | PHA s | EOR #  | LSR A | PHK s | JMP a  | EOR a  | LSR a  | EOR al  |
   |  1 3  |  2 2   |  1 2  |  1 3  |  3 3   |  3 4   |  3 6   |   4 5   |
   +-------+--------+-------+-------+--------+--------+--------+---------+
 5 | CLI i | EOR a,y| PHY s | TCD i | JMP al | EOR a,x| LSR a,x| EOR al,x|
   |  1 2  |  3 4   |  1 3  |  1 2  |  4 4   |  3 4   |  3 7   |   4 5   |
   +-------+--------+-------+-------+--------+--------+--------+---------+
 6 | PLA s | ADC #  | ROR A | RTL s | JMP (a)| ADC a  | ROR a  | ADC al  |
   |  1 4  |  2 2   |  1 2  |  1 6  |  3 5   |  3 4   |  3 6   |   4 5   |
   +-------+--------+-------+-------+--------+--------+--------+---------+
 7 | SEI i | ADC a,y| PLY s | TDC i |JMP(a,x)| ADC a,x| ROR a,x| ADC al,x|
   |  1 2  |  3 4   |  1 4  |  1 2  |  3 6   |  3 4   |  3 7   |   4 5   |
   +-------+--------+-------+-------+--------+--------+--------+---------+
 8 | DEY i | BIT #  | TXA i | PHB s | STY a  | STA a  | STX a  | STA al  |
   |  1 2  |  2 2   |  1 2  |  1 3  |  3 4   |  3 4   |  3 4   |   4 5   |
   +-------+--------+-------+-------+--------+--------+--------+---------+
 9 | TYA i | STA a,y| TXS i | TXY i | STZ a  | STA a,x| STZ a,x| STA al,x|
   |  1 2  |  3 5   |  1 2  |  1 2  |  3 4   |  3 5   |  3 5   |   4 5   |
   +-------+--------+-------+-------+--------+--------+--------+---------+
 A | TAY i | LDA #  | TAX i | PLB s | LDY a  | LDA a  | LDX a  | LDA al  |
   |  1 2  |  2 2   |  1 2  |  1 4  |  3 4   |  3 4   |  3 4   |   4 5   |
   +-------+--------+-------+-------+--------+--------+--------+---------+
 B | CLV i | LDA a,y| TSX i | TYX i | LDY a,x| LDA a,x| LDX a,y| LDA al,x|
   |  1 2  |  3 4   |  1 2  |  1 2  |  3 4   |  3 4   |  3 4   |   4 5   |
   +-------+--------+-------+-------+--------+--------+--------+---------+
 C | INY i | CMP #  | DEX i | WAI i | CPY a  | CMP a  | DEC a  | CMP al  |
   | 1 2   |  2 2   |  1 2  |  1 3  |  3 4   |  3 4   |  3 4   |   4 5   |
   +-------+--------+-------+-------+--------+--------+--------+---------+
 D | CLD i | CMP a,y| PHX s | STP i | JML (a)| CMP a,x| DEC a,x| CMP al,x|
   |  1 2  |  3 4   |  1 3  |  1 3  |  3 6   |  3 4   |  3 7   |   4 5   |
   +-------+--------+-------+-------+--------+--------+--------+---------+
 E | INX i | SBC #  | NOP i | XBA i | CPX a  | SBC a  | INC a  | SBC al  |
   |  1 2  |  2 2   |  1 2  |  1 3  |  3 4   |  3 4   |  3 6   |   4 5   |
   +-------+--------+-------+-------+--------+--------+--------+---------+
 F | SED i | SBC a,y| PLX s | XCE i |JSR(a,x)| SBC a,x| INC a,x| SBC al,x|
   |  1 2  |  3 4   |  1 4  |  1 2  |  3 6   |  3 4   |  3 7   |   4 5   |
   +-------+--------+-------+-------+--------+--------+--------+---------+
   |   8   |   9    |   A   |   B   |   C    |   D    |    E   |    F    |
   +-------+--------+-------+-------+--------+--------+--------+---------+


 (Note: Data is gained from 65816-documentation, but it is downward
        compatible. For the 6510 just ignore specs which do not apply.)

 6510/65816 Addressing modes:

  Absolute -- a
  Absolute (JMP) -- a
  Absolute (JSR) -- a
  Absolute (R-M-W) -- a
  Absolute Indexed -- a,x  a,y
  Absolute Indexed (R-M-W) -- a,x
  Absolute Indexed Indirect -- (a,x)
  Absolute Indirect -- (a)
  Accumulator -- A
  Immediate -- #
  Implied -- i
  Relative -- r
  Stack (Hardware Interrupts) -- s
  Stack (Software Interrupts) -- s
  Stack (Pull) -- s
  Stack (Push) -- s
  Stack (RTI) -- s
  Stack (RTS) -- s
  Zeropage/Direct -- d
  Zeropage/Direct (R-M-W) -- d
  Zeropage/Direct Indexed -- d,x  d,y
  Zeropage/Direct Indexed (R-M-W) -- d,x
  Zeropage/Direct Indexed Indirect -- (d,x)
  Zeropage/Direct Indirect Indexed -- (d),y

 6510 Illegal Addressing modes:

  Absolute Indexed (R-M-W) -- a,y
  Zeropage Indexed Indirect (R-M-W) -- (d,x)
  Zeropage Indirect Indexed (R-M-W) -- (d),y

 65816 Addressing modes:

  Absolute Indexed Indirect (JSR) -- (a,x)
  Absolute Indirect Long (JML) -- (a)
  Absolute Long -- al
  Absolute Long Indexed -- al,x
  Absolute Long (JMP) -- al
  Absolute Long (JSL) -- al
  Block Move Negative (backward) -- xyc
  Block Move Positive (forward) -- xyc
  Direct Indirect -- (d)
  Direct Indirect Long -- [d]
  Direct Indirect Indexed Long -- [d],y
  Implied (XBA) -- i
  Relative Long -- rl
  Stack (PEA) -- s
  Stack (PEI) -- s
  Stack (PER) -- s
  Stack (RTL) -- s
  Stack Relative -- d,s
  Stack Relative Indirect Indexed -- (d,s),y
  Stop the Clock (STP) -- h
  Wait for Interrupt (WAI) -- h


 6510/65816 Addressing mode: Immediate -- #

 (ADC,ANC,AND,ANE,ARR,ASR,BIT,CMP,CPX,CPY,EOR,LDA,LDX,LDY,LXA,NOP,ORA,
  REP,SBC,SBX,SEP)
 (2 and 3 bytes)  (2 and 3 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Immediate Data Low    |    R     |
    |       (1) 2a  |  PBR,PC+2        | Immediate Data High   |    R     |
    +---------------+------------------+-----------------------+----------+
    (1) Add 1 cycle and 1 byte for M=0 or X=0 (i.e. 16 bit data).

    See also: Abbreviations


 6510/65816 Addressing mode: Absolute -- a

 (ADC,AND,BIT,CMP,CPX,CPY,EOR,LAX,LDA,LDX,LDY,NOP,ORA,SAX,SBC,STA,STX,
  STY,STZ)
 (3 bytes)  (4 and 5 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Absolute Address Low  |    R     |
    |           3   |  PBR,PC+2        | Absolute Address High |    R     |
    |           4   |  DBR,AA          | Data Low              |   R/W    |
    |       (1) 4a  |  DBR,AA+1        | Data High             |   R/W    |
    +---------------+------------------+-----------------------+----------+
    (1) Add 1 cycle for M=0 or X=0 (i.e. 16 bit data).

    See also: Abbreviations


 6510/65816 Addressing mode: Absolute (R-M-W) -- a

 (ASL,DCP,DEC,INC,ISB,LSR,RLA,ROL,ROR,RRA,SLO,SRE,TRB,TSB)
 (3 bytes)  (6 and 8 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Absolute Address Low  |    R     |
    |           3   |  PBR,PC+2        | Absolute Address High |    R     |
    |           4   |  DBR,AA          | Data Low              |    R     |
    |       (1) 4a  |  DBR,AA+1        | Data High             |    R     |
    |   (12)(3) 5   |  DBR,AA+2        | Internal Operation    |    R     |
    |       (1) 6a  |  DBR,AA+1        | Data High             |    W     |
    |           6   |  DBR,AA          | Data Low              |    W     |
    +---------------+------------------+-----------------------+----------+
    (1) Add 1 cycle for M=0 or X=0 (i.e. 16 bit data).
    (3) Special case for aborting instruction. This is the last cycle which
        may be aborted or the Status, PBR or DBR registers will be updated.
   (12) Unmodified Data Low is written back to memory in 6502 emulation
        mode (E=1).

    See also: Abbreviations


 6510/65816 Addressing mode: Absolute (JMP) -- a

 (JMP)
 (3 bytes)  (3 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | NEW PCL               |    R     |
    |           3   |  PBR,PC+2        | NEW PCH               |    R     |
    |           1   |  PBR,NEWPC       | New Op Code           |    R     |
    +---------------+------------------+-----------------------+----------+

    See also: Abbreviations


 6510/65816 Addressing mode: Absolute (JSR) -- a

 (JSR)
 (3 bytes)  (6 cycles)

 On 6510:
    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | NEW PCL               |    R     |
    |           3   |  0,S             | Internal Operation    |    R     |
    |           4   |  0,S             | Program Counter High  |    W     |
    |           5   |  0,S-1           | Program Counter Low   |    W     |
    |           6   |  PBR,PC+2        | NEW PCH               |    R     |
    |           1   |  PBR,NEWPC       | New Op Code           |    R     |
    +---------------+------------------+-----------------------+----------+

 On 65816:
    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | NEW PCL               |    R     |
    |           3   |  PBR,PC+2        | NEW PCH               |    R     |
    |           4   |  PBR,PC+2        | Internal Operation    |    R     |
    |           5   |  0,S             | Program Counter High  |    W     |
    |           6   |  0,S-1           | Program Counter Low   |    W     |
    |           1   |  PBR,NEWPC       | New Op Code           |    R     |
    +---------------+------------------+-----------------------+----------+

    See also: Abbreviations


 6510/65816 Addressing mode: Absolute Long -- al

 (ADC,AND,CMP,EOR,LDA,ORA,SBC,STA)
 (4 bytes)  (5 and 6 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Absolute Address Low  |    R     |
    |           3   |  PBR,PC+2        | Absolute Address High |    R     |
    |           4   |  PBR,PC+3        | Absolute Address Bank |    R     |
    |           5   |  AAB,AA          | Data Low              |   R/W    |
    |       (1) 5a  |  AAB,AA+1        | Data High             |   R/W    |
    +---------------+------------------+-----------------------+----------+
    (1) Add 1 cycle for M=0 or X=0 (i.e. 16 bit data).

    See also: Abbreviations


 6510/65816 Addressing mode: Absolute Long (JMP) -- al

 (JMP)
 (4 bytes)  (4 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | NEW PCL               |    R     |
    |           3   |  PBR,PC+2        | NEW PCH               |    R     |
    |           4   |  PBR,PC+3        | NEW PBR               |    R     |
    |           1   |  NEW PBR,PC      | New Op Code           |    R     |
    +---------------+------------------+-----------------------+----------+

    See also: Abbreviations


 6510/65816 Addressing mode: Absolute Long (JSL) -- al

 (JSL)
 (4 bytes)  (7 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | NEW PCL               |    R     |
    |           3   |  PBR,PC+2        | NEW PCH               |    R     |
    |           4   |  0,S             | Program Bank Register |    W     |
    |           5   |  0,S             | Internal Operation    |    R     |
    |           6   |  PBR,PC+3        | NEW PBR               |    R     |
    |           7   |  0,S-1           | Program Counter High  |    W     |
    |           8   |  0,S-2           | Program Counter Low   |    W     |
    |           1   |  NEW PBR,PC      | New Op Code           |    R     |
    +---------------+------------------+-----------------------+----------+

    See also: Abbreviations


 6510/65816 Addressing mode: Zeropage/Direct -- d

 (ADC,AND,BIT,CMP,CPX,CPY,EOR,LAX,LDA,LDX,LDY,NOP,ORA,SAX,SBC,STA,STX,
  STY,STZ)
 (2 bytes)  (3,4 and 5 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Direct Offset         |    R     |
    |       (2) 2a  |  PBR,PC+2        | Internal Operation    |    R     |
    |           3   |  0,D+DO          | Data Low              |   R/W    |
    |       (1) 3a  |  0,D+DO+1        | Data High             |   R/W    |
    +---------------+------------------+-----------------------+----------+
    (1) Add 1 cycle for M=0 or X=0 (i.e. 16 bit data).
    (2) Add 1 cycle for direct register low (DL) not equal 0.

    See also: Abbreviations


 6510/65816 Addressing mode: Zeropage/Direct (R-M-W) -- d

 (ASL,DCP,DEC,INC,ISB,LSR,RLA,ROL,ROR,RRA,SLO,SRE,TRB,TSB)
 (2 bytes)  (5,6,7 and 8 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Direct Offset         |    R     |
    |       (2) 3a  |  PBR,PC+1        | Internal Operation    |    R     |
    |           3   |  0,D+DO          | Data Low              |    R     |
    |       (1) 3a  |  0,D+DO+1        | Data High             |    R     |
    |   (12)(3) 4   |  0,D+DO+1        | Internal Operation    |    R     |
    |       (1) 5a  |  0,D+D0+1        | Data High             |    W     |
    |           5   |  0,D+DO          | Data Low              |    W     |
    +---------------+------------------+-----------------------+----------+
    (1) Add 1 cycle for M=0 or X=0 (i.e. 16 bit data).
    (2) Add 1 cycle for direct register low (DL) not equal 0.
    (3) Special case for aborting instruction. This is the last cycle which
        may be aborted or the Status, PBR or DBR registers will be updated.
   (12) Unmodified Data Low is written back to memory in 6502 emulation
        mode (E=1).

    See also: Abbreviations


 6510/65816 Addressing mode: Accumulator -- A

 (ASL,DEC,INC,LSR,ROL,ROR)
 (1 byte)  (2 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Internal Operation    |    R     |
    +---------------+------------------+-----------------------+----------+

    See also: Abbreviations


 6510/65816 Addressing mode: Implied -- i

 (CLC,CLD,CLI,CLV,DEX,DEY,INX,INY,JAM,NOP,SEC,SED,SEI,TAX,TAY,TCD,TCS,
  TDC,TSC,TSX,TXA,TXS,TXY,TYA,TYX,XCE)
 (1 byte)  (2 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Internal Operation    |    R     |
    +---------------+------------------+-----------------------+----------+

    See also: Abbreviations


 65816 Addressing mode: Implied (XBA) -- i

 (XBA)
 (1 byte)  (3 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Internal Operation    |    R     |
    |           3   |  PBR,PC+1        | Internal Operation    |    R     |
    +---------------+------------------+-----------------------+----------+

    See also: Abbreviations


 65816 Addressing mode: Wait for Interrupt -- h

 (WAI)
 (1 byte)  (3 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |       (9) 2   |  PBR,PC+1        | Internal Operation    |    R     |
    |           3   |  PBR,PC+1        | Internal Operation    |    R     |
    |   IRQ,NMI 1   |  PBR,PC+1        | IRQ(BRK)              |    R     |
    +---------------+------------------+-----------------------+----------+
    (9) Wait at cycle 2 for 2 cycles after /NMI or /IRQ active input.

    See also: Abbreviations


 65816 Addressing mode: Stop the Clock -- h

 (STP)
 (1 byte)  (3 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Internal Operation    |    R     |
    |   RES=1   3   |  PBR,PC+1        | Internal Operation    |    R     |
    |   RES=0   1c  |  PBR,PC+1        | RES(BRK)              |    R     |
    |   RES=0   1b  |  PBR,PC+1        | RES(BRK)              |    R     |
    |   RES=1   1a  |  PBR,PC+1        | RES(BRK)              |    R     |
    |           1   |  PBR,PC+1        | BEGIN                 |    R     |
    +---------------+------------------+-----------------------+----------+

    See also: Abbreviations
              Hardware interrupt


 6510/65816 Addressing mode: Zeropage/Direct Indirect Indexed -- (d),y

 (ADC,AND,CMP,EOR,LAX,LDA,ORA,SBC,STA)
 (2 bytes)  (5,6,7 and 8 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Direct Offset         |    R     |
    |       (2) 2a  |  PBR,PC+1        | Internal Operation    |    R     |
    |           3   |  0,D+DO          | Absolute Address Low  |    R     |
    |           4   |  0,D+DO+1        | Absolute Address High |    R     |
    |       (4) 4a  |  DBR,AAH,AAL+YL  | Internal Operation    |    R     |
    |           5   |  DBR,AA+Y        | Data Low              |   R/W    |
    |       (1) 5a  |  DBR,AA+Y+1      | Data High             |   R/W    |
    +---------------+------------------+-----------------------+----------+
    (1) Add 1 cycle for M=0 or X=0 (i.e. 16 bit data).
    (2) Add 1 cycle for direct register low (DL) not equal 0.
    (4) Add 1 cycle for indexing across page boundaries, or write, or X=0.
        When X=1 or in the emulation mode, this cycle contains invalid
        addresses.

    See also: Abbreviations


 6510 Illegal Addressing mode: Direct Indexed Indirect (R-M-W) -- (d),y

 (DCP,ISB,RLA,RRA,SLO,SRE)
 (2 bytes)  (7,8 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Direct Offset         |    R     |
    |           3   |  0,D+DO          | Absolute Address Low  |    R     |
    |           4   |  0,D+DO+1        | Absolute Address High |    R     |
    |       (4) 4a  |  DBR,AAH,AAL+YL  | Internal Operation    |    R     |
    |           5   |  DBR,AA+Y        | Data Low              |    R     |
    |           6   |  DBR,AA          | Old Data Low          |    W     |
    |           7   |  DBR,AA          | New Data Low          |    W     |
    +---------------+------------------+-----------------------+----------+
    (4) Add 1 cycle for indexing across page boundaries or write.

    See also: Abbreviations


 6510/65816 Addressing mode: Zeropage/Direct Indirect Indexed Long -- [d],y

 (ADC,AND,CMP,EOR,LDA,ORA,SBC,STA)
 (2 bytes)  (6,7 and 8 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Direct Offset         |    R     |
    |       (2) 2a  |  PBR,PC+1        | Internal Operation    |    R     |
    |           3   |  0,D+DO          | Absolute Address Low  |    R     |
    |           4   |  0,D+DO+1        | Absolute Address High |    R     |
    |           5   |  0,D+DO+2        | Absolute Address Bank |    R     |
    |           6   |  AAB,AA+Y        | Data Low              |   R/W    |
    |       (1) 6a  |  AAB,AA+Y+1      | Data High             |   R/W    |
    +---------------+------------------+-----------------------+----------+
    (1) Add 1 cycle for M=0 or X=0 (i.e. 16 bit data).
    (2) Add 1 cycle for direct register low (DL) not equal 0.

    See also: Abbreviations


 6510/65816 Addressing mode: Zeropage/Direct Indexed Indirect -- (d,x)

 (ADC,AND,CMP,EOR,LAX,LDA,ORA,SAX,SBC,STA)
 (2 bytes)  (6,7 and 8 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Direct Offset         |    R     |
    |       (2) 2a  |  PBR,PC+1        | Internal Operation    |    R     |
    |           3   |  PBR,PC+1        | Internal Operation    |    R     |
    |           4   |  0,D+DO+X        | Absolute Address Low  |    R     |
    |           5   |  0,D+DO+X+1      | Absolute Address High |    R     |
    |           6   |  DBR,AA          | Data Low              |   R/W    |
    |       (1) 6a  |  DBR,AA+1        | Data High             |   R/W    |
    +---------------+------------------+-----------------------+----------+
    (1) Add 1 cycle for M=0 or X=0 (i.e. 16 bit data).
    (2) Add 1 cycle for direct register low (DL) not equal 0.

    See also: Abbreviations


 6510 Illegal Addressing mode: Direct Indexed Indirect (R-M-W) -- (d,x)

 (DCP,ISB,RLA,RRA,SLO,SRE)
 (2 bytes)  (8 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Direct Offset         |    R     |
    |           3   |  PBR,PC+1        | Internal Operation    |    R     |
    |           4   |  0,D+DO+X        | Absolute Address Low  |    R     |
    |           5   |  0,D+DO+X+1      | Absolute Address High |    R     |
    |           6   |  DBR,AA          | Data Low              |    R     |
    |           7   |  DBR,AA          | Old Data Low          |    W     |
    |           8   |  DBR,AA          | New Data Low          |    W     |
    +---------------+------------------+-----------------------+----------+

    See also: Abbreviations


 6510/65816 Addressing mode: Zeropage/Direct Indexed -- d,x  d,y

 (ADC,AND,BIT,CMP,EOR,LAX,LDA,LDX,LDY,NOP,ORA,SAX,SBC,STA,STX,STY,STZ)

 (2 bytes)  (4,5 and 6 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Direct Offset         |    R     |
    |       (2) 2a  |  PBR,PC+1        | Internal Operation    |    R     |
    |           3   |  PBR,PC+1        | Internal Operation    |    R     |
    |           4   |  0,D+DO+I        | Data Low              |   R/W    |
    |       (1) 4a  |  0,D+DO+I+1      | Data High             |   R/W    |
    +---------------+------------------+-----------------------+----------+
    (1) Add 1 cycle for M=0 or X=0 (i.e. 16 bit data).
    (2) Add 1 cycle for direct register low (DL) not equal 0.

    See also: Abbreviations


 6510/65816 Addressing mode: Zeropage/Direct Indexed (R-M-W) -- d,x

 (ASL,DCP,DEC,INC,ISB,LSR,RLA,ROL,ROR,RRA,SLO,SRE)
 (2 bytes)  (6,7,8 and 9 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Direct Offset         |    R     |
    |       (2) 2a  |  PBR,PC+1        | Internal Operation    |    R     |
    |           3   |  PBR,PC+1        | Internal Operation    |    R     |
    |           4   |  0,D+DO+X        | Data Low              |    R     |
    |       (1) 4a  |  0,D+DO+X+1      | Data High             |    R     |
    |   (12)(3) 5   |  0,D+DO+X+1      | Internal Operation    |    R     |
    |       (1) 6a  |  0,D+DO+X+1      | Data High             |    W     |
    |           6   |  0,D+DO+X        | Data Low              |    W     |
    +---------------+------------------+-----------------------+----------+
    (1) Add 1 cycle for M=0 or X=0 (i.e. 16 bit data).
    (2) Add 1 cycle for direct register low (DL) not equal 0.
    (3) Special case for aborting instruction. This is the last cycle which
        may be aborted or the Status, PBR or DBR registers will be updated.
   (12) Unmodified Data Low is written back to memory in 6502 emulation
        mode (E=1).

    See also: Abbreviations


 6510/65816 Addressing mode: Absolute Indexed -- a,x  a,y

 (ADC,AND,BIT,CMP,EOR,LAE,LAX,LDA,LDX,LDY,NOP,ORA,SBC,SHA,SHS,SHX,SHY,
  STA,STZ)
 (3 bytes)  (4,5 and 6 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op code               |    R     |
    |           2   |  PBR,PC+1        | Absolute Address Low  |    R     |
    |           3   |  PBR,PC+2        | Absolute Address High |    R     |
    |       (4) 3a  |  DBR,AAH,AAL+IL  | Internal Operation    |    R     |
    |           4   |  DBR,AA+I        | Data Low              |   R/W    |
    |       (1) 4a  |  DBR,AA+I+1      | Data High             |   R/W    |
    +---------------+------------------+-----------------------+----------+
    (1) Add 1 cycle for M=0 or X=0 (i.e. 16 bit data).
    (4) Add 1 cycle for indexing across page boundaries, or write, or X=0.
        When X=1 or in the emulation mode, this cycle contains invalid
        addresses.

    See also: Abbreviations


 6510/65816 Addressing mode: Absolute Indexed (R-M-W) -- a,x
 6510 Illegal Addressing mode: Absolute Indexed (R-M-W) -- a,y

 (ASL,DCP,DEC,INC,ISB,LSR,RLA,ROL,ROR,RRA,SLO,SRE)
 (3 bytes)  (7 and 9 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Absolute Address Low  |    R     |
    |           3   |  PBR,PC+2        | Absolute Address High |    R     |
    |           4   |  DBR,AAH,AAL+XL  | Internal Operation    |    R     |
    |           5   |  DBR,AA+X        | Data Low              |    R     |
    |       (1) 5a  |  DBR,AA+X+1      | Data High             |    R     |
    |   (12)(3) 6   |  DBR,AA+X+1      | Internal Operation    |    R     |
    |       (1) 7a  |  DBR,AA+X+1      | Data High             |    W     |
    |           7   |  DBR,AA+X        | Data Low              |    W     |
    +---------------+------------------+-----------------------+----------+
    (1) Add 1 cycle for M=0 or X=0 (i.e. 16 bit data).
    (3) Special case for aborting instruction. This is the last cycle which
        may be aborted or the Status, PBR or DBR registers will be updated.
   (12) Unmodified Data Low is written back to memory in 6502 emulation
        mode (E=1).

    See also: Abbreviations


 65816 Addressing mode: Absolute Long Indexed -- al,x

 (ADC,AND,CMP,EOR,LDA,ORA,SBC,STA)
 (4 bytes)  (5 and 6 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Absolute Address Low  |    R     |
    |           3   |  PBR,PC+2        | Absolute Address High |    R     |
    |           4   |  PBR,PC+3        | Absolute Address Bank |    R     |
    |           5   |  AAB,AA+X        | Data Low              |   R/W    |
    |       (1) 5a  |  AAB,AA+X+1      | Data High             |   R/W    |
    +---------------+------------------+-----------------------+----------+
    (1) Add 1 cycle for M=0 or X=0 (i.e. 16 bit data).

    See also: Abbreviations


 6510/65816 Addressing mode: Relative -- r

 (BCC,BCS,BEQ,BMI,BNE,BPL,BRA,BVC,BVS)
 (2 bytes)  (2,3 and 4 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Offset                |    R     |
    |       (5) 2a  |  PBR,PC+2        | Internal Operation    |    R     |
    |       (6) 2b  |  PBR,PC+2+OFF    | Internal Operation    |    R     |
    |           1   |  PBR,NewPC       | New Op Code           |    R     |
    +---------------+------------------+-----------------------+----------+
    (5) Add 1 cycle if branch is taken.
    (6) Add 1 cycle if branch is taken across page boundaries in 6502
        emulation mode (E=1).

    See also: Abbreviations


 65816 Addressing mode: Relative Long -- rl

 (BRL)
 (3 bytes)  (4 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Offset Low            |    R     |
    |           3   |  PBR,PC+2        | Offset High           |    R     |
    |           4   |  PBR,PC+2        | Internal Operation    |    R     |
    |           1   |  PBR,NewPC       | New Op Code           |    R     |
    +---------------+------------------+-----------------------+----------+

    See also: Abbreviations


 6510/65816 Addressing mode: Absolute Indirect -- (a)

 (JMP)
 (3 bytes)  (5 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Absolute Address Low  |    R     |
    |           3   |  PBR,PC+2        | Absolute Address High |    R     |
    |           4   |  0,AA            | NEW PCL               |    R     |
    |           5   |  0,AA+1          | NEW PCH               |    R     |
    |           1   |  PBR,NewPC       | New Op Code           |    R     |
    +---------------+------------------+-----------------------+----------+

    See also: Abbreviations


 65816 Addressing mode: Absolute Indirect Long (JML) -- (a)

 (JML)
 (3 bytes)  (6 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Absolute Address Low  |    R     |
    |           3   |  PBR,PC+1        | Absolute Address High |    R     |
    |           4   |  0,AA            | NEW PCL               |    R     |
    |           5   |  0,AA+1          | NEW PCH               |    R     |
    |           6   |  0,AA+2          | NEW PBR               |    R     |
    |           1   |  NEW PBR,PC      | New Op Code           |    R     |
    +---------------+------------------+-----------------------+----------+

    See also: Abbreviations


 65816 Addressing mode: Direct Indirect -- (d)

 (ADC,AND,CMP,EOR,LDA,ORA,SBC,STA)
 (2 bytes)  (5,6 and 7 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Direct Offset         |    R     |
    |       (2) 2a  |  PBR,PC+1        | Internal Operation    |    R     |
    |           3   |  0,D+DO          | Absolute Address Low  |    R     |
    |           1   |  0,D+DO+1        | Absolute Address High |    R     |
    |           5   |  DBR,AA          | Data Low              |   R/W    |
    |       (1) 5a  |  DBR,AA+1        | Data Low              |   R/W    |
    +---------------+------------------+-----------------------+----------+
    (1) Add 1 cycle for M=0 or X=0 (i.e. 16 bit data).
    (2) Add 1 cycle for direct register low (DL) not equal 0.

    See also: Abbreviations


 65816 Addressing mode: Direct Indirect Long -- [d]

 (ADC,AND,CMP,EOR,LDA,ORA,SBC,STA)
 (2 bytes)  (6,7 and 8 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Direct Offset         |    R     |
    |       (2) 2a  |  PBR,PC+1        | Internal Operation    |    R     |
    |           3   |  0,D+DO          | Absolute Address Low  |    R     |
    |           4   |  0,D+DO+1        | Absolute Address High |    R     |
    |           5   |  0,D+DO+2        | Absolute Address Bank |    R     |
    |           6   |  AAB,AA          | Data Low              |   R/W    |
    |       (1) 6a  |  AAB,AA+1        | Data High             |   R/W    |
    +---------------+------------------+-----------------------+----------+
    (1) Add 1 cycle for M=0 or X=0 (i.e. 16 bit data).
    (2) Add 1 cycle for direct register low (DL) not equal 0.

    See also: Abbreviations


 6510/65816 Addressing mode: Absolute Indexed Indirect -- (a,x)

 (JMP)
 (3 bytes)  (6 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Absolute Address Low  |    R     |
    |           3   |  PBR,PC+2        | Absolute Address High |    R     |
    |           4   |  PBR,PC+2        | Internal Operation    |    R     |
    |           5   |  PBR,AA+X        | NEW PCL               |    R     |
    |           6   |  PBR,AA+X+1      | NEW PCH               |    R     |
    |           1   |  PBR,NEWPC       | New Op Code           |    R     |
    +---------------+------------------+-----------------------+----------+

    See also: Abbreviations


 65816 Addressing mode: Absolute Indexed Indirect (JSR) -- (a,x)

 (JSR)
 (3 bytes)  (8 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Absolute Address Low  |    R     |
    |           3   |  0,S             | Program Counter High  |    W     |
    |           4   |  0,S-1           | Program Counter Low   |    W     |
    |           5   |  PBR,PC+2        | Absolute Address High |    R     |
    |           6   |  PBR,PC+2        | Internal Operation    |    R     |
    |           7   |  PBR,AA+X        | NEW PCL               |    R     |
    |           8   |  PBR,AA+X+1      | NEW PCH               |    R     |
    |           1   |  PBR,NEWPC       | New Op Code           |    R     |
    +---------------+------------------+-----------------------+----------+

    See also: Abbreviations


 6510/65816 Addressing mode: Stack (Hardware Interrupts) -- s

 (IRQ,NMI,ABORT,RES)
 (0 bytes)  (7 and 8 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Internal Operation    |    R     |
    |       (3) 2   |  PBR,PC          | Internal Operation    |    R     |
    |       (7) 3   |  0,S             | Program Bank Register |    W     |
    |      (10) 4   |  0,S-1           | Program Counter High  |    W     |
    |      (10) 5   |  0,S-2           | Program Counter Low   |    W     |
    |  (10)(11) 6   |  0,S-3           | Status Register       |    W     |
    |           7   |  0,VA            | Abs.Addr. Vector Low  |    R     |
    |           8   |  0,VA+1          | Abs.Addr. Vector High |    R     |
    |           1   |  0,AAV           | New Op Code           |    R     |
    +---------------+------------------+-----------------------+----------+
    (3) Special case for aborting instruction. This is the last cycle which
        may be aborted or the Status, PBR or DBR registers will be updated.
    (7) Subtract 1 cycle for 6502 emulation mode (E=1).
   (10) R/W remains high during Reset.
   (11) BRK bit 4 equals "0" in Emulation mode.

    See also: Abbreviations


 6510/65816 Addressing mode: Stack (Software Interrupts) -- s

 (BRK,COP)
 (2 bytes)  (7 and 8 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |       (3) 2   |  PBR,PC+1        | Signature             |    R     |
    |       (7) 3   |  0,S             | Program Bank Register |    W     |
    |           4   |  0,S-1           | Program Counter High  |    W     |
    |           5   |  0,S-2           | Program Counter Low   |    W     |
    |           6   |  0,S-3           | (COP Latches)P        |    W     |
    |           7   |  0,VA            | Abs.Addr. Vector Low  |    R     |
    |           8   |  0,VA+1          | Abs.Addr. Vector High |    R     |
    |           1   |  0,AAV           | New Op Code           |    R     |
    +---------------+------------------+-----------------------+----------+
    (3) Special case for aborting instruction. This is the last cycle which
        may be aborted or the Status, PBR or DBR registers will be updated.
    (7) Subtract 1 cycle for 6502 emulation mode (E=1).

    See also: Abbreviations


 6510/65816 Addressing mode: Stack (RTI) -- s

 (RTI)
 (1 byte)  (6 and 7 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Internal Operation    |    R     |
    |       (3) 3   |  PBR,PC+1        | Internal Operation    |    R     |
    |           4   |  0,S+1           | Status Register       |    R     |
    |           5   |  0,S+2           | New PCL               |    R     |
    |           6   |  0,S+3           | New PCH               |    R     |
    |       (7) 7   |  0,S+4           | Program Bank Register |    R     |
    |           1   |  PBR,NewPC       | New Op Code           |    R     |
    +---------------+------------------+-----------------------+----------+
    (3) Special case for aborting instruction. This is the last cycle which
        may be aborted or the Status, PBR or DBR registers will be updated.
    (7) Subtract 1 cycle for 6502 emulation mode (E=1).

    See also: Abbreviations


 6510/65816 Addressing mode: Stack (RTS) -- s

 (RTS)
 (1 byte)  (6 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Internal Operation    |    R     |
    |           3   |  PBR,PC+1        | Internal Operation    |    R     |
    |           4   |  0,S+1           | New PCL-1             |    R     |
    |           5   |  0,S+2           | New PCH               |    R     |
    |           6   |  0,S+2           | Internal Operation    |    R     |
    |           1   |  PBR,NewPC       | New Op Code           |    R     |
    +---------------+------------------+-----------------------+----------+

    See also: Abbreviations


 65816 Addressing mode: Stack (RTL) -- s

 (RTL)
 (1 byte)  (6 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Internal Operation    |    R     |
    |           3   |  PBR,PC+1        | Internal Operation    |    R     |
    |           4   |  0,S+1           | NEW PCL               |    R     |
    |           5   |  0,S+2           | NEW PCH               |    R     |
    |           6   |  0,S+3           | NEW PBR               |    R     |
    |           1   |  NEWPBR,PC       | New Op Code           |    R     |
    +---------------+------------------+-----------------------+----------+

    See also: Abbreviations


 6510/65816 Addressing mode: Stack (Push) -- s

 (PHA,PHB,PHD,PHK,PHP,PHX,PHY)
 (1 byte)  (3 and 4 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Internal Operation    |    R     |
    |       (1) 3a  |  0,S             | Register High         |    W     |
    |           3   |  0,S-1           | Register Low          |    W     |
    +---------------+------------------+-----------------------+----------+
    (1) Add 1 cycle for M=0 or X=0 (i.e. 16 bit data).

    See also: Abbreviations


 6510/65816 Addressing mode: Stack (Pull) -- s

 (PLA,PLB,PLD,PLP,PLX,PLY)
 (1 byte)  (4 and 5 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Internal Operation    |    R     |
    |           3   |  PBR,PC+1        | Internal Operation    |    R     |
    |           4   |  0,S+1           | Register Low          |    R     |
    |       (1) 4a  |  0,S+2           | Register High         |    R     |
    +---------------+------------------+-----------------------+----------+
    (1) Add 1 cycle for M=0 or X=0 (i.e. 16 bit data).

    See also: Abbreviations


 65816 Addressing mode: Stack (PEI) -- s

 (PEI)
 (2 bytes)  (6 and 7 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Direct Offset         |    R     |
    |       (2) 2a  |  PBR,PC+1        | Internal Operation    |    R     |
    |           3   |  0,D+DO          | Absolute Address Low  |    R     |
    |           4   |  0,D+DO+1        | Absolute Address High |    R     |
    |           5   |  0,S             | Absolute Address High |    W     |
    |           6   |  0,S-1           | Absolute Address Low  |    W     |
    +---------------+------------------+-----------------------+----------+
    (2) Add 1 cycle for direct register low (DL) not equal 0.

    See also: Abbreviations


 65816 Addressing mode: Stack (PEA) -- s

 (PEA)
 (3 bytes)  (5 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Absolute Address Low  |    R     |
    |           3   |  PBR,PC+2        | Absolute Address High |    R     |
    |           4   |  0,S             | Absolute Address High |    W     |
    |           5   |  0,S-1           | Absolute Address Low  |    W     |
    +---------------+------------------+-----------------------+----------+

    See also: Abbreviations


 65816 Addressing mode: Stack (PER) -- s

 (PER)
 (3 bytes)  (6 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Offset Low            |    R     |
    |           3   |  PBR,PC+2        | Offset High           |    R     |
    |           4   |  PBR,PC+2        | Internal Operation    |    R     |
    |           5   |  0,S             | PCH+Offset+CAR        |    W     |
    |           6   |  0,S-1           | PCL + Offset          |    W     |
    +---------------+------------------+-----------------------+----------+

    See also: Abbreviations


 65816 Addressing mode: Stack Relative -- d,s

 (ADC,AND,CMP,EOR,LDA,ORA,SBC,STA)
 (2 bytes)  (4 and 5 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Stack Offset          |    R     |
    |           3   |  PBR,PC+1        | Internal Operation    |    R     |
    |           4   |  0,S+SO          | Data Low              |   R/W    |
    |       (1) 4a  |  0,S+SO+1        | Data High             |   R/W    |
    +---------------+------------------+-----------------------+----------+
    (1) Add 1 cycle for M=0 or X=0 (i.e. 16 bit data).

    See also: Abbreviations


 65816 Addressing mode: Stack Relative Indirect Indexed -- (d,s),y

 (ADC,AND,CMP,EOR,LDA,ORA,SBC,STA)
 (2 bytes)  (7 and 8 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |           1   |  PBR,PC          | Op Code               |    R     |
    |           2   |  PBR,PC+1        | Stack Offset          |    R     |
    |           3   |  PBR,PC+1        | Internal Operation    |    R     |
    |           4   |  0,S+SO          | Absolute Address Low  |    R     |
    |           5   |  0,S+SO+1        | Absolute Address High |    R     |
    |           6   |  0,S+SO+1        | Internal Operation    |    R     |
    |           7   |  DBR,AA+Y        | Data Low              |   R/W    |
    |       (1) 7a  |  DBR,AA+Y+1      | Data High             |   R/W    |
    +---------------+------------------+-----------------------+----------+
    (1) Add 1 cycle for M=0 or X=0 (i.e. 16 bit data).

    See also: Abbreviations


 65816 Addressing mode: Block Move Positive (forward) -- xyc

 (MVP)
 (3 bytes)  (7 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |        +- 1   |  PBR,PC          | Op Code               |    R     |
    |        |  2   |  PBR,PC+1        | Dest. Bank Address    |    R     |
    |        |  3   |  PBR,PC+2        | Source Bank Address   |    R     |
    |   N-2  |  4   |  SBA,X           | Source Data           |    R     |
    |   Byte |  5   |  DBA,Y           | Dest Data             |    W     |
    |   C=2  |  6   |  DBA,Y           | Internal Operation    |    R     |
    |        +- 7   |  DBA,Y           | Internal Operation    |    R     |
    |        +- 1   |  PBR,PC          | Op Code               |    R     |
    |        |  2   |  PBR,PC+1        | Dest. Bank Address    |    R     |
    |   N-1  |  3   |  PBR,PC+2        | Source Bank Address   |    R     |
    |   Byte |  4   |  SBA,X-1         | Source Data           |    R     |
    |   C=1  |  5   |  DBA,Y-1         | Dest Data             |    W     |
    |        |  6   |  DBA,Y-1         | Internal Operation    |    R     |
    |        +- 7   |  DBA,Y-1         | Internal Operation    |    R     |
    |        +- 1   |  PBR,PC          | Op Code               |    R     |
    |        |  2   |  PBR,PC+1        | Dest. Bank Address    |    R     |
    | N Byte |  3   |  PBR,PC+2        | Source Bank Address   |    R     |
    |   Last |  4   |  SBA,X-2         | Source Data           |    R     |
    |   C=0  |  5   |  DBA,Y-2         | Dest Data             |    W     |
    |        |  6   |  DBA,Y-2         | Internal Operation    |    R     |
    |        |  7   |  DBA,Y-2         | Internal Operation    |    R     |
    |        +- 1   |  PBR,PC+3        | New Op Code           |    R     |
    +---------------+------------------+-----------------------+----------+

    See also: Abbreviations

   x = Source Address
   y = Destination
   c = Number of Bytes to move -1
   x,y Decrement
   MVP is used when the destination start address is higher (more positive)
   than the source start address.

   FFFFFF
     ^  Dest Start
     |  Source Start
     |  Dest End
     |  Source End
   000000


 65816 Addressing mode: Block Move Negative (backward) -- xyc

 (MVN)
 (3 bytes)  (7 cycles)

    +---------------+------------------+-----------------------+----------+
    |     Cycle     |   Address Bus    |       Data Bus        |Read/Write|
    +---------------+------------------+-----------------------+----------+
    |        +- 1   |  PBR,PC          | Op Code               |    R     |
    |        |  2   |  PBR,PC+1        | Dest. Bank Address    |    R     |
    |        |  3   |  PBR,PC+2        | Source Bank Address   |    R     |
    |   N-2  |  4   |  SBA,X           | Source Data           |    R     |
    |   Byte |  5   |  DBA,Y           | Dest Data             |    W     |
    |   C=2  |  6   |  DBA,Y           | Internal Operation    |    R     |
    |        +- 7   |  DBA,Y           | Internal Operation    |    R     |
    |        +- 1   |  PBR,PC          | Op Code               |    R     |
    |        |  2   |  PBR,PC+1        | Dest. Bank Address    |    R     |
    |   N-1  |  3   |  PBR,PC+2        | Source Bank Address   |    R     |
    |   Byte |  4   |  SBA,X+1         | Source Data           |    R     |
    |   C=1  |  5   |  DBA,Y+1         | Dest Data             |    W     |
    |        |  6   |  DBA,Y+1         | Internal Operation    |    R     |
    |        +- 7   |  DBA,Y+1         | Internal Operation    |    R     |
    |        +- 1   |  PBR,PC          | Op Code               |    R     |
    |        |  2   |  PBR,PC+1        | Dest. Bank Address    |    R     |
    | N Byte |  3   |  PBR,PC+2        | Source Bank Address   |    R     |
    |   Last |  4   |  SBA,X+2         | Source Data           |    R     |
    |   C=0  |  5   |  DBA,Y+2         | Dest Data             |    W     |
    |        |  6   |  DBA,Y+2         | Internal Operation    |    R     |
    |        |  7   |  DBA,Y+2         | Internal Operation    |    R     |
    |        +- 1   |  PBR,PC+3        | New Op Code           |    R     |
    +---------------+------------------+-----------------------+----------+

    See also: Abbreviations

   x = Source Address
   y = Destination
   c = Number of Bytes to move -1
   x,y Increment
   MVN is used when the destination start address is lower (more negative)
   than the source start address.

   FFFFFF
     |  Source End
     |  Dest End
     |  Source Start
     v  Dest Start
   000000


 Address-Mode Abbreviations:

    AAB     Absolute Address Bank           IDL     Immediate Data Low
    AAH     Absolute Address High           IO      Internal Operation
    AAL     Absolute Address Low            P       Status Register
    AAVH    Abs.Addr. Vector High           PBR     Program Bank Register
    AAVL    Abs.Addr. Vector Low            PC      Program Counter
    C       Accumulator                     PCH     Program Counter High
    CAR     Carry                           PCL     Program Counter Low
    D       Direct Register                 R-M-W   Read-Modify-Write
    DBA     Dest. Bank Address              S       Stack Address
    DBR     Data Bank Register              SBA     Source Bank Address
    DO      Direct Offset                   SO      Stack Offset
    I       Index Registers                 VA      Vector Address
    IDH     Immediate Data High             X,Y     X,Y Registers


  Branch penalty cycles
 +---------------------+

 As you can see from the relative addressing mode, the relative offset is
 added to the PC after it has been fetched, of course. That means, that the
 penalty cycle for branching to a different page is given, if the branch
 is taken and the high byte of the PC after the branch instruction is
 different from the high byte of the destination address.

 The syntax of assemblers may lead to confusion here. For example, "BCS *+2"
 looks like an offset has to be added, but it will be coded as "B0 00", so
 this instruction will never branch to a different page.

 The 65816 applies this penalty cycle only in Emulation mode.


  Bugs and flaws of the 6510
 +--------------------------+

 Zeropage addressing modes & page wraps (fixed on 65816 in native mode):

   If you use an indexed-zeropage addressing mode, either direct or indirect,
   it is not able to leave the zeropage on page-wraps. Examples:

    LDX #$01
    LDA $FF,X

   will fetch from adress $0000 and not $0100.

    LDA ($FF),Y

    LDX #$00
    LDA ($FF,X)

    LDX #$FF
    LDA ($00,X)

   will all fetch the low-byte from $00FF and the high-byte from $0000.

 Indirect addressing mode & page wraps (fixed on 65816):

   If you use the indirect addressing mode, PCH will not be incremented on
   page wraps. Example:

    JMP ($C0FF)

   will fetch the low-byte from $C0FF and the high-byte from $C000.

 Decimal mode (flags fixed on 65816):

   In decimal mode, N and V are set after the high-order nibble is added or
   subtracted but before it is decimal-corrected, according to binary rules.
   Z is always set according to binary mode, not decimal.

   When decimal-correcting a nibble for addition, following rules apply:

    IF ((nibble >= $A) \/ C') THEN nibble += 6
    C'' = C' \/ (nibble + 6 >= $A)

   When decimal-correcting a nibble for subtraction,  following rules apply:

    IF (~C') THEN nibble -= 6
    C'' = C' \/ (nibble - 6 < 0)

   Thus, $F + $F in decimal mode is $14, not $24. Also, decimal correction
   can result in nibbles ranging from $A-$F. For example, $C + $D results
   in $19 before correction, $1F after.


  +------------------------------------------------------------------------
  |
  |      VIDEO INTERFACE CHIP (VIC) 6566/6567
  |
  +------------------------------------------------------------------------
  |
  |  VIC related topics:
  |
  |   Bit Interpretations
  |   CBMSCII Charset
  |   Colors
  |   PAL/NTSC Differences
  |   PAL-Timing-Schemes
  |   Screen Dimensions
  |
  |  Register description:
  |
  |   $D000/53248/VIC+0        Sprite 0 X Pos
  |   $D001/53249/VIC+1        Sprite 0 Y Pos
  |   $D002/53250/VIC+2        Sprite 1 X Pos
  |   $D003/53251/VIC+3        Sprite 1 Y Pos
  |   $D004/53252/VIC+4        Sprite 2 X Pos
  |   $D005/53253/VIC+5        Sprite 2 Y Pos
  |   $D006/53254/VIC+6        Sprite 3 X Pos
  |   $D007/53255/VIC+7        Sprite 3 Y Pos
  |   $D008/53256/VIC+8        Sprite 4 X Pos
  |   $D009/53257/VIC+9        Sprite 4 Y Pos
  |   $D00A/53258/VIC+10       Sprite 5 X Pos
  |   $D00B/53259/VIC+11       Sprite 5 Y Pos
  |   $D00C/53260/VIC+12       Sprite 6 X Pos
  |   $D00D/53261/VIC+13       Sprite 6 Y Pos
  |   $D00E/53262/VIC+14       Sprite 7 X Pos
  |   $D00F/53263/VIC+15       Sprite 7 Y Pos
  |   $D010/53264/VIC+16       Sprites 0-7 MSB of X coordinate
  |   $D011/53265/VIC+17       Control Register 1
  |   $D012/53266/VIC+18       Raster Position
  |   $D013/53267/VIC+19       Latch X Pos
  |   $D014/53268/VIC+20       Latch Y Pos
  |   $D015/53269/VIC+21       Sprite display Enable
  |   $D016/53270/VIC+22       Control Register 2
  |   $D017/53271/VIC+23       Sprites Expand 2x Vertical (Y)
  |   $D018/53272/VIC+24       Memory Control Register
  |   $D019/53273/VIC+25       Interrupt Request Register (IRR)
  |   $D01A/53274/VIC+26       Interrupt Mask Register (IMR)
  |   $D01B/53275/VIC+27       Sprite to Background Display Priority
  |   $D01C/53276/VIC+28       Sprites Multi-Color Mode Select
  |   $D01D/53277/VIC+29       Sprites Expand 2x Horizontal (X)
  |   $D01E/53278/VIC+30       Sprite to Sprite Collision Detect
  |   $D01F/53279/VIC+31       Sprite to Background Collision Detect
  |   $D020/53280/VIC+32       Border Color
  |   $D021/53281/VIC+33       Background Color 0
  |   $D022/53282/VIC+34       Background Color 1, Multi-Color Register 0
  |   $D023/53283/VIC+35       Background Color 2, Multi-Color Register 1
  |   $D024/53284/VIC+36       Background Color 3
  |   $D025/53285/VIC+37       Sprite Multi-Color Register 0
  |   $D026/53286/VIC+38       Sprite Multi-Color Register 1
  |   $D027/53287/VIC+39       Sprite 0 Color
  |   $D028/53288/VIC+40       Sprite 1 Color
  |   $D029/53289/VIC+41       Sprite 2 Color
  |   $D02A/53290/VIC+42       Sprite 3 Color
  |   $D02B/53291/VIC+43       Sprite 4 Color
  |   $D02C/53292/VIC+44       Sprite 5 Color
  |   $D02D/53293/VIC+45       Sprite 6 Color
  |   $D02E/53294/VIC+46       Sprite 7 Color
  |
  | C128 only:
  |
  |   $D02F/53295/VIC+47       Port A* for Extended Keyboard
  |   $D030/53296/VIC+48       Switch to FAST-Mode
  |
  +------------------------------------------------------------------------



 $D000/53248/VIC+0:   Sprite 0 X Pos

   MSB is at $D010


 $D001/53249/VIC+1:   Sprite 0 Y Pos


 $D002/53250/VIC+2:   Sprite 1 X Pos

   MSB is at $D010


 $D003/53251/VIC+3:   Sprite 1 Y Pos


 $D004/53252/VIC+4:   Sprite 2 X Pos

   MSB is at $D010


 $D005/53253/VIC+5:   Sprite 2 Y Pos


 $D006/53254/VIC+6:   Sprite 3 X Pos

   MSB is at $D010


 $D007/53255/VIC+7:   Sprite 3 Y Pos


 $D008/53256/VIC+8:   Sprite 4 X Pos

   MSB is at $D010


 $D009/53257/VIC+9:   Sprite 4 Y Pos


 $D00A/53258/VIC+10:  Sprite 5 X Pos

   MSB is at $D010


 $D00B/53259/VIC+11:  Sprite 5 Y Pos


 $D00C/53260/VIC+12:  Sprite 6 X Pos

   MSB is at $D010


 $D00D/53261/VIC+13:  Sprite 6 Y Pos


 $D00E/53262/VIC+14:  Sprite 7 X Pos

   MSB is at $D010


 $D00F/53263/VIC+15:  Sprite 7 Y Pos


 $D010/53264/VIC+16:  Sprites 0-7 MSB of X coordinate

   +----------+---------------------------------------------------+
   | Bit  x   |   Sprite x: Bit 8 of X-Position                   |
   +----------+---------------------------------------------------+


 $D011/53265/VIC+17:  Control Register 1

   +----------+---------------------------------------------------+
   | Bit  7   |    Raster Position Bit 8 from $D012               |
   | Bit  6   |    Extended Color Text Mode: 1 = Enable           |
   | Bit  5   |    Bitmap Mode: 1 = Enable                        |
   | Bit  4   |    Blank Screen to Border Color: 0 = Blank        |
   | Bit  3   |    Select 24/25 Row Text Display: 1 = 25 Rows     |
   | Bits 2-0 |    Smooth Scroll to Y Dot-Position (0-7)          |
   +----------+---------------------------------------------------+

   Default Value: $9B/155 (%10011011).

Kernal-Reference:

 LDA $D011   : $F88D $FC95
 STA $D011   : $F892 $FC9A


 $D012/53266/VIC+18:  Raster Position

   Read : Get current Raster Position
   Write: Set Raster Position for IRQ

   Bit 8 is at $D011

Kernal-Reference:

 LDA $D012   : $FF5E


 $D013/53267/VIC+19:  Latch X Pos


 $D014/53268/VIC+20:  Latch Y Pos


 $D015/53269/VIC+21:  Sprite display Enable

   +----------+---------------------------------------------------+
   | Bit  x   |   Sprite x: 1 = Sprite enabled                    |
   +----------+---------------------------------------------------+


 $D016/53270/VIC+22:  Control Register 2

   +----------+---------------------------------------------------+
   | Bits 7-6 |    Unused                                         |
   | Bit  5   |    Reset-Bit: 1 = Stop VIC (no Video Out, no RAM  |
   |          |                   refresh, no bus access)         |
   | Bit  4   |    Multi-Color Mode: 1 = Enable (Text or Bitmap)  |
   | Bit  3   |    Select 38/40 Column Text Display: 1 = 40 Cols  |
   | Bits 2-0 |    Smooth Scroll to X Dot-Position (0-7)          |
   +----------+---------------------------------------------------+

   Default Value: $08/8 (%00001000).

   See also: Bit Interpretations in Hires and MC-Mode

Kernal-Reference:

 STX $D016   : $FCEF


 $D017/53271/VIC+23:  Sprites Expand 2x Vertical (Y)

   +----------+---------------------------------------------------+
   | Bit  x   |   Sprite x: 1 = Sprite expanded                   |
   +----------+---------------------------------------------------+


 $D018/53272/VIC+24:   Memory Control Register

   +----------+---------------------------------------------------+
   | Bits 7-4 |   Video Matrix Base Address (inside VIC)          |
   | Bit  3   |   Bitmap-Mode: Select Base Address (inside VIC)   |
   | Bits 3-1 |   Character Dot-Data Base Address (inside VIC)    |
   | Bit  0   |   Unused                                          |
   +----------+---------------------------------------------------+

   Default Value: $14/20 (%00010100).

Kernal-Reference:

 LDA $D018   : $EB59 $EC48 $EC53
 STA $D018   : $EB5E $EC58


 $D019/53273/VIC+25:  Interrupt Request Register (IRR)

   1 = IRQ occured

   +----------+-------------------------------------------------------+
   | Bit 7    |   1 = IRQ has been generated                          |
   | Bit 3    |   Light-Pen Triggered IRQ Flag                        |
   | Bit 2    |   Sprite to Sprite Collision IRQ Flag     (see $D01E) |
   | Bit 1    |   Sprite to Background Collision IRQ Flag (see $D01F) |
   | Bit 0    |   Raster Compare IRQ Flag                 (see $D012) |
   +----------+-------------------------------------------------------+

   An IRQ will be initiated, if equal bits are set in IRR and IMR.

   Your VIC does NOT clear this register! You have to do this by
   setting the bits you want to clear.
   Note also that read-modify-write-instructions, like INC, ASL..., will
   not work on 65816-CPUs in native mode!

Kernal-Reference:

 LDA $D019   : $FF63


 $D01A/53274/VIC+26:  Interrupt Mask Register (IMR)

   1 = IRQ enabled

   +----------+-------------------------------------------------------+
   | Bit 7-4  |   Always 1                                            |
   | Bit 3    |   Light-Pen Triggered IRQ Flag                        |
   | Bit 2    |   Sprite to Sprite Collision IRQ Flag     (see $D01E) |
   | Bit 1    |   Sprite to Background Collision IRQ Flag (see $D01F) |
   | Bit 0    |   Raster Compare IRQ Flag                 (see $D012) |
   +----------+-------------------------------------------------------+

   An IRQ will be initiated, if equal bits are set in IRR and IMR.
   Default Value: $00/0 (%00000000).


 $D01B/53275/VIC+27:  Sprite to Background Display Priority

   +----------+---------------------------------------------------+
   | Bit  x   |   Sprite x: 0 = Sprite has higher Priority        |
   +----------+---------------------------------------------------+

   Higher Priority means sprite is in front of everything.

   Lower Priority means sprite is behind bit-combinations starting with
   1 (e.g. %1 in hires mode and %1x in multi-color mode) and in front of
   bit combinations starting with 0 (e.g. %0 in hires mode and %0x in
   multi-color mode). So we get the following priority-tables:

   Hires: Bit=0 < Sprite < Bit=1 ; Multi-Color: Bit=00 < Sprite < Bit = 10
                                                Bit=01 <        < Bit = 11


 $D01C/53276/VIC+28:   Sprites Multi-Color Mode Select

   +----------+---------------------------------------------------+
   | Bit  x   |   Sprite x: 1 = Sprite is in Multi-Color Mode     |
   +----------+---------------------------------------------------+

   See also: Bit Interpretations in Hires and MC-Mode


 $D01D/53277/VIC+29:  Sprites Expand 2x Horizontal (X)

   +----------+---------------------------------------------------+
   | Bit  x   |   Sprite x: 1 = Sprite expanded                   |
   +----------+---------------------------------------------------+


 $D01E/53278/VIC+30:  Sprite to Sprite Collision Detect

   If a Sprite to Sprite Collision is detected, Bits in $D01E will be set
   according to Sprite Numbers of the overlayed Sprites and additionally
   Bit 2 in $D019.

   Your VIC does NOT clear this register! You have to do this by
   simply reading it.


 $D01F/53279/VIC+31:  Sprite to Background Collision Detect

   If a Sprite to Background Collision is detected, Bits in $D01F will be
   set according to Sprite Number of the overlayed Sprite and additionally
   Bit 1 in $D019.

   Your VIC does NOT clear this register! You have to do this by
   simply reading it.


 $D020/53280/VIC+32:  Border Color

   Default Value: $0E/14 (%00001110)
         On SX64: $03/3 (%00000011)


 $D021/53281/VIC+33:  Background Color 0

   Default Value: $06/6 (%00000110)
         On SX64: $01/1 (%00000001)


 $D022/53282/VIC+34:  Background Color 1, Multi-Color Register 0

   $D022 stores an additional Color for Multi-Color Mode (Text and Bitmap)
   and for Extended Color Mode


 $D023/53283/VIC+35:  Background Color 2, Multi-Color Register 1

   $D023 stores an additional Color for Multi-Color Mode (Text and Bitmap)
   and for Extended Color Mode


 $D024/53284/VIC+36:  Background Color 3

   $D024 stores an additional Color for Extended Color Mode


 $D025/53285/VIC+37:  Sprite Multi-Color Register 0

   Additional Color for Sprites 0-7 in Multi-Color Mode


 $D026/53286/VIC+38:  Sprite Multi-Color Register 1

   Additional Color for Sprites 0-7 in Multi-Color Mode


 $D027/53287/VIC+39:  Sprite 0 Color


 $D028/53288/VIC+40:  Sprite 1 Color


 $D029/53289/VIC+41:  Sprite 2 Color


 $D02A/53290/VIC+42:  Sprite 3 Color


 $D02B/53291/VIC+43:  Sprite 4 Color


 $D02C/53292/VIC+44:  Sprite 5 Color


 $D02D/53293/VIC+45:  Sprite 6 Color


 $D02E/53294/VIC+46:  Sprite 7 Color


 $D02F/53295/VIC+47:  C128 only: Port A* for Extended Keyboard

   +----------+---------------------------------------------------+
   | Bits 7-3 |   no Function, always 1                           |
   | Bits 2-0 |   Write Keyboard Column Values for Keyboard Scan  |
   +----------+---------------------------------------------------+


 $D030/53296/VIC+48:  C128 only: Switch to FAST-Mode

   +----------+---------------------------------------------------+
   | Bits 7-2 |   no Function, always 1                           |
   | Bit  1   |   1 = Test-Mode(?)                                |
   |          |       ($D012 increases by one per cycle)          |
   | Bit  0   |   1 = Enable 2 MHz-Mode, VIC displays whatever is |
   |          |       on data-bus when in visible area            |
   +----------+---------------------------------------------------+


 +-------------------------+
 | VIC Bit Interpretations |
 +-------------------------+

  This map shows you which bit-combination forces VIC to get
  the color-data from which location for all the different modes.

 +---------------+----------------------------------------------------------+
 | Charset-Hires |  0 = Background ($D021)      1 = Color-RAM               |
 +---------------+----------------------------------------------------------+
 | Charset-MC    | 00 = Background ($D021)     01 = MC-Color1 ($D022)       |
 |               | 10 = MC-Color2  ($D023)     11 = Color-RAM               |
 +---------------+----------------------------------------------------------+
 | Bitmap-Hires  |  0 = LN Screen-RAM           1 = HN Screen-RAM           |
 +---------------+----------------------------------------------------------+
 | Bitmap-MC     | 00 = Background ($D021)     01 = HN Screen-RAM           |
 |               | 10 = LN Screen-RAM          11 = Color-RAM               |
 +---------------+----------------------------------------------------------+
 | Sprite-Hires  |  0 = Background ($D021)      1 = Sprite-Color ($D027..)  |
 +---------------+----------------------------------------------------------+
 | Sprite-MC     | 00 = Background ($D021)     01 = Sprite-MC-Color1 ($D025)|
 |               | 10 = Sprite-Color ($D027..) 11 = Sprite-MC-Color2 ($D026)|
 +---------------+----------------------------------------------------------+

  LN = Low-Nybble ; HN = High-Nybble


 VIC's 16 Colors:

  0/$0 = Black           8/$8  = Orange
  1/$1 = White           9/$9  = Brown
  2/$2 = Red             10/$A = Light Red
  3/$3 = Cyan            11/$B = Dark Grey
  4/$4 = Purple          12/$C = Grey
  5/$5 = Green           13/$D = Light Green
  6/$6 = Blue            14/$E = Light Blue
  7/$7 = Yellow          15/$F = Light Grey

 sorted by Brightness:

   White
   Yellow      Light Green
   Cyan        Light Grey
   Green       Light Red
   Grey        Light Blue
   Purple      Orange
   Red         Dark Grey
   Blue        Brown
   Black


 PAL-Timing Schemes for:

  Normal Scan Line       Normal Scan Line with Sprites
  Bad Scan Line          Bad Scan Line with Sprites
  Over Scan Line         Over Scan Line with Sprites

    Information was taken from 'PALTIME.TXT' by Marko Makela.
    Refer to that article if you want to know more about this topic.


 PAL-Timing scheme for a bad scan line, no sprites:

  +---------------------------------------------------------------+
  |         1         2         3         4         5         6   |
  |123456789012345678901234567890123456789012345678901234567890123|Cycles
  +---------[------(--------------------------------------)---]---+Borders
  |3-4-5-6-7-rrrrrgggggggggggggggggggggggggggggggggggggggg-N0-1-2-|Phi-1 VIC
  |              cccccccccccccccccccccccccccccccccccccccc         |Phi-2 VIC
  |xxxxxxxxxxxXXX========================================xxxxxxxxx|Phi-2 CPU
  +---------------------------------------------------------------+

  '-' = idle bus cycle (reads from the last byte of the video bank)

   <num> = pointer fetch for sprite <num>  ;  g = graphics fetch
   r = memory refresh cycle  ;  c = character pointer and/or color data fetch
   N = extra '-' cycles for NTSC added here

   x  = processor executes instructions (BA high, AEC high)
   X  = bus request pending, bus still available (BA low, AEC high);
        processor may execute write cycles, stops on the next read cycle.
  '=' = bus unavailable (BA low, AEC low); processor is blocked because it
        would like to read something.


 PAL-Timing scheme for a normal scan line, no sprites:

  +---------------------------------------------------------------+
  |         1         2         3         4         5         6   |
  |123456789012345678901234567890123456789012345678901234567890123|Cycles
  +---------[------(--------------------------------------)---]---+Borders
  |3-4-5-6-7-rrrrrgggggggggggggggggggggggggggggggggggggggg-N0-1-2-|Phi-1 VIC
  |                                                               |Phi-2 VIC
  |xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx|Phi-2 CPU
  +---------------------------------------------------------------+

  '-' = idle bus cycle (reads from the last byte of the video bank)

   <num> = pointer fetch for sprite <num>  ;  g = graphics fetch
   r = memory refresh cycle  ;  N = extra '-' cycles for NTSC added here

   x = processor executes instructions (BA high, AEC high)


 PAL-Timing scheme for a overscan raster line or blanked screen, no sprites:

  +---------------------------------------------------------------+
  |         1         2         3         4         5         6   |
  |123456789012345678901234567890123456789012345678901234567890123|Cycles
  +---------[------(--------------------------------------)---]---+Borders
  |3-4-5-6-7-rrrrr++++++++++++++++++++++++++++++++++++++++-N0-1-2-|Phi-1 VIC
  |                                                               |Phi-2 VIC
  |xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx|Phi-2 CPU
  +---------------------------------------------------------------+

  '-' = idle bus cycle (reads from the last byte of the video bank)
  '+' = idle bus cycle (just like '-', but reads from
        video_bank_base_address + $39FF if ECM ($D011 Bit 6) is selected)

   <num> = pointer fetch for sprite <num>  ;  r = memory refresh cycle
   N = extra '-' cycles for NTSC added here

   x = processor executes instructions (BA high, AEC high)


 PAL-Timing scheme for a bad scan line, at least the sprites 3-7 active on the
 current scan line and the sprites 0-2 on the following scan line:

  +---------------------------------------------------------------+
  |         1         2         3         4         5         6   |
  |123456789012345678901234567890123456789012345678901234567890123|Cycles
  +---------[------(--------------------------------------)---]---+Borders
  |3s4s5s6s7srrrrrgggggggggggggggggggggggggggggggggggggggg-N0s1s2s|Phi-1 VIC
  |ssssssssss    cccccccccccccccccccccccccccccccccccccccc   ssssss|Phi-2 VIC
  |==========xXXX========================================***======|Phi-2 CPU
  +---------------------------------------------------------------+

  '-' = idle bus cycle (reads from the last byte of the video bank)

   <num> = pointer fetch for sprite <num>  ;  g = graphics fetch
   r = memory refresh cycle  ;  c = character pointer and/or color data fetch
   s = sprite data fetch  ;  N = extra '-' cycles for NTSC added here

   x  = processor executes instructions (BA high, AEC high)
   X  = bus request pending, bus still available (BA low, AEC high);
        processor may execute write cycles, stops on the next read cycle.
  '*' = bus request pending, bus still available (BA low, AEC high);
        processor is blocked because it would like to read something.
  '=' = bus unavailable (BA low, AEC low); processor is blocked because it
        would like to read something.


 PAL-Timing scheme for a normal scan line, no sprites on the current scan line
 but at least the sprites 1+2 active on the following scan line:

  +---------------------------------------------------------------+
  |         1         2         3         4         5         6   |
  |123456789012345678901234567890123456789012345678901234567890123|Cycles
  +---------[------(--------------------------------------)---]---+Borders
  |3-4-5-6-7-rrrrrgggggggggggggggggggggggggggggggggggggggg-N0-1s2s|Phi-1 VIC
  |                                                           ssss|Phi-2 VIC
  |xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxXXX====|Phi-2 CPU
  +---------------------------------------------------------------+

  '-' = idle bus cycle (reads from the last byte of the video bank)

   <num> = pointer fetch for sprite <num>  ;  g = graphics fetch
   s = sprite data fetch  ;  r = memory refresh cycles
   N = extra '-' cycles for NTSC added here

   x  = processor executes instructions (BA high, AEC high)
   X  = bus request pending, bus still available (BA low, AEC high);
        processor may execute write cycles, stops on the next read cycle.
  '=' = bus unavailable (BA low, AEC low); processor is blocked because it
        would like to read something.


 PAL-Timing scheme for two successive overscan raster lines, sprites 1+3+7 active
 on the latter:

  +---------------------------------------------------------------+
  |         1         2         3         4         5         6   |
  |123456789012345678901234567890123456789012345678901234567890123|Cycles
  +---------[------(--------------------------------------)---]---+Borders
  |3-4-5-6-7-rrrrr++++++++++++++++++++++++++++++++++++++++-N0-1s2-|Phi-1 VIC
  |                                                           ss  |Phi-2 VIC
  |xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxXXX==**|Phi-2 CPU
  +---------------------------------------------------------------+
  |3s4-5-6-7srrrrr++++++++++++++++++++++++++++++++++++++++-N0-1-2-|Phi-1 VIC
  |ss      ss                                                     |Phi-2 VIC
  |==xxxXXX==xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx|Phi-2 CPU
  +---------------------------------------------------------------+

  '-' = idle bus cycle (reads from the last byte of the video bank)
  '+' = idle bus cycle (just like '-', but reads from
        video_bank_base_address + $39FF if ECM ($D011 Bit 6) is selected)

   <num> = pointer fetch for sprite <num>  ;  r = memory refresh cycle
   s = sprite data fetch  ;  N = extra '-' cycles for NTSC added here

   x  = processor executes instructions (BA high, AEC high)
   X  = bus request pending, bus still available (BA low, AEC high);
        processor may execute write cycles, stops on the next read cycle.
  '*' = bus request pending, bus still available (BA low, AEC high);
        processor is blocked because it would like to read something.
  '=' = bus unavailable (BA low, AEC low); processor is blocked because it
        would like to read something.

 VIC Screen Dimensions:
  +------------------------------------------------------------------------+
  |                                          Upper Border: $08             |
  |  O V E R S C A N - A R E A                                             |
  |    +--------------------------------------------------------------+    |
  |    |                        Upper Border:                         |    |
  |    |                             $33                              |    |
  |    |                                                              |    |
  |    |Left Border:                                     Right Border:|    |
  |    |    $18                                              $157     |    |
  |    |                                                              |    |
  |Left|                                                              |Rght|
  |Brdr|                                                              |Brdr|
  | :  |              D E F A U L T   T E X T - S C R E E N           | :  |
  |$1E0|                                                              |$1DF|
  |    |                        Lower Border:                         |    |
  |    |                             $FA                              |    |
  |    +--------------------------------------------------------------+    |
  |                                                                        |
  |                                          Lower Border: $12B            |
  +------------------------------------------------------------------------+

    The horizontal values are sprite coordinates, the vertical are
    rasterline counts (= Y sprite coordinates + 1).
    All values are inclusive, e.g. rasterlines $33 and $FA do belong to
    the default text screen.

    In the timing schemes the horizontal overscan borders are marked with
    '[' and ']', the text screen borders with '(' and ')'.


 VIC PAL/NTSC Differences:

 Here are some specifications about the different VIC types. Please note that
 the 6567R56A was only used in very early C64s and is mentioned here only
 for completeness.

 +----------+--------+-------+---------+---------+---------+------------+
 |   VIC    | Video  | # of  | Cycles/ | Cycles/ | Frames/ | System     |
 |   Type   | system | lines |  line   | frame   | second  | Clock (Hz) |
 +----------+--------+-------+---------+---------+---------+------------+
 |   6569   |  PAL-B |  312  |   63    |  19656  | 50.125  |   985248   |
 |  6567R8  | NTSC-M |  263  |   65    |  17095  | 59.826  |  1022727   |
 | 6567R56A | NTSC-M |  262  |   64    |  16768  |   ?     |     ?      |
 +----------+--------+-------+---------+---------+---------+------------+

 +----------+---------+-------------+
 |   VIC    | Visible |  Visible    |
 |   Type   |  lines  | pixels/line |
 +----------+---------+-------------+
 |   6569   |   284   |     403     |
 |  6567R8  |   235   |     418     |
 | 6567R56A |   234   |     411     |
 +----------+---------+-------------+

 +----------+--------+--------+--------------+------------+------------+
 |   VIC    | First  |  Last  |    First     |   First    |    Last    |
 |   Type   | vblank | vblank |   X coord.   |  visible   |  visible   |
 |          |  line  |  line  |  of a line   |  X coord.  |  X coord.  |
 +----------+--------+--------+--------------+------------+------------+
 |   6569   |  300   |   15   |  404 ($194)  | 480 ($1e0) | 380 ($17c) |
 |  6567R8  |   13   |   40   |  412 ($19c)  | 489 ($1e9) | 396 ($18c) |
 | 6567R56A |   13   |   40   |  412 ($19c)  | 488 ($1e8) | 388 ($184) |
 +----------+--------+--------+--------------+------------+------------+


  +------------------------------------------------------------------------
  |
  |    CBMSCII - Charset Map
  |
  +------------------------------------------------------------------------
  |
  |  Upper Case/Graphics:                Lower Case/Upper Case:
  |
  |   Chars $00-$3F (0 - 63)              Chars $00-$3F (0 - 63)
  |   Chars $40-$7F (64 - 127)            Chars $40-$7F (64 - 127)
  |   Chars $80-$BF (128 - 191)           Chars $80-$BF (128 - 191)
  |   Chars $C0-$FF (192 - 255)           Chars $C0-$FF (192 - 255)
  |
  +------------------------------------------------------------------------


 Upper Case/Graphics $00-$3F (0 - 63):

   $00/000  $01/001  $02/002  $03/003  $04/004  $05/005  $06/006  $07/007
   --####-- ---##--- -#####-- --####-- -####--- -######- -######- --####--
   -##--##- --####-- -##--##- -##--##- -##-##-- -##----- -##----- -##--##-
   -##-###- -##--##- -##--##- -##----- -##--##- -##----- -##----- -##-----
   -##-###- -######- -#####-- -##----- -##--##- -####--- -####--- -##-###-
   -##----- -##--##- -##--##- -##----- -##--##- -##----- -##----- -##--##-
   -##---#- -##--##- -##--##- -##--##- -##-##-- -##----- -##----- -##--##-
   --####-- -##--##- -#####-- --####-- -####--- -######- -##----- --####--
   -------- -------- -------- -------- -------- -------- -------- --------

   $08/008  $09/009  $0A/010  $0B/011  $0C/012  $0D/013  $0E/014  $0F/015
   -##--##- --####-- ---####- -##--##- -##----- -##---## -##--##- --####--
   -##--##- ---##--- ----##-- -##-##-- -##----- -###-### -###-##- -##--##-
   -##--##- ---##--- ----##-- -####--- -##----- -####### -######- -##--##-
   -######- ---##--- ----##-- -###---- -##----- -##-#-## -######- -##--##-
   -##--##- ---##--- ----##-- -####--- -##----- -##---## -##-###- -##--##-
   -##--##- ---##--- -##-##-- -##-##-- -##----- -##---## -##--##- -##--##-
   -##--##- --####-- --###--- -##--##- -######- -##---## -##--##- --####--
   -------- -------- -------- -------- -------- -------- -------- --------

   $10/016  $11/017  $12/018  $13/019  $14/020  $15/021  $16/022  $17/023
   -#####-- --####-- -#####-- --####-- -######- -##--##- -##--##- -##---##
   -##--##- -##--##- -##--##- -##--##- ---##--- -##--##- -##--##- -##---##
   -##--##- -##--##- -##--##- -##----- ---##--- -##--##- -##--##- -##---##
   -#####-- -##--##- -#####-- --####-- ---##--- -##--##- -##--##- -##-#-##
   -##----- -##--##- -####--- -----##- ---##--- -##--##- -##--##- -#######
   -##----- --####-- -##-##-- -##--##- ---##--- -##--##- --####-- -###-###
   -##----- ----###- -##--##- --####-- ---##--- --####-- ---##--- -##---##
   -------- -------- -------- -------- -------- -------- -------- --------

   $18/024  $19/025  $1A/026  $1B/027  $1C/028  $1D/029  $1E/030  $1F/031
   -##--##- -##--##- -######- --####-- ----##-- --####-- -------- --------
   -##--##- -##--##- -----##- --##---- ---#--#- ----##-- ---##--- ---#----
   --####-- -##--##- ----##-- --##---- --##---- ----##-- --####-- --##----
   ---##--- --####-- ---##--- --##---- -#####-- ----##-- -######- -#######
   --####-- ---##--- --##---- --##---- --##---- ----##-- ---##--- -#######
   -##--##- ---##--- -##----- --##---- -##---#- ----##-- ---##--- --##----
   -##--##- ---##--- -######- --####-- ######-- --####-- ---##--- ---#----
   -------- -------- -------- -------- -------- -------- ---##--- --------

   $20/032  $21/033  $22/034  $23/035  $24/036  $25/037  $26/038  $27/039
   -------- ---##--- -##--##- -##--##- ---##--- -##---#- --####-- -----##-
   -------- ---##--- -##--##- -##--##- --#####- -##--##- -##--##- ----##--
   -------- ---##--- -##--##- ######## -##----- ----##-- --####-- ---##---
   -------- ---##--- -------- -##--##- --####-- ---##--- --###--- --------
   -------- -------- -------- ######## -----##- --##---- -##--### --------
   -------- -------- -------- -##--##- -#####-- -##--##- -##--##- --------
   -------- ---##--- -------- -##--##- ---##--- -#---##- --###### --------
   -------- -------- -------- -------- -------- -------- -------- --------

   $28/040  $29/041  $2A/042  $2B/043  $2C/044  $2D/045  $2E/046  $2F/047
   ----##-- --##---- -------- -------- -------- -------- -------- --------
   ---##--- ---##--- -##--##- ---##--- -------- -------- -------- ------##
   --##---- ----##-- --####-- ---##--- -------- -------- -------- -----##-
   --##---- ----##-- ######## -######- -------- -######- -------- ----##--
   --##---- ----##-- --####-- ---##--- -------- -------- -------- ---##---
   ---##--- ---##--- -##--##- ---##--- ---##--- -------- ---##--- --##----
   ----##-- --##---- -------- -------- ---##--- -------- ---##--- -##-----
   -------- -------- -------- -------- --##---- -------- -------- --------

   $30/048  $31/049  $32/050  $33/051  $34/052  $35/053  $36/054  $37/055
   --####-- ---##--- --####-- --####-- -----##- -######- --####-- -######-
   -##--##- ---##--- -##--##- -##--##- ----###- -##----- -##--##- -##--##-
   -##-###- --###--- -----##- -----##- ---####- -#####-- -##----- ----##--
   -###-##- ---##--- ----##-- ---###-- -##--##- -----##- -#####-- ---##---
   -##--##- ---##--- --##---- -----##- -####### -----##- -##--##- ---##---
   -##--##- ---##--- -##----- -##--##- -----##- -##--##- -##--##- ---##---
   --####-- -######- -######- --####-- -----##- --####-- --####-- ---##---
   -------- -------- -------- -------- -------- -------- -------- --------

   $38/056  $39/057  $3A/058  $3B/059  $3C/060  $3D/061  $3E/062  $3F/063
   --####-- --####-- -------- -------- ----###- -------- -###---- --####--
   -##--##- -##--##- -------- -------- ---##--- -------- ---##--- -##--##-
   -##--##- -##--##- ---##--- ---##--- --##---- -######- ----##-- -----##-
   --####-- --#####- -------- -------- -##----- -------- -----##- ----##--
   -##--##- -----##- -------- -------- --##---- -######- ----##-- ---##---
   -##--##- -##--##- ---##--- ---##--- ---##--- -------- ---##--- --------
   --####-- --####-- -------- ---##--- ----###- -------- -###---- ---##---
   -------- -------- -------- --##---- -------- -------- -------- --------

  Upper Case/Graphics:                Lower Case/Upper Case:

   Chars $00-$3F (0 - 63)              Chars $00-$3F (0 - 63)
   Chars $40-$7F (64 - 127)            Chars $40-$7F (64 - 127)
   Chars $80-$BF (128 - 191)           Chars $80-$BF (128 - 191)
   Chars $C0-$FF (192 - 255)           Chars $C0-$FF (192 - 255)


 Upper Case/Graphics $40-$7F (64 - 127):

   $40/064  $41/065  $42/066  $43/067  $44/068  $45/069  $46/070  $47/071
   -------- ----#--- ---##--- -------- -------- -------- -------- --##----
   -------- ---###-- ---##--- -------- -------- ######## -------- --##----
   -------- --#####- ---##--- -------- ######## ######## -------- --##----
   ######## -####### ---##--- ######## ######## -------- -------- --##----
   ######## -####### ---##--- ######## -------- -------- ######## --##----
   -------- ---###-- ---##--- -------- -------- -------- ######## --##----
   -------- --#####- ---##--- -------- -------- -------- -------- --##----
   -------- -------- ---##--- -------- -------- -------- -------- --##----

   $48/072  $49/073  $4A/074  $4B/075  $4C/076  $4D/077  $4E/078  $4F/079
   ----##-- -------- ---##--- ---##--- ##------ ##------ ------## ########
   ----##-- -------- ---##--- ---##--- ##------ ###----- -----### ########
   ----##-- -------- ---###-- --###--- ##------ -###---- ----###- ##------
   ----##-- ###----- ----#### ####---- ##------ --###--- ---###-- ##------
   ----##-- ####---- -----### ###----- ##------ ---###-- --###--- ##------
   ----##-- --###--- -------- -------- ##------ ----###- -###---- ##------
   ----##-- ---##--- -------- -------- ######## -----### ###----- ##------
   ----##-- ---##--- -------- -------- ######## ------## ##------ ##------

   $50/080  $51/081  $52/082  $53/083  $54/084  $55/085  $56/086  $57/087
   ######## -------- -------- --##-##- -##----- -------- ##----## --------
   ######## --####-- -------- -####### -##----- -------- ###--### --####--
   ------## -######- -------- -####### -##----- -------- -######- -######-
   ------## -######- -------- -####### -##----- -----### --####-- -##--##-
   ------## -######- -------- --#####- -##----- ----#### --####-- -##--##-
   ------## -######- ######## ---###-- -##----- ---###-- -######- -######-
   ------## --####-- ######## ----#--- -##----- ---##--- ###--### --####--
   ------## -------- -------- -------- -##----- ---##--- ##----## --------

   $58/088  $59/089  $5A/090  $5B/091  $5C/092  $5D/093  $5E/094  $5F/095
   ---##--- -----##- ----#--- ---##--- ##------ ---##--- -------- ########
   ---##--- -----##- ---###-- ---##--- ##------ ---##--- -------- -#######
   -##--##- -----##- --#####- ---##--- --##---- ---##--- ------## --######
   -##--##- -----##- -####### ######## --##---- ---##--- --#####- ---#####
   ---##--- -----##- --#####- ######## ##------ ---##--- -###-##- ----####
   ---##--- -----##- ---###-- ---##--- ##------ ---##--- --##-##- -----###
   --####-- -----##- ----#--- ---##--- --##---- ---##--- --##-##- ------##
   -------- -----##- -------- ---##--- --##---- ---##--- -------- -------#

   $60/096  $61/097  $62/098  $63/099  $64/100  $65/101  $66/102  $67/103
   -------- ####---- -------- ######## -------- ##------ ##--##-- ------##
   -------- ####---- -------- -------- -------- ##------ ##--##-- ------##
   -------- ####---- -------- -------- -------- ##------ --##--## ------##
   -------- ####---- -------- -------- -------- ##------ --##--## ------##
   -------- ####---- ######## -------- -------- ##------ ##--##-- ------##
   -------- ####---- ######## -------- -------- ##------ ##--##-- ------##
   -------- ####---- ######## -------- -------- ##------ --##--## ------##
   -------- ####---- ######## -------- ######## ##------ --##--## ------##

   $68/104  $69/105  $6A/106  $6B/107  $6C/108  $6D/109  $6E/110  $6F/111
   -------- ######## ------## ---##--- -------- ---##--- -------- --------
   -------- #######- ------## ---##--- -------- ---##--- -------- --------
   -------- ######-- ------## ---##--- -------- ---##--- -------- --------
   -------- #####--- ------## ---##### -------- ---##### #####--- --------
   ##--##-- ####---- ------## ---##### ----#### ---##### #####--- --------
   ##--##-- ###----- ------## ---##--- ----#### -------- ---##--- --------
   --##--## ##------ ------## ---##--- ----#### -------- ---##--- ########
   --##--## #------- ------## ---##--- ----#### -------- ---##--- ########

   $70/112  $71/113  $72/114  $73/115  $74/116  $75/117  $76/118  $77/119
   -------- ---##--- -------- ---##--- ##------ ###----- -----### ########
   -------- ---##--- -------- ---##--- ##------ ###----- -----### ########
   -------- ---##--- -------- ---##--- ##------ ###----- -----### --------
   ---##### ######## ######## #####--- ##------ ###----- -----### --------
   ---##### ######## ######## #####--- ##------ ###----- -----### --------
   ---##--- -------- ---##--- ---##--- ##------ ###----- -----### --------
   ---##--- -------- ---##--- ---##--- ##------ ###----- -----### --------
   ---##--- -------- ---##--- ---##--- ##------ ###----- -----### --------

   $78/120  $79/121  $7A/122  $7B/123  $7C/124  $7D/125  $7E/126  $7F/127
   ######## -------- ------## -------- ----#### ---##--- ####---- ####----
   ######## -------- ------## -------- ----#### ---##--- ####---- ####----
   ######## -------- ------## -------- ----#### ---##--- ####---- ####----
   -------- -------- ------## -------- ----#### #####--- ####---- ####----
   -------- -------- ------## ####---- -------- #####--- -------- ----####
   -------- ######## ------## ####---- -------- -------- -------- ----####
   -------- ######## ######## ####---- -------- -------- -------- ----####
   -------- ######## ######## ####---- -------- -------- -------- ----####

  Upper Case/Graphics:                Lower Case/Upper Case:

   Chars $00-$3F (0 - 63)              Chars $00-$3F (0 - 63)
   Chars $40-$7F (64 - 127)            Chars $40-$7F (64 - 127)
   Chars $80-$BF (128 - 191)           Chars $80-$BF (128 - 191)
   Chars $C0-$FF (192 - 255)           Chars $C0-$FF (192 - 255)


 Upper Case/Graphics $80-$BF (128 - 191):

   $80/128  $81/129  $82/130  $83/131  $84/132  $85/133  $86/134  $87/135
   ##----## ###--### #-----## ##----## #----### #------# #------# ##----##
   #--##--# ##----## #--##--# #--##--# #--#--## #--##### #--##### #--##--#
   #--#---# #--##--# #--##--# #--##### #--##--# #--##### #--##### #--#####
   #--#---# #------# #-----## #--##### #--##--# #----### #----### #--#---#
   #--##### #--##--# #--##--# #--##### #--##--# #--##### #--##### #--##--#
   #--##--# #--##--# #--##--# #--##--# #--#--## #--##### #--##### #--##--#
   ##----## #--##--# #-----## ##----## #----### #------# #--##### ##----##
   ######## ######## ######## ######## ######## ######## ######## ########

   $88/136  $89/137  $8A/138  $8B/139  $8C/140  $8D/141  $8E/142  $8F/143
   #--##--# ##----## ###----# #--##--# #--##### #--###-- #--##--# ##----##
   #--##--# ###--### ####--## #--#--## #--##### #---#--- #---#--# #--##--#
   #--##--# ###--### ####--## #----### #--##### #------- #------# #--##--#
   #------# ###--### ####--## #---#### #--##### #--#-#-- #------# #--##--#
   #--##--# ###--### ####--## #----### #--##### #--###-- #--#---# #--##--#
   #--##--# ###--### #--#--## #--#--## #--##### #--###-- #--##--# #--##--#
   #--##--# ##----## ##---### #--##--# #------# #--###-- #--##--# ##----##
   ######## ######## ######## ######## ######## ######## ######## ########

   $90/144  $91/145  $92/146  $93/147  $94/148  $95/149  $96/150  $97/151
   #-----## ##----## #-----## ##----## #------# #--##--# #--##--# #--###--
   #--##--# #--##--# #--##--# #--##--# ###--### #--##--# #--##--# #--###--
   #--##--# #--##--# #--##--# #--##### ###--### #--##--# #--##--# #--###--
   #-----## #--##--# #-----## ##----## ###--### #--##--# #--##--# #--#-#--
   #--##### #--##--# #----### #####--# ###--### #--##--# #--##--# #-------
   #--##### ##----## #--#--## #--##--# ###--### #--##--# ##----## #---#---
   #--##### ####---# #--##--# ##----## ###--### ##----## ###--### #--###--
   ######## ######## ######## ######## ######## ######## ######## ########

   $98/152  $99/153  $9A/154  $9B/155  $9C/156  $9D/157  $9E/158  $9F/159
   #--##--# #--##--# #------# ##----## ####--## ##----## ######## ########
   #--##--# #--##--# #####--# ##--#### ###-##-# ####--## ###--### ###-####
   ##----## #--##--# ####--## ##--#### ##--#### ####--## ##----## ##--####
   ###--### ##----## ###--### ##--#### #-----## ####--## #------# #-------
   ##----## ###--### ##--#### ##--#### ##--#### ####--## ###--### #-------
   #--##--# ###--### #--##### ##--#### #--###-# ####--## ###--### ##--####
   #--##--# ###--### #------# ##----## ------## ##----## ###--### ###-####
   ######## ######## ######## ######## ######## ######## ###--### ########

   $A0/160  $A1/161  $A2/162  $A3/163  $A4/164  $A5/165  $A6/166  $A7/167
   ######## ###--### #--##--# #--##--# ###--### #--###-# ##----## #####--#
   ######## ###--### #--##--# #--##--# ##-----# #--##--# #--##--# ####--##
   ######## ###--### #--##--# -------- #--##### ####--## ##----## ###--###
   ######## ###--### ######## #--##--# ##----## ###--### ##---### ########
   ######## ######## ######## -------- #####--# ##--#### #--##--- ########
   ######## ######## ######## #--##--# #-----## #--##--# #--##--# ########
   ######## ###--### ######## #--##--# ###--### #-###--# ##------ ########
   ######## ######## ######## ######## ######## ######## ######## ########

   $A8/168  $A9/169  $AA/170  $AB/171  $AC/172  $AD/173  $AE/174  $AF/175
   ####--## ##--#### ######## ######## ######## ######## ######## ########
   ###--### ###--### #--##--# ###--### ######## ######## ######## ######--
   ##--#### ####--## ##----## ###--### ######## ######## ######## #####--#
   ##--#### ####--## -------- #------# ######## #------# ######## ####--##
   ##--#### ####--## ##----## ###--### ######## ######## ######## ###--###
   ###--### ###--### #--##--# ###--### ###--### ######## ###--### ##--####
   ####--## ##--#### ######## ######## ###--### ######## ###--### #--#####
   ######## ######## ######## ######## ##--#### ######## ######## ########

   $B0/176  $B1/177  $B2/178  $B3/179  $B4/180  $B5/181  $B6/182  $B7/183
   ##----## ###--### ##----## ##----## #####--# #------# ##----## #------#
   #--##--# ###--### #--##--# #--##--# ####---# #--##### #--##--# #--##--#
   #--#---# ##---### #####--# #####--# ###----# #-----## #--##### ####--##
   #---#--# ###--### ####--## ###---## #--##--# #####--# #-----## ###--###
   #--##--# ###--### ##--#### #####--# #------- #####--# #--##--# ###--###
   #--##--# ###--### #--##### #--##--# #####--# #--##--# #--##--# ###--###
   ##----## #------# #------# ##----## #####--# ##----## ##----## ###--###
   ######## ######## ######## ######## ######## ######## ######## ########

   $B8/184  $B9/185  $BA/186  $BB/187  $BC/188  $BD/189  $BE/190  $BF/191
   ##----## ##----## ######## ######## ####---# ######## #---#### ##----##
   #--##--# #--##--# ######## ######## ###--### ######## ###--### #--##--#
   #--##--# #--##--# ###--### ###--### ##--#### #------# ####--## #####--#
   ##----## ##-----# ######## ######## #--##### ######## #####--# ####--##
   #--##--# #####--# ######## ######## ##--#### #------# ####--## ###--###
   #--##--# #--##--# ###--### ###--### ###--### ######## ###--### ########
   ##----## ##----## ######## ###--### ####---# ######## #---#### ###--###
   ######## ######## ######## ##--#### ######## ######## ######## ########

  Upper Case/Graphics:                Lower Case/Upper Case:

   Chars $00-$3F (0 - 63)              Chars $00-$3F (0 - 63)
   Chars $40-$7F (64 - 127)            Chars $40-$7F (64 - 127)
   Chars $80-$BF (128 - 191)           Chars $80-$BF (128 - 191)
   Chars $C0-$FF (192 - 255)           Chars $C0-$FF (192 - 255)


 Upper Case/Graphics $C0-$FF (192 - 255):

   $C0/192  $C1/193  $C2/194  $C3/195  $C4/196  $C5/197  $C6/198  $C7/199
   ######## ####-### ###--### ######## ######## ######## ######## ##--####
   ######## ###---## ###--### ######## ######## -------- ######## ##--####
   ######## ##-----# ###--### ######## -------- -------- ######## ##--####
   -------- #------- ###--### -------- -------- ######## ######## ##--####
   -------- #------- ###--### -------- ######## ######## -------- ##--####
   ######## ###---## ###--### ######## ######## ######## -------- ##--####
   ######## ##-----# ###--### ######## ######## ######## ######## ##--####
   ######## ######## ###--### ######## ######## ######## ######## ##--####

   $C8/200  $C9/201  $CA/202  $CB/203  $CC/204  $CD/205  $CE/206  $CF/207
   ####--## ######## ###--### ###--### --###### --###### ######-- --------
   ####--## ######## ###--### ###--### --###### ---##### #####--- --------
   ####--## ######## ###---## ##---### --###### #---#### ####---# --######
   ####--## ---##### ####---- ----#### --###### ##---### ###---## --######
   ####--## ----#### #####--- ---##### --###### ###---## ##---### --######
   ####--## ##---### ######## ######## --###### ####---# #---#### --######
   ####--## ###--### ######## ######## -------- #####--- ---##### --######
   ####--## ###--### ######## ######## -------- ######-- --###### --######

   $D0/208  $D1/209  $D2/210  $D3/211  $D4/212  $D5/213  $D6/214  $D7/215
   -------- ######## ######## ##--#--# #--##### ######## --####-- ########
   -------- ##----## ######## #------- #--##### ######## ---##--- ##----##
   ######-- #------# ######## #------- #--##### ######## #------# #------#
   ######-- #------# ######## #------- #--##### #####--- ##----## #--##--#
   ######-- #------# ######## ##-----# #--##### ####---- ##----## #--##--#
   ######-- #------# -------- ###---## #--##### ###---## #------# #------#
   ######-- ##----## -------- ####-### #--##### ###--### ---##--- ##----##
   ######-- ######## ######## ######## #--##### ###--### --####-- ########

   $D8/216  $D9/217  $DA/218  $DB/219  $DC/220  $DD/221  $DE/222  $DF/223
   ###--### #####--# ####-### ###--### --###### ###--### ######## --------
   ###--### #####--# ###---## ###--### --###### ###--### ######## #-------
   #--##--# #####--# ##-----# ###--### ##--#### ###--### ######-- ##------
   #--##--# #####--# #------- -------- ##--#### ###--### ##-----# ###-----
   ###--### #####--# ##-----# -------- --###### ###--### #---#--# ####----
   ###--### #####--# ###---## ###--### --###### ###--### ##--#--# #####---
   ##----## #####--# ####-### ###--### ##--#### ###--### ##--#--# ######--
   ######## #####--# ######## ###--### ##--#### ###--### ######## #######-

   $E0/224  $E1/225  $E2/226  $E3/227  $E4/228  $E5/229  $E6/230  $E7/231
   ######## ----#### ######## -------- ######## --###### --##--## ######--
   ######## ----#### ######## ######## ######## --###### --##--## ######--
   ######## ----#### ######## ######## ######## --###### ##--##-- ######--
   ######## ----#### ######## ######## ######## --###### ##--##-- ######--
   ######## ----#### -------- ######## ######## --###### --##--## ######--
   ######## ----#### -------- ######## ######## --###### --##--## ######--
   ######## ----#### -------- ######## ######## --###### ##--##-- ######--
   ######## ----#### -------- ######## -------- --###### ##--##-- ######--

   $E8/232  $E9/233  $EA/234  $EB/235  $EC/236  $ED/237  $EE/238  $EF/239
   ######## -------- ######-- ###--### ######## ###--### ######## ########
   ######## -------# ######-- ###--### ######## ###--### ######## ########
   ######## ------## ######-- ###--### ######## ###--### ######## ########
   ######## -----### ######-- ###----- ######## ###----- -----### ########
   --##--## ----#### ######-- ###----- ####---- ###----- -----### ########
   --##--## ---##### ######-- ###--### ####---- ######## ###--### ########
   ##--##-- --###### ######-- ###--### ####---- ######## ###--### --------
   ##--##-- -####### ######-- ###--### ####---- ######## ###--### --------

   $F0/240  $F1/241  $F2/242  $F3/243  $F4/244  $F5/245  $F6/246  $F7/247
   ######## ###--### ######## ###--### --###### ---##### #####--- --------
   ######## ###--### ######## ###--### --###### ---##### #####--- --------
   ######## ###--### ######## ###--### --###### ---##### #####--- ########
   ###----- -------- -------- -----### --###### ---##### #####--- ########
   ###----- -------- -------- -----### --###### ---##### #####--- ########
   ###--### ######## ###--### ###--### --###### ---##### #####--- ########
   ###--### ######## ###--### ###--### --###### ---##### #####--- ########
   ###--### ######## ###--### ###--### --###### ---##### #####--- ########

   $F8/248  $F9/249  $FA/250  $FB/251  $FC/252  $FD/253  $FE/254  $FF/255

   -------- ######## ######-- ######## ####---- ###--### ----#### ----####
   -------- ######## ######-- ######## ####---- ###--### ----#### ----####
   -------- ######## ######-- ######## ####---- ###--### ----#### ----####
   ######## ######## ######-- ######## ####---- -----### ----#### ----####
   ######## ######## ######-- ----#### ######## -----### ######## ####----
   ######## -------- ######-- ----#### ######## ######## ######## ####----
   ######## -------- -------- ----#### ######## ######## ######## ####----
   ######## -------- -------- ----#### ######## ######## ######## ####----

  Upper Case/Graphics:                Lower Case/Upper Case:

   Chars $00-$3F (0 - 63)              Chars $00-$3F (0 - 63)
   Chars $40-$7F (64 - 127)            Chars $40-$7F (64 - 127)
   Chars $80-$BF (128 - 191)           Chars $80-$BF (128 - 191)
   Chars $C0-$FF (192 - 255)           Chars $C0-$FF (192 - 255)


 Lower Case/Upper Case $00-$3F (0 - 63):

   $00/000  $01/001  $02/002  $03/003  $04/004  $05/005  $06/006  $07/007
   --####-- -------- -------- -------- -------- -------- -------- --------
   -##--##- -------- -##----- -------- -----##- -------- ----###- --------
   -##-###- --####-- -##----- --####-- -----##- --####-- ---##--- --#####-
   -##-###- -----##- -#####-- -##----- --#####- -##--##- --#####- -##--##-
   -##----- --#####- -##--##- -##----- -##--##- -######- ---##--- -##--##-
   -##---#- -##--##- -##--##- -##----- -##--##- -##----- ---##--- --#####-
   --####-- --#####- -#####-- --####-- --#####- --####-- ---##--- -----##-
   -------- -------- -------- -------- -------- -------- -------- -#####--

   $08/008  $09/009  $0A/010  $0B/011  $0C/012  $0D/013  $0E/014  $0F/015
   -------- -------- -------- -------- -------- -------- -------- --------
   -##----- ---##--- -----##- -##----- --###--- -------- -------- --------
   -##----- -------- -------- -##----- ---##--- -##--##- -#####-- --####--
   -#####-- --###--- -----##- -##-##-- ---##--- -####### -##--##- -##--##-
   -##--##- ---##--- -----##- -####--- ---##--- -####### -##--##- -##--##-
   -##--##- ---##--- -----##- -##-##-- ---##--- -##-#-## -##--##- -##--##-
   -##--##- --####-- -----##- -##--##- --####-- -##---## -##--##- --####--
   -------- -------- --####-- -------- -------- -------- -------- --------

   $10/016  $11/017  $12/018  $13/019  $14/020  $15/021  $16/022  $17/023
   -------- -------- -------- -------- -------- -------- -------- --------
   -------- -------- -------- -------- ---##--- -------- -------- --------
   -#####-- --#####- -#####-- --#####- -######- -##--##- -##--##- -##---##
   -##--##- -##--##- -##--##- -##----- ---##--- -##--##- -##--##- -##-#-##
   -##--##- -##--##- -##----- --####-- ---##--- -##--##- -##--##- -#######
   -#####-- --#####- -##----- -----##- ---##--- -##--##- --####-- --#####-
   -##----- -----##- -##----- -#####-- ----###- --#####- ---##--- --##-##-
   -##----- -----##- -------- -------- -------- -------- -------- --------

   $18/024  $19/025  $1A/026  $1B/027  $1C/028  $1D/029  $1E/030  $1F/031
   -------- -------- -------- --####-- ----##-- --####-- -------- --------
   -------- -------- -------- --##---- ---#--#- ----##-- ---##--- ---#----
   -##--##- -##--##- -######- --##---- --##---- ----##-- --####-- --##----
   --####-- -##--##- ----##-- --##---- -#####-- ----##-- -######- -#######
   ---##--- -##--##- ---##--- --##---- --##---- ----##-- ---##--- -#######
   --####-- --#####- --##---- --##---- -##---#- ----##-- ---##--- --##----
   -##--##- ----##-- -######- --####-- ######-- --####-- ---##--- ---#----
   -------- -####--- -------- -------- -------- -------- ---##--- --------

   $20/032  $21/033  $22/034  $23/035  $24/036  $25/037  $26/038  $27/039
   -------- ---##--- -##--##- -##--##- ---##--- -##---#- --####-- -----##-
   -------- ---##--- -##--##- -##--##- --#####- -##--##- -##--##- ----##--
   -------- ---##--- -##--##- ######## -##----- ----##-- --####-- ---##---
   -------- ---##--- -------- -##--##- --####-- ---##--- --###--- --------
   -------- -------- -------- ######## -----##- --##---- -##--### --------
   -------- -------- -------- -##--##- -#####-- -##--##- -##--##- --------
   -------- ---##--- -------- -##--##- ---##--- -#---##- --###### --------
   -------- -------- -------- -------- -------- -------- -------- --------

   $28/040  $29/041  $2A/042  $2B/043  $2C/044  $2D/045  $2E/046  $2F/047
   ----##-- --##---- -------- -------- -------- -------- -------- --------
   ---##--- ---##--- -##--##- ---##--- -------- -------- -------- ------##
   --##---- ----##-- --####-- ---##--- -------- -------- -------- -----##-
   --##---- ----##-- ######## -######- -------- -######- -------- ----##--
   --##---- ----##-- --####-- ---##--- -------- -------- -------- ---##---
   ---##--- ---##--- -##--##- ---##--- ---##--- -------- ---##--- --##----
   ----##-- --##---- -------- -------- ---##--- -------- ---##--- -##-----
   -------- -------- -------- -------- --##---- -------- -------- --------

   $30/048  $31/049  $32/050  $33/051  $34/052  $35/053  $36/054  $37/055
   --####-- ---##--- --####-- --####-- -----##- -######- --####-- -######-
   -##--##- ---##--- -##--##- -##--##- ----###- -##----- -##--##- -##--##-
   -##-###- --###--- -----##- -----##- ---####- -#####-- -##----- ----##--
   -###-##- ---##--- ----##-- ---###-- -##--##- -----##- -#####-- ---##---
   -##--##- ---##--- --##---- -----##- -####### -----##- -##--##- ---##---
   -##--##- ---##--- -##----- -##--##- -----##- -##--##- -##--##- ---##---
   --####-- -######- -######- --####-- -----##- --####-- --####-- ---##---
   -------- -------- -------- -------- -------- -------- -------- --------

   $38/056  $39/057  $3A/058  $3B/059  $3C/060  $3D/061  $3E/062  $3F/063
   --####-- --####-- -------- -------- ----###- -------- -###---- --####--
   -##--##- -##--##- -------- -------- ---##--- -------- ---##--- -##--##-
   -##--##- -##--##- ---##--- ---##--- --##---- -######- ----##-- -----##-
   --####-- --#####- -------- -------- -##----- -------- -----##- ----##--
   -##--##- -----##- -------- -------- --##---- -######- ----##-- ---##---
   -##--##- -##--##- ---##--- ---##--- ---##--- -------- ---##--- --------
   --####-- --####-- -------- ---##--- ----###- -------- -###---- ---##---
   -------- -------- -------- --##---- -------- -------- -------- --------

  Upper Case/Graphics:                Lower Case/Upper Case:

   Chars $00-$3F (0 - 63)              Chars $00-$3F (0 - 63)
   Chars $40-$7F (64 - 127)            Chars $40-$7F (64 - 127)
   Chars $80-$BF (128 - 191)           Chars $80-$BF (128 - 191)
   Chars $C0-$FF (192 - 255)           Chars $C0-$FF (192 - 255)


 Lower Case/Upper Case $40-$7F (64 - 127):

   $40/064  $41/065  $42/066  $43/067  $44/068  $45/069  $46/070  $47/071
   -------- ---##--- -#####-- --####-- -####--- -######- -######- --####--
   -------- --####-- -##--##- -##--##- -##-##-- -##----- -##----- -##--##-
   -------- -##--##- -##--##- -##----- -##--##- -##----- -##----- -##-----
   ######## -######- -#####-- -##----- -##--##- -####--- -####--- -##-###-
   ######## -##--##- -##--##- -##----- -##--##- -##----- -##----- -##--##-
   -------- -##--##- -##--##- -##--##- -##-##-- -##----- -##----- -##--##-
   -------- -##--##- -#####-- --####-- -####--- -######- -##----- --####--
   -------- -------- -------- -------- -------- -------- -------- --------

   $48/072  $49/073  $4A/074  $4B/075  $4C/076  $4D/077  $4E/078  $4F/079
   -##--##- --####-- ---####- -##--##- -##----- -##---## -##--##- --####--
   -##--##- ---##--- ----##-- -##-##-- -##----- -###-### -###-##- -##--##-
   -##--##- ---##--- ----##-- -####--- -##----- -####### -######- -##--##-
   -######- ---##--- ----##-- -###---- -##----- -##-#-## -######- -##--##-
   -##--##- ---##--- ----##-- -####--- -##----- -##---## -##-###- -##--##-
   -##--##- ---##--- -##-##-- -##-##-- -##----- -##---## -##--##- -##--##-
   -##--##- --####-- --###--- -##--##- -######- -##---## -##--##- --####--
   -------- -------- -------- -------- -------- -------- -------- --------

   $50/080  $51/081  $52/082  $53/083  $54/084  $55/085  $56/086  $57/087
   -#####-- --####-- -#####-- --####-- -######- -##--##- -##--##- -##---##
   -##--##- -##--##- -##--##- -##--##- ---##--- -##--##- -##--##- -##---##
   -##--##- -##--##- -##--##- -##----- ---##--- -##--##- -##--##- -##---##
   -#####-- -##--##- -#####-- --####-- ---##--- -##--##- -##--##- -##-#-##
   -##----- -##--##- -####--- -----##- ---##--- -##--##- -##--##- -#######
   -##----- --####-- -##-##-- -##--##- ---##--- -##--##- --####-- -###-###
   -##----- ----###- -##--##- --####-- ---##--- --####-- ---##--- -##---##
   -------- -------- -------- -------- -------- -------- -------- --------

   $58/088  $59/089  $5A/090  $5B/091  $5C/092  $5D/093  $5E/094  $5F/095
   -##--##- -##--##- -######- ---##--- ##------ ---##--- --##--## --##--##
   -##--##- -##--##- -----##- ---##--- ##------ ---##--- --##--## #--##--#
   --####-- -##--##- ----##-- ---##--- --##---- ---##--- ##--##-- ##--##--
   ---##--- --####-- ---##--- ######## --##---- ---##--- ##--##-- -##--##-
   --####-- ---##--- --##---- ######## ##------ ---##--- --##--## --##--##
   -##--##- ---##--- -##----- ---##--- ##------ ---##--- --##--## #--##--#
   -##--##- ---##--- -######- ---##--- --##---- ---##--- ##--##-- ##--##--
   -------- -------- -------- ---##--- --##---- ---##--- ##--##-- -##--##-

   $60/096  $61/097  $62/098  $63/099  $64/100  $65/101  $66/102  $67/103
   -------- ####---- -------- ######## -------- ##------ ##--##-- ------##
   -------- ####---- -------- -------- -------- ##------ ##--##-- ------##
   -------- ####---- -------- -------- -------- ##------ --##--## ------##
   -------- ####---- -------- -------- -------- ##------ --##--## ------##
   -------- ####---- ######## -------- -------- ##------ ##--##-- ------##
   -------- ####---- ######## -------- -------- ##------ ##--##-- ------##
   -------- ####---- ######## -------- -------- ##------ --##--## ------##
   -------- ####---- ######## -------- ######## ##------ --##--## ------##

   $68/104  $69/105  $6A/106  $6B/107  $6C/108  $6D/109  $6E/110  $6F/111
   -------- ##--##-- ------## ---##--- -------- ---##--- -------- --------
   -------- #--##--# ------## ---##--- -------- ---##--- -------- --------
   -------- --##--## ------## ---##--- -------- ---##--- -------- --------
   -------- -##--##- ------## ---##### -------- ---##### #####--- --------
   ##--##-- ##--##-- ------## ---##### ----#### ---##### #####--- --------
   ##--##-- #--##--# ------## ---##--- ----#### -------- ---##--- --------
   --##--## --##--## ------## ---##--- ----#### -------- ---##--- ########
   --##--## -##--##- ------## ---##--- ----#### -------- ---##--- ########

   $70/112  $71/113  $72/114  $73/115  $74/116  $75/117  $76/118  $77/119
   -------- ---##--- -------- ---##--- ##------ ###----- -----### ########
   -------- ---##--- -------- ---##--- ##------ ###----- -----### ########
   -------- ---##--- -------- ---##--- ##------ ###----- -----### --------
   ---##### ######## ######## #####--- ##------ ###----- -----### --------
   ---##### ######## ######## #####--- ##------ ###----- -----### --------
   ---##--- -------- ---##--- ---##--- ##------ ###----- -----### --------
   ---##--- -------- ---##--- ---##--- ##------ ###----- -----### --------
   ---##--- -------- ---##--- ---##--- ##------ ###----- -----### --------

   $78/120  $79/121  $7A/122  $7B/123  $7C/124  $7D/125  $7E/126  $7F/127
   ######## -------- -------# -------- ----#### ---##--- ####---- ####----
   ######## -------- ------## -------- ----#### ---##--- ####---- ####----
   ######## -------- -----##- -------- ----#### ---##--- ####---- ####----
   -------- -------- -##-##-- -------- ----#### #####--- ####---- ####----
   -------- -------- -####--- ####---- -------- #####--- -------- ----####
   -------- ######## -###---- ####---- -------- -------- -------- ----####
   -------- ######## -##----- ####---- -------- -------- -------- ----####
   -------- ######## -------- ####---- -------- -------- -------- ----####

  Upper Case/Graphics:                Lower Case/Upper Case:

   Chars $00-$3F (0 - 63)              Chars $00-$3F (0 - 63)
   Chars $40-$7F (64 - 127)            Chars $40-$7F (64 - 127)
   Chars $80-$BF (128 - 191)           Chars $80-$BF (128 - 191)
   Chars $C0-$FF (192 - 255)           Chars $C0-$FF (192 - 255)


 Lower Case/Upper Case $80-$BF (128 - 191):

   $80/128  $81/129  $82/130  $83/131  $84/132  $85/133  $86/134  $87/135
   ##----## ######## ######## ######## ######## ######## ######## ########
   #--##--# ######## #--##### ######## #####--# ######## ####---# ########
   #--#---# ##----## #--##### ##----## #####--# ##----## ###--### ##-----#
   #--#---# #####--# #-----## #--##### ##-----# #--##--# ##-----# #--##--#
   #--##### ##-----# #--##--# #--##### #--##--# #------# ###--### #--##--#
   #--##--# #--##--# #--##--# #--##### #--##--# #--##### ###--### ##-----#
   ##----## ##-----# #-----## ##----## ##-----# ##----## ###--### #####--#
   ######## ######## ######## ######## ######## ######## ######## #-----##

   $88/136  $89/137  $8A/138  $8B/139  $8C/140  $8D/141  $8E/142  $8F/143
   ######## ######## ######## ######## ######## ######## ######## ########
   #--##### ###--### #####--# #--##### ##---### ######## ######## ########
   #--##### ######## ######## #--##### ###--### #--##--# #-----## ##----##
   #-----## ##---### #####--# #--#--## ###--### #------- #--##--# #--##--#
   #--##--# ###--### #####--# #----### ###--### #------- #--##--# #--##--#
   #--##--# ###--### #####--# #--#--## ###--### #--#-#-- #--##--# #--##--#
   #--##--# ##----## #####--# #--##--# ##----## #--###-- #--##--# ##----##
   ######## ######## ##----## ######## ######## ######## ######## ########

   $90/144  $91/145  $92/146  $93/147  $94/148  $95/149  $96/150  $97/151
   ######## ######## ######## ######## ######## ######## ######## ########
   ######## ######## ######## ######## ###--### ######## ######## ########
   #-----## ##-----# #-----## ##-----# #------# #--##--# #--##--# #--###--
   #--##--# #--##--# #--##--# #--##### ###--### #--##--# #--##--# #--#-#--
   #--##--# #--##--# #--##### ##----## ###--### #--##--# #--##--# #-------
   #-----## ##-----# #--##### #####--# ###--### #--##--# ##----## ##-----#
   #--##### #####--# #--##### #-----## ####---# ##-----# ###--### ##--#--#
   #--##### #####--# ######## ######## ######## ######## ######## ########

   $98/152  $99/153  $9A/154  $9B/155  $9C/156  $9D/157  $9E/158  $9F/159
   ######## ######## ######## ##----## ####--## ##----## ######## ########
   ######## ######## ######## ##--#### ###-##-# ####--## ###--### ###-####
   #--##--# #--##--# #------# ##--#### ##--#### ####--## ##----## ##--####
   ##----## #--##--# ####--## ##--#### #-----## ####--## #------# #-------
   ###--### #--##--# ###--### ##--#### ##--#### ####--## ###--### #-------
   ##----## ##-----# ##--#### ##--#### #--###-# ####--## ###--### ##--####
   #--##--# ####--## #------# ##----## ------## ##----## ###--### ###-####
   ######## #----### ######## ######## ######## ######## ###--### ########

   $A0/160  $A1/161  $A2/162  $A3/163  $A4/164  $A5/165  $A6/166  $A7/167
   ######## ###--### #--##--# #--##--# ###--### #--###-# ##----## #####--#
   ######## ###--### #--##--# #--##--# ##-----# #--##--# #--##--# ####--##
   ######## ###--### #--##--# -------- #--##### ####--## ##----## ###--###
   ######## ###--### ######## #--##--# ##----## ###--### ##---### ########
   ######## ######## ######## -------- #####--# ##--#### #--##--- ########
   ######## ######## ######## #--##--# #-----## #--##--# #--##--# ########
   ######## ###--### ######## #--##--# ###--### #-###--# ##------ ########
   ######## ######## ######## ######## ######## ######## ######## ########

   $A8/168  $A9/169  $AA/170  $AB/171  $AC/172  $AD/173  $AE/174  $AF/175
   ####--## ##--#### ######## ######## ######## ######## ######## ########
   ###--### ###--### #--##--# ###--### ######## ######## ######## ######--
   ##--#### ####--## ##----## ###--### ######## ######## ######## #####--#
   ##--#### ####--## -------- #------# ######## #------# ######## ####--##
   ##--#### ####--## ##----## ###--### ######## ######## ######## ###--###
   ###--### ###--### #--##--# ###--### ###--### ######## ###--### ##--####
   ####--## ##--#### ######## ######## ###--### ######## ###--### #--#####
   ######## ######## ######## ######## ##--#### ######## ######## ########

   $B0/176  $B1/177  $B2/178  $B3/179  $B4/180  $B5/181  $B6/182  $B7/183
   ##----## ###--### ##----## ##----## #####--# #------# ##----## #------#
   #--##--# ###--### #--##--# #--##--# ####---# #--##### #--##--# #--##--#
   #--#---# ##---### #####--# #####--# ###----# #-----## #--##### ####--##
   #---#--# ###--### ####--## ###---## #--##--# #####--# #-----## ###--###
   #--##--# ###--### ##--#### #####--# #------- #####--# #--##--# ###--###
   #--##--# ###--### #--##### #--##--# #####--# #--##--# #--##--# ###--###
   ##----## #------# #------# ##----## #####--# ##----## ##----## ###--###
   ######## ######## ######## ######## ######## ######## ######## ########

   $B8/184  $B9/185  $BA/186  $BB/187  $BC/188  $BD/189  $BE/190  $BF/191
   ##----## ##----## ######## ######## ####---# ######## #---#### ##----##
   #--##--# #--##--# ######## ######## ###--### ######## ###--### #--##--#
   #--##--# #--##--# ###--### ###--### ##--#### #------# ####--## #####--#
   ##----## ##-----# ######## ######## #--##### ######## #####--# ####--##
   #--##--# #####--# ######## ######## ##--#### #------# ####--## ###--###
   #--##--# #--##--# ###--### ###--### ###--### ######## ###--### ########
   ##----## ##----## ######## ###--### ####---# ######## #---#### ###--###
   ######## ######## ######## ##--#### ######## ######## ######## ########

  Upper Case/Graphics:                Lower Case/Upper Case:

   Chars $00-$3F (0 - 63)              Chars $00-$3F (0 - 63)
   Chars $40-$7F (64 - 127)            Chars $40-$7F (64 - 127)
   Chars $80-$BF (128 - 191)           Chars $80-$BF (128 - 191)
   Chars $C0-$FF (192 - 255)           Chars $C0-$FF (192 - 255)


 Lower Case/Upper Case $C0-$FF (192 - 255):

   $C0/192  $C1/193  $C2/194  $C3/195  $C4/196  $C5/197  $C6/198  $C7/199
   ######## ###--### #-----## ##----## #----### #------# #------# ##----##
   ######## ##----## #--##--# #--##--# #--#--## #--##### #--##### #--##--#
   ######## #--##--# #--##--# #--##### #--##--# #--##### #--##### #--#####
   -------- #------# #-----## #--##### #--##--# #----### #----### #--#---#
   -------- #--##--# #--##--# #--##### #--##--# #--##### #--##### #--##--#
   ######## #--##--# #--##--# #--##--# #--#--## #--##### #--##### #--##--#
   ######## #--##--# #-----## ##----## #----### #------# #--##### ##----##
   ######## ######## ######## ######## ######## ######## ######## ########

   $C8/200  $C9/201  $CA/202  $CB/203  $CC/204  $CD/205  $CE/206  $CF/207
   #--##--# ##----## ###----# #--##--# #--##### #--###-- #--##--# ##----##
   #--##--# ###--### ####--## #--#--## #--##### #---#--- #---#--# #--##--#
   #--##--# ###--### ####--## #----### #--##### #------- #------# #--##--#
   #------# ###--### ####--## #---#### #--##### #--#-#-- #------# #--##--#
   #--##--# ###--### ####--## #----### #--##### #--###-- #--#---# #--##--#
   #--##--# ###--### #--#--## #--#--## #--##### #--###-- #--##--# #--##--#
   #--##--# ##----## ##---### #--##--# #------# #--###-- #--##--# ##----##
   ######## ######## ######## ######## ######## ######## ######## ########

   $D0/208  $D1/209  $D2/210  $D3/211  $D4/212  $D5/213  $D6/214  $D7/215
   #-----## ##----## #-----## ##----## #------# #--##--# #--##--# #--###--
   #--##--# #--##--# #--##--# #--##--# ###--### #--##--# #--##--# #--###--
   #--##--# #--##--# #--##--# #--##### ###--### #--##--# #--##--# #--###--
   #-----## #--##--# #-----## ##----## ###--### #--##--# #--##--# #--#-#--
   #--##### #--##--# #----### #####--# ###--### #--##--# #--##--# #-------
   #--##### ##----## #--#--## #--##--# ###--### #--##--# ##----## #---#---
   #--##### ####---# #--##--# ##----## ###--### ##----## ###--### #--###--
   ######## ######## ######## ######## ######## ######## ######## ########

   $D8/216  $D9/217  $DA/218  $DB/219  $DC/220  $DD/221  $DE/222  $DF/223
   #--##--# #--##--# #------# ###--### --###### ###--### ##--##-- ##--##--
   #--##--# #--##--# #####--# ###--### --###### ###--### ##--##-- -##--##-
   ##----## #--##--# ####--## ###--### ##--#### ###--### --##--## --##--##
   ###--### ##----## ###--### -------- ##--#### ###--### --##--## #--##--#
   ##----## ###--### ##--#### -------- --###### ###--### ##--##-- ##--##--
   #--##--# ###--### #--##### ###--### --###### ###--### ##--##-- -##--##-
   #--##--# ###--### #------# ###--### ##--#### ###--### --##--## --##--##
   ######## ######## ######## ###--### ##--#### ###--### --##--## #--##--#

   $E0/224  $E1/225  $E2/226  $E3/227  $E4/228  $E5/229  $E6/230  $E7/231
   ######## ----#### ######## -------- ######## --###### --##--## ######--
   ######## ----#### ######## ######## ######## --###### --##--## ######--
   ######## ----#### ######## ######## ######## --###### ##--##-- ######--
   ######## ----#### ######## ######## ######## --###### ##--##-- ######--
   ######## ----#### -------- ######## ######## --###### --##--## ######--
   ######## ----#### -------- ######## ######## --###### --##--## ######--
   ######## ----#### -------- ######## ######## --###### ##--##-- ######--
   ######## ----#### -------- ######## -------- --###### ##--##-- ######--

   $E8/232  $E9/233  $EA/234  $EB/235  $EC/236  $ED/237  $EE/238  $EF/239
   ######## --##--## ######-- ###--### ######## ###--### ######## ########
   ######## -##--##- ######-- ###--### ######## ###--### ######## ########
   ######## ##--##-- ######-- ###--### ######## ###--### ######## ########
   ######## #--##--# ######-- ###----- ######## ###----- -----### ########
   --##--## --##--## ######-- ###----- ####---- ###----- -----### ########
   --##--## -##--##- ######-- ###--### ####---- ######## ###--### ########
   ##--##-- ##--##-- ######-- ###--### ####---- ######## ###--### --------
   ##--##-- #--##--# ######-- ###--### ####---- ######## ###--### --------

   $F0/240  $F1/241  $F2/242  $F3/243  $F4/244  $F5/245  $F6/246  $F7/247
   ######## ###--### ######## ###--### --###### ---##### #####--- --------
   ######## ###--### ######## ###--### --###### ---##### #####--- --------
   ######## ###--### ######## ###--### --###### ---##### #####--- ########
   ###----- -------- -------- -----### --###### ---##### #####--- ########
   ###----- -------- -------- -----### --###### ---##### #####--- ########
   ###--### ######## ###--### ###--### --###### ---##### #####--- ########
   ###--### ######## ###--### ###--### --###### ---##### #####--- ########
   ###--### ######## ###--### ###--### --###### ---##### #####--- ########

   $F8/248  $F9/249  $FA/250  $FB/251  $FC/252  $FD/253  $FE/254  $FF/255
   -------- ######## #######- ######## ####---- ###--### ----#### ----####
   -------- ######## ######-- ######## ####---- ###--### ----#### ----####
   -------- ######## #####--# ######## ####---- ###--### ----#### ----####
   ######## ######## #--#--## ######## ####---- -----### ----#### ----####
   ######## ######## #----### ----#### ######## -----### ######## ####----
   ######## -------- #---#### ----#### ######## ######## ######## ####----
   ######## -------- #--##### ----#### ######## ######## ######## ####----
   ######## -------- ######## ----#### ######## ######## ######## ####----

  Upper Case/Graphics:                Lower Case/Upper Case:

   Chars $00-$3F (0 - 63)              Chars $00-$3F (0 - 63)
   Chars $40-$7F (64 - 127)            Chars $40-$7F (64 - 127)
   Chars $80-$BF (128 - 191)           Chars $80-$BF (128 - 191)
   Chars $C0-$FF (192 - 255)           Chars $C0-$FF (192 - 255)


  +------------------------------------------------------------------------
  |
  |      SOUND INTERFACE DEVICE (SID) 6581
  |
  +------------------------------------------------------------------------
  |
  |  SID related topics:
  |
  |    ADR-Table
  |    SID-Mathmatics
  |
  |  Register description:
  |
  |   $D400/54272/SID+0       Voice 1: Frequency Control - Low-Byte
  |   $D401/54273/SID+1       Voice 1: Frequency Control - High-Byte
  |   $D402/54274/SID+2       Voice 1: Pulse Waveform Width - Low-Byte
  |   $D403/54275/SID+3       Voice 1: Pulse Waveform Width - High-Nybble
  |   $D404/54276/SID+4       Voice 1: Control Register
  |   $D405/54277/SID+5       Voice 1: Attack / Decay Cycle Control
  |   $D406/54278/SID+6       Voice 1: Sustain / Release Cycle Control
  |   $D407/54279/SID+7       Voice 2: Frequency Control - Low-Byte
  |   $D408/54280/SID+8       Voice 2: Frequency Control - High-Byte
  |   $D409/54281/SID+9       Voice 2: Pulse Waveform Width - Low-Byte
  |   $D40A/54282/SID+10      Voice 2: Pulse Waveform Width - High-Nybble
  |   $D40B/54283/SID+11      Voice 2: Control Register
  |   $D40C/54284/SID+12      Voice 2: Attack / Decay Cycle Control
  |   $D40D/54285/SID+13      Voice 2: Sustain / Release Cycle Control
  |   $D40E/54286/SID+14      Voice 3: Frequency Control - Low-Byte
  |   $D40F/54287/SID+15      Voice 3: Frequency Control - High-Byte
  |   $D410/54288/SID+16      Voice 3: Pulse Waveform Width - Low-Byte
  |   $D411/54289/SID+17      Voice 3: Pulse Waveform Width - High-Nybble
  |   $D412/54290/SID+18      Voice 3: Control Register
  |   $D413/54291/SID+19      Voice 3: Attack / Decay Cycle Control
  |   $D414/54292/SID+20      Voice 3: Sustain / Release Cycle Control
  |   $D415/54293/SID+21      Filter Cutoff Frequency: Low-Nybble
  |   $D416/54294/SID+22      Filter Cutoff Frequency: High-Byte
  |   $D417/54295/SID+23      Filter Resonance Control / Voice Input Control
  |   $D418/54296/SID+24      Select Filter Mode and Volume
  |   $D419/54297/SID+25      Analog/Digital Converter: Game Paddle 1
  |   $D41A/54298/SID+26      Analog/Digital Converter: Game Paddle 2
  |   $D41B/54299/SID+27      Oscillator 3 Output
  |   $D41C/54300/SID+28      Envelope Generator 3 Output
  |
  +------------------------------------------------------------------------



 $D400/54272/SID+0:   Voice 1: Frequency Control - Low-Byte

   This register is write-only!

   See also: SID-Maths


 $D401/54273/SID+1:   Voice 1: Frequency Control - High-Byte

   This register is write-only!

   See also: SID-Maths


 $D402/54274/SID+2:   Voice 1: Pulse Waveform Width - Low-Byte

   This register is write-only!

   See also: SID-Maths


 $D403/54275/SID+3:   Voice 1: Pulse Waveform Width - High-Nybble

   +----------+---------------------------------------------------+
   | Bits 7-4 |   Unused                                          |
   | Bits 3-0 |   Voice 1: Pulse Waveform Width - High-Nybble     |
   +----------+---------------------------------------------------+

   This register is write-only!

   See also: SID-Maths


 $D404/54276/SID+4:   Voice 1: Control Register

   +-------+------------------------------------------------------+
   | Bit 7 |   Select Random Noise Waveform, 1 = On               |
   | Bit 6 |   Select Pulse Waveform, 1 = On                      |
   | Bit 5 |   Select Sawtooth Waveform, 1 = On                   |
   | Bit 4 |   Select Triangle Waveform, 1 = On                   |
   | Bit 3 |   Test Bit: 1 = Disable Oscillator                   |
   | Bit 2 |   Ring Modulate Osc. 1 with Osc. 3 Output, 1 = On    |
   | Bit 1 |   Synchronize Osc. 1 with Osc. 3 Frequency, 1 = On   |
   | Bit 0 |   Gate Bit: 1 = Start Att/Dec/Sus, 0 = Start Release |
   +-------+------------------------------------------------------+

   This register is write-only!


 $D405/54277/SID+5:   Voice 1: Attack / Decay Cycle Control

   +----------+---------------------------------------------------+
   | Bits 7-4 |   Select Attack Cycle Duration: 0-15              |
   | Bits 3-0 |   Select Decay Cycle Duration: 0-15               |
   +----------+---------------------------------------------------+

   This register is write-only!

   See also: ADR-Rates


 $D406/54278/SID+6:   Voice 1: Sustain / Release Cycle Control

   +----------+---------------------------------------------------+
   | Bits 7-4 |   Select Sustain Cycle Duration: 0-15             |
   | Bits 3-0 |   Select Release Cycle Duration: 0-15             |
   +----------+---------------------------------------------------+

   This register is write-only!

   See also: ADR-Rates


 $D407/54279/SID+7:   Voice 2: Frequency Control - Low-Byte

   This register is write-only!

   See also: SID-Maths


 $D408/54280/SID+8:   Voice 2: Frequency Control - High-Byte

   This register is write-only!

   See also: SID-Maths


 $D409/54281/SID+9:   Voice 2: Pulse Waveform Width - Low-Byte

   This register is write-only!

   See also: SID-Maths


 $D40A/54282/SID+10:  Voice 2: Pulse Waveform Width - High-Nybble

   +----------+---------------------------------------------------+
   | Bits 7-4 |   Unused                                          |
   | Bits 3-0 |   Voice 2: Pulse Waveform Width - High-Nybble     |
   +----------+---------------------------------------------------+

   This register is write-only!

   See also: SID-Maths


 $D40B/54283/SID+11:  Voice 2: Control Register

   +-------+------------------------------------------------------+
   | Bit 7 |   Select Random Noise Waveform, 1 = On               |
   | Bit 6 |   Select Pulse Waveform, 1 = On                      |
   | Bit 5 |   Select Sawtooth Waveform, 1 = On                   |
   | Bit 4 |   Select Triangle Waveform, 1 = On                   |
   | Bit 3 |   Test Bit: 1 = Disable Oscillator                   |
   | Bit 2 |   Ring Modulate Osc. 2 with Osc. 1 Output, 1 = On    |
   | Bit 1 |   Synchronize Osc. 2 with Osc. 1 Frequency, 1 = On   |
   | Bit 0 |   Gate Bit: 1 = Start Att/Dec/Sus, 0 = Start Release |
   +-------+------------------------------------------------------+

   This register is write-only!


 $D40C/54284/SID+12:  Voice 2: Attack / Decay Cycle Control

   +----------+---------------------------------------------------+
   | Bits 7-4 |   Select Attack Cycle Duration: 0-15              |
   | Bits 3-0 |   Select Decay Cycle Duration: 0-15               |
   +----------+---------------------------------------------------+

   This register is write-only!

   See also: ADR-Rates


 $D40D/54285/SID+13:  Voice 2: Sustain / Release Cycle Control

   +----------+---------------------------------------------------+
   | Bits 7-4 |   Select Sustain Cycle Duration: 0-15             |
   | Bits 3-0 |   Select Release Cycle Duration: 0-15             |
   +----------+---------------------------------------------------+

   This register is write-only!

   See also: ADR-Rates


 $D40E/54286/SID+14:  Voice 3: Frequency Control - Low-Byte

   This register is write-only!

   See also: SID-Maths


 $D40F/54287/SID+15:  Voice 3: Frequency Control - High-Byte

   This register is write-only!

   See also: SID-Maths


 $D410/54288/SID+16:  Voice 3: Pulse Waveform Width - Low-Byte

   This register is write-only!

   See also: SID-Maths


 $D411/54289/SID+17:  Voice 3: Pulse Waveform Width - High-Nybble

   +----------+---------------------------------------------------+
   | Bits 7-4 |   Unused                                          |
   | Bits 3-0 |   Voice 3: Pulse Waveform Width - High-Nybble     |
   +----------+---------------------------------------------------+

   This register is write-only!

   See also: SID-Maths


 $D412/54290/SID+18:  Voice 3: Control Register

   +-------+------------------------------------------------------+
   | Bit 7 |   Select Random Noise Waveform, 1 = On               |
   | Bit 6 |   Select Pulse Waveform, 1 = On                      |
   | Bit 5 |   Select Sawtooth Waveform, 1 = On                   |
   | Bit 4 |   Select Triangle Waveform, 1 = On                   |
   | Bit 3 |   Test Bit: 1 = Disable Oscillator                   |
   | Bit 2 |   Ring Modulate Osc. 3 with Osc. 2 Output, 1 = On    |
   | Bit 1 |   Synchronize Osc. 3 with Osc. 2 Frequency, 1 = On   |
   | Bit 0 |   Gate Bit: 1 = Start Att/Dec/Sus, 0 = Start Release |
   +-------+------------------------------------------------------+

   This register is write-only!


 $D413/54291/SID+19:  Voice 3: Attack / Decay Cycle Control

   +----------+---------------------------------------------------+
   | Bits 7-4 |   Select Attack Cycle Duration: 0-15              |
   | Bits 3-0 |   Select Decay Cycle Duration: 0-15               |
   +----------+---------------------------------------------------+

   This register is write-only!

   See also: ADR-Rates


 $D414/54292/SID+20:  Voice 3: Sustain / Release Cycle Control

   +----------+---------------------------------------------------+
   | Bits 7-4 |   Select Sustain Cycle Duration: 0-15             |
   | Bits 3-0 |   Select Release Cycle Duration: 0-15             |
   +----------+---------------------------------------------------+

   This register is write-only!

   See also: ADR-Rates


 $D415/54293/SID+21:  Filter Cutoff Frequency: Low-Nybble

   +----------+---------------------------------------------------+
   | Bits 7-3 |   Unused                                          |
   | Bits 2-0 |   Filter Cutoff Frequency: Low-Nybble             |
   +----------+---------------------------------------------------+

   This register is write-only!


 $D416/54294/SID+22:  Filter Cutoff Frequency: High-Byte

   This register is write-only!


 $D417/54295/SID+23:  Filter Resonance Control / Voice Input Control

   +----------+---------------------------------------------------+
   | Bits 7-4 |   Select Filter Resonance: 0-15 (linear steps)    |
   | Bits 3   |   Filter External Input: 1 = Yes, 0 = No          |
   | Bits 2   |   Filter Voice 3 Output: 1 = Yes, 0 = No          |
   | Bits 1   |   Filter Voice 2 Output: 1 = Yes, 0 = No          |
   | Bits 0   |   Filter Voice 1 Output: 1 = Yes, 0 = No          |
   +----------+---------------------------------------------------+

   This register is write-only!


 $D418/54296/SID+24:  Select Filter Mode and Volume

   +----------+---------------------------------------------------+
   | Bits 7   |   Cut-Off Voice 3 Output: 1 = On, 0 = Off         |
   | Bits 6   |   Select Filter High-Pass Mode: 1 = On            |
   | Bits 5   |   Select Filter Band-Pass Mode: 1 = On            |
   | Bits 4   |   Select Filter Low-Pass Mode: 1 = On             |
   | Bits 3-0 |   Select Output Volume: 0-15 (linear steps)       |
   +----------+---------------------------------------------------+

   This register is write-only!

Kernal-Reference:

 STX $D418   : $FDC4


 $D419/54297/SID+25:  Analog/Digital Converter: Game Paddle 1

   This register is read-only!


 $D41A/54298/SID+26:  Analog/Digital Converter: Game Paddle 2

   This register is read-only!


 $D41B/54299/SID+27:  Oscillator 3 Output

   This register is read-only!


 $D41C/54300/SID+28:  Envelope Generator 3 Output

   This register is read-only!


 SID-ADR-Table:

     VALUE    ATTACK    DECAY/RELEASE
   +-------+----------+---------------+
   |   0   |    2 ms  |      6 ms     |
   |   1   |    8 ms  |     24 ms     |
   |   2   |   16 ms  |     48 ms     |
   |   3   |   24 ms  |     72 ms     |
   |   4   |   38 ms  |    114 ms     |
   |   5   |   56 ms  |    168 ms     |
   |   6   |   68 ms  |    204 ms     |
   |   7   |   80 ms  |    240 ms     |
   |   8   |  100 ms  |    300 ms     |
   |   9   |  240 ms  |    720 ms     |
   |   10  |  500 ms  |    1.5 s      |
   |   11  |  800 ms  |    2.4 s      |
   |   12  |    1 s   |      3 s      |
   |   13  |    3 s   |      9 s      |
   |   14  |    5 s   |     15 s      |
   |   15  |    8 s   |     24 s      |
   +-------+----------+---------------+

 This chart represents the 16 rates for ATTACK, DECAY and RELEASE.


 SID-Maths:

  Frequency:
  ----------

   To calculate the frequency corresponding to the 16-bit value in
   $D400+$D401, $D407+$D408, $D40E+$D40F use the following formula:

    Freq = 16Bit-Value * Phi2 / 16777216 Hz

   where Phi2 is the system-clock, 985248 Hz for PAL-systems,
   1022727 Hz for NTSC-systems.

   A good approximation for both systems is the formula:

    Freq = 16Bit-Value / 17.03

  Pulse-Width:
  ------------

   To calculate the pulse width (in %) corresponding to the 12-bit value in
   $D402+$D403, $D409+$D40A, $D410+$D411 use the following formula:

    PulseWidth = (16Bit-Value / 40.96) %


  +------------------------------------------------------------------------
  |
  |      COMPLEX INTERFACE ADAPTER (CIA) 6526
  |
  +------------------------------------------------------------------------
  |
  |  CIA related topics:
  |
  |   Keyboard Matrix
  |
  |  Register description:
  |
  |  CIA 1:
  |
  |   $DC00/56320/CIA1+0       Data Port A (Keyboard, Joystick, Paddles)
  |   $DC01/56321/CIA1+1       Data Port B (Keyboard, Joystick, Paddles)
  |   $DC02/56322/CIA1+2       Data Direction Register A
  |   $DC03/56323/CIA1+3       Data Direction Register B
  |   $DC04/56324/CIA1+4       Timer A Low-Byte  (Kernal-IRQ, Tape)
  |   $DC05/56325/CIA1+5       Timer A High-Byte (Kernal-IRQ, Tape)
  |   $DC06/56326/CIA1+6       Timer B Low-Byte  (Tape, Serial Port)
  |   $DC07/56327/CIA1+7       Timer B High-Byte (Tape, Serial Port)
  |   $DC08/56328/CIA1+8       Time-of-Day Clock: 1/10 Seconds
  |   $DC09/56329/CIA1+9       Time-of-Day Clock: Seconds
  |   $DC0A/56330/CIA1+10      Time-of-Day Clock: Minutes
  |   $DC0B/56331/CIA1+11      Time-of-Day Clock: Hours + AM/PM Flag
  |   $DC0C/56332/CIA1+12      Synchronous Serial I/O Data Buffer
  |   $DC0D/56333/CIA1+13      Interrupt (IRQ) Control Register
  |   $DC0E/56334/CIA1+14      Control Register A
  |   $DC0F/56335/CIA1+15      Control Register B
  |
  |  CIA 2:
  |
  |   $DD00/56576/CIA2+0       Data Port A (Serial Bus, RS232, VIC Base Mem.)
  |   $DD01/56577/CIA2+1       Data Port B (User Port, RS232)
  |   $DD02/56578/CIA2+2       Data Direction Register A
  |   $DD03/56579/CIA2+3       Data Direction Register B
  |   $DD04/56580/CIA2+4       Timer A Low-Byte  (RS232)
  |   $DD05/56581/CIA2+5       Timer A High-Byte (RS232)
  |   $DD06/56582/CIA2+6       Timer B Low-Byte  (RS232)
  |   $DD07/56583/CIA2+7       Timer B High-Byte (RS232)
  |   $DD08/56584/CIA2+8       Time-of-Day Clock: 1/10 Seconds
  |   $DD09/56585/CIA2+9       Time-of-Day Clock: Seconds
  |   $DD0A/56586/CIA2+10      Time-of-Day Clock: Minutes
  |   $DD0B/56587/CIA2+11      Time-of-Day Clock: Hours + AM/PM Flag
  |   $DD0C/56588/CIA2+12      Synchronous Serial I/O Data Buffer
  |   $DD0D/56589/CIA2+13      Interrupt (NMI) Control Register
  |   $DD0E/56590/CIA2+14      Control Register A
  |   $DD0F/56591/CIA2+15      Control Register B
  |
  +------------------------------------------------------------------------



 $DC00/56320/CIA1+0:   Data Port A (Keyboard, Joystick, Paddles)

   +----------+---------------------------------------------------+
   | Bits 7-0 |   Write Keyboard Column Values for Keyboard Scan  |
   | Bits 7-6 |   Paddles on: 01 = Port A, 10 = Port B            |
   | Bit  4   |   Joystick A Fire Button: 0 = Pressed             |
   | Bit  3   |   Joystick A Right: 0 = Pressed, or Paddle Button |
   | Bit  2   |   Joystick A Left : 0 = Pressed, or Paddle Button |
   | Bit  1   |   Joystick A Down : 0 = Pressed                   |
   | Bit  0   |   Joystick A Up   : 0 = Pressed                   |
   +----------+---------------------------------------------------+

   Do NOT use Paddles on both Ports at the same time!

   Joystick A is the one plugged into Port 2.

   Default Value: $7F/127 (%01111111)

Kernal-Reference:

 STA $DC00   : $E93A $E945 $EA90 $EAA5 $EAD7 $EB44 $F6D4 $FDAB
 STX $DC00   : $F6C9


 $DC01/56321/CIA1+1:   Data Port B (Keyboard, Joystick, Paddles)

   +----------+---------------------------------------------------+
   | Bits 7-0 |   Read Keyboard Row Values for Keyboard Scan      |
   | Bit  4   |   Joystick B Fire Button: 0 = Pressed             |
   | Bit  3   |   Joystick B Right: 0 = Pressed, or Paddle Button |
   | Bit  2   |   Joystick B Left : 0 = Pressed, or Paddle Button |
   | Bit  1   |   Joystick B Down : 0 = Pressed                   |
   | Bit  0   |   Joystick B Up   : 0 = Pressed                   |
   +----------+---------------------------------------------------+

   Joystick B is the one plugged into Port 1.

Kernal-Reference:

 CMP $DC01   : $EAAE $F6BF
 CPX $DC01   : $F6CF
 LDA $DC01   : $E93D $EAAB $F6BC
 LDX $DC01   : $EA93 $F6CC


 $DC02/56322/CIA1+2:   Data Direction Register A

   +----------+---------------------------------------------------+
   | Bit  x   |   1 = Pin PAx set to Output, 0 = Input            |
   +----------+---------------------------------------------------+

   Default Value: $FF/255 (%11111111)

Kernal-Reference:

 STX $DC02   : $FDC8


 $DC03/56323/CIA1+3:   Data Direction Register B

   +----------+---------------------------------------------------+
   | Bit  x   |   1 = Pin PBx set to Output, 0 = Input            |
   +----------+---------------------------------------------------+

    Default Value: $00/0 (%00000000)

Kernal-Reference:

 STX $DC03   : $FDBE


 $DC04/56324/CIA1+4:   Timer A Low-Byte (Kernal-IRQ, Tape)

   Read : Get current value
   Write: Set Low-Byte of value to count down from

   Default Value: $25/37 on PAL
                  $95/149 on NTSC

Kernal-Reference:

 STA $DC04   : $F907 $FDE4 $FDEE


 $DC05/56325/CIA1+5:   Timer A High-Byte (Kernal-IRQ, Tape)

   Read : Get current value
   Write: Set High-Byte of value to count down from

   Default Value: $40/64 on PAL
                  $42/66 on NTSC

Kernal-Reference:

 STA $DC05   : $F90E $FDF3


 $DC06/56326/CIA1+6:   Timer B Low-Byte (Tape, Serial Port)

   Read : Get current value

   Write: Set Low-Byte of value to count down from

Kernal-Reference:

 LDA $DC06   : $F8FE
 SBC $DC06   : $F932
 STA $DC06   : $FBB1
 STY $DC06   : $F93D


 $DC07/56327/CIA1+7:   Timer B High-Byte (Tape, Serial Port)

   Read : Get current value

   Write: Set High-Byte of value to count down from

Kernal-Reference:

 ADC $DC07   : $F90B
 CPX $DC07   : $F935
 LDX $DC07   : $F92C
 STA $DC07   : $ED94 $EE22
 STX $DC07   : $FBB4
 STY $DC07   : $F940


 $DC08/56328/CIA1+8:   Time-of-Day Clock: 1/10 Seconds

   +----------+---------------------------------------------------+
   | Bits 7-4 | Always 0                                          |
   | Bits 3-0 | 1/10 Seconds in BCD-Format                        |
   +----------+---------------------------------------------------+


 $DC09/56329/CIA1+9:   Time-of-Day Clock: Seconds

   +----------+---------------------------------------------------+
   | Bit  7   |   Always 0                                        |
   | Bits 6-4 |   10 Seconds in BCD-Format                        |
   | Bits 3-0 |    1 Seconds in BCD-Format                        |
   +----------+---------------------------------------------------+


 $DC0A/56330/CIA1+10:  Time-of-Day Clock: Minutes

   +----------+---------------------------------------------------+
   | Bit  7   |   Always 0                                        |
   | Bits 6-4 |   10 Minutes in BCD-Format                        |
   | Bits 3-0 |    1 Minutes in BCD-Format                        |
   +----------+---------------------------------------------------+


 $DC0B/56331/CIA1+11:  Time-of-Day Clock: Hours + AM/PM Flag

   +----------+---------------------------------------------------+
   | Bit  7   |   0 = AM / 1 = PM                                 |
   | Bit  6-5 |   Always 0                                        |
   | Bit  4   |   10 Hours in BCD-Format                          |
   | Bits 3-0 |    1 Hours in BCD-Format                          |
   +----------+---------------------------------------------------+


 $DC0C/56332/CIA1+12:  Synchronous Serial I/O Data Buffer

   Bits to be send or received via Pin SP are stored in this register.


 $DC0D/56333/CIA1+13:  Interrupt (IRQ) Control Register

   +-------+------------------------------------------------------+
   | Bit 7 |   On Read:  1 = Interrupt occured                    |
   |       |   On Write: 1 = Set Int.-Flags, 0 = Clear Int-.Flags |
   | Bit 4 |   FLAG1 IRQ (Cassette Read / Serial Bus SRQ Input)   |
   | Bit 3 |   Serial Port Interrupt ($DC0C full/empty)           |
   | Bit 2 |   Time-of-Day Clock Alarm Interrupt                  |
   | Bit 1 |   Timer B Interrupt (Tape, Serial Port)              |
   | Bit 0 |   Timer A Interrupt (Kernal-IRQ, Tape)               |
   +-------+------------------------------------------------------+

   Your CIA does NOT clear this register! You have to do this by
   simply reading it.

   Default Value: $81/129 (%10000001)

Kernal-Reference:

 LDA $DC0D   : $EA7E $ED9C $ED9F $EE2D $EE30 $F91A $F948 $FBB7
 LDX $DC0D   : $FB52
 STA $DC0D   : $F87A $FA3F $FA50 $FCA2 $FDA5 $FF70
 STX $DC0D   : $FB4F
 STY $DC0D   : $F877


 $DC0E/56334/CIA1+14:  Control Register A

   +-------+--------------------------------------------------------+
   | Bit 7 |   Time-of-Day Clock Frequency: 1 = 50 Hz, 0 = 60 Hz    |
   | Bit 6 |   Serial Port ($DC0C) I/O Mode: 1 = Output, 0 = Input  |
   | Bit 5 |   Timer A Counts: 1 = CNT Signals, 0 = System 02 Clock |
   | Bit 4 |   Force Load Timer A: 1 = Yes                          |
   | Bit 3 |   Timer A Run Mode: 1 = One-Shot, 0 = Continuous       |
   | Bit 2 |   Timer A Output Mode to PB6: 1 = Toggle, 0 = Pulse    |
   | Bit 1 |   Timer A Output on PB6: 1 = Yes, 0 = No               |
   | Bit 0 |   Start/Stop Timer A: 1 = Start, 0 = Stop              |
   +-------+--------------------------------------------------------+

   Default Value: $11/17 (%00010001)

Kernal-Reference:

 LDA $DC0E   : $F87D $FF73
 STA $DC0E   : $F914 $FDB0 $FF7A


 $DC0F/56335/CIA1+15:  Control Register B

   +----------+-----------------------------------------------------+
   | Bit  7   |   Set Alarm/TOD-Clock: 1 = Alarm, 0 = Clock         |
   | Bits 6-5 |   Timer B Mode Select:                              |
   |          |            00 = Count System 02 Clock Pulses        |
   |          |            01 = Count Positive CNT Transitions      |
   |          |            10 = Count Timer A Underflow Pulses      |
   |          |            11 = Count Timer A Underflows While CNT  |
   | Bit  4   |   Force Load Timer B: 1 = Yes                       |
   | Bit  3   |   Timer B Run Mode: 1 = One-Shot, 0 = Continuous    |
   | Bit  2   |   Timer B Output Mode to PB7: 1 = Toggle, 0 = Pulse |
   | Bit  1   |   Timer B Output on PB7: 1 = Yes, 0 = No            |
   | Bit  0   |   Start/Stop Timer B: 1 = Start, 0 = Stop           |
   +----------+-----------------------------------------------------+

   Default Value: $08/8 (%00001000)

Kernal-Reference:

 STA $DC0F   : $ED99 $EE27 $F882 $F945 $FBBC $FDB6


 $DD00/56576/CIA2+0:   Data Port A (Serial Bus, RS232, VIC Base Mem.)

   +----------+---------------------------------------------------+
   | Bit  7   |  Serial Bus Data Input                            |
   | Bit  6   |  Serial Bus Clock Pulse Input                     |
   | Bit  5   |  Serial Bus Data Output                           |
   | Bit  4   |  Serial Bus Clock Pulse Output                    |
   | Bit  3   |  Serial Bus ATN Signal Output                     |
   | Bit  2   |  RS232 Data Output (User Port)                    |
   | Bit  1-0 |  VIC Chip System Memory Bank Select (low active!) |
   +----------+---------------------------------------------------+

   Default Value: $17/23 (%00010111)

Kernal-Reference:

 CMP $DD00   : $ED69 $EE5D $EE6A $EEAC
 LDA $DD00   : $ED2E $ED66 $ED84 $EDBE $EDF3 $EE5A $EE67 $EE85 $EE8E $EE97
               $EEA0 $EEA9 $FE7B
 ORA $DD00   : $F492
 STA $DD00   : $ED33 $ED8B $EDC3 $EDF8 $EE8A $EE93 $EE9C $EEA5 $F495 $FDCD
               $FE82


 $DD01/56577/CIA2+1:   Data Port B (User Port, RS232)
   +-------+------------------------------------------------------+
   | Bit 7 |   User Port PB7 / RS232 Data Set Ready               |
   | Bit 6 |   User Port PB6 / RS232 Clear to Send                |
   | Bit 5 |   User Port PB5                                      |
   | Bit 4 |   User Port PB4 / RS232 Carrier Detect               |
   | Bit 3 |   User Port PB3 / RS232 Ring Indicator               |
   | Bit 2 |   User Port PB2 / RS232 Data Terminal Ready          |
   | Bit 1 |   User Port PB1 / RS232 Request to Send              |
   | Bit 0 |   User Port PB0 / RS232 Received Data                |
   +-------+------------------------------------------------------+

Kernal-Reference:

 BIT $DD01   : $EF0C $EFEB $EFF9 $F006 $F05B
 LDA $DD01   : $EFFE $F068 $F070 $F453 $FED6
 STA $DD01   : $F003 $F06D $F48D


 $DD02/56578/CIA2+2:   Data Direction Register A

   +----------+---------------------------------------------------+
   | Bit  x   |   1 = Pin PAx set to Output, 0 = Input            |
   +----------+---------------------------------------------------+

   Default Value: $3F/63 (%00111111)

Kernal-Reference:

 STA $DD02   : $FDD2


 $DD03/56579/CIA2+3:   Data Direction Register B

   +----------+---------------------------------------------------+
   | Bit  x   |   1 = Pin PBx set to Output, 0 = Input            |
   +----------+---------------------------------------------------+

   Default Value: $00/0 (%00000000)

Kernal-Reference:

 STA $DD03   : $F48A
 STX $DD03   : $FDC1


 $DD04/56580/CIA2+4:   Timer A Low-Byte (RS232)

   Read : Get current value

   Write: Set Low-Byte of value to count down from

Kernal-Reference:

 STA $DD04   : $F036


 $DD05/56581/CIA2+5:   Timer A High-Byte (RS232)

   Read : Get current value

   Write: Set High-Byte of value to count down from

Kernal-Reference:

 STA $DD05   : $F03C


 $DD06/56582/CIA2+6:   Timer B Low-Byte (RS232)

   Read : Get current value

   Write: Set Low-Byte of value to count down from

Kernal-Reference:

 LDA $DD06   : $FEDD
 STA $DD06   : $FEE5 $FEFE $FF0A $FF22


 $DD07/56583/CIA2+7:   Timer B High-Byte (RS232)

   Read : Get current value

   Write: Set High-Byte of value to count down from

Kernal-Reference:

 LDA $DD07   : $FEE8
 STA $DD07   : $FEEE $FF01 $FF10 $FF25


 $DD08/56584/CIA2+8:   Time-of-Day Clock: 1/10 Seconds

   +----------+---------------------------------------------------+
   | Bits 7-4 | Always 0                                          |
   | Bits 3-0 | 1/10 Seconds in BCD-Format                        |
   +----------+---------------------------------------------------+


 $DD09/56585/CIA2+9:   Time-of-Day Clock: Seconds

   +----------+---------------------------------------------------+
   | Bit  7   |   Always 0                                        |
   | Bits 6-4 |   10 Seconds in BCD-Format                        |
   | Bits 3-0 |    1 Seconds in BCD-Format                        |
   +----------+---------------------------------------------------+


 $DD0A/56586/CIA2+10:  Time-of-Day Clock: Minutes

   +----------+---------------------------------------------------+
   | Bit  7   |   Always 0                                        |
   | Bits 6-4 |   10 Minutes in BCD-Format                        |
   | Bits 3-0 |    1 Minutes in BCD-Format                        |
   +----------+---------------------------------------------------+


 $DD0B/56587/CIA2+11:  Time-of-Day Clock: Hours + AM/PM Flag

   +----------+---------------------------------------------------+
   | Bit  7   |   0 = AM / 1 = PM                                 |
   | Bit  6-5 |   Always 0                                        |
   | Bit  4   |   10 Hours in BCD-Format                          |
   | Bits 3-0 |    1 Hours in BCD-Format                          |
   +----------+---------------------------------------------------+


 $DD0C/56588/CIA2+12:  Synchronous Serial I/O Data Buffer

   Bits to be send or received via Pin SP are stored in this register.


 $DD0D/56589/CIA2+13:  Interrupt (NMI) Control Register

   +-------+------------------------------------------------------+
   | Bit 7 |   On Read:  1 = Interrupt occured                    |
   |       |   On Write: 1 = Set Int.-Flags, 0 = Clear Int.-Flags |
   | Bit 4 |   FLAG1 NMI (User/RS232 Received Data Input)         |
   | Bit 3 |   Serial Port Interrupt ($DD0C full/empty)           |
   | Bit 2 |   Time-of-Day Clock Alarm Interrupt                  |
   | Bit 1 |   Timer B Interrupt (RS232)                          |
   | Bit 0 |   Timer A Interrupt (RS232)                          |
   +-------+------------------------------------------------------+

   Your CIA does NOT clear this register! You have to do this by
   simply reading it.

   Default Value: $7F/127 (%01111111)

Kernal-Reference:

 LDY $DD0D   : $FE51
 STA $DD0D   : $EF3B $EF46 $EF80 $F0B3 $F485 $FDA8 $FE4E $FE88 $FEB9 $FEF9


 $DD0E/56590/CIA2+14:  Control Register A

   +-------+--------------------------------------------------------+
   | Bit 7 |   Time-of-Day Clock Frequency: 1 = 50 Hz, 0 = 60 Hz    |
   | Bit 6 |   Serial Port ($DD0C) I/O Mode: 1 = Output, 0 = Input  |
   | Bit 5 |   Timer A Counts: 1 = CNT Signals, 0 = System 02 Clock |
   | Bit 4 |   Force Load Timer A: 1 = Yes                          |
   | Bit 3 |   Timer A Run Mode: 1 = One-Shot, 0 = Continuous       |
   | Bit 2 |   Timer A Output Mode to PB6: 1 = Toggle, 0 = Pulse    |
   | Bit 1 |   Timer A Output on PB6: 1 = Yes, 0 = No               |
   | Bit 0 |   Start/Stop Timer A: 1 = Start, 0 = Stop              |
   +-------+--------------------------------------------------------+

   Default Value: $08/8 (%00001000)

Kernal-Reference:

 STA $DD0E   : $F030 $F049 $FDB3


 $DD0F/56591/CIA2+15:  Control Register B

   +----------+-----------------------------------------------------+
   | Bit  7   |   Set Alarm/TOD-Clock: 1 = Alarm, 0 = Clock         |
   | Bits 6-5 |   Timer B Mode Select:                              |
   |          |            00 = Count System 02 Clock Pulses        |
   |          |            01 = Count Positive CNT Transitions      |
   |          |            10 = Count Timer A Underflow Pulses      |
   |          |            11 = Count Timer A Underflows While CNT  |
   | Bit  4   |   Force Load Timer B: 1 = Yes                       |
   | Bit  3   |   Timer B Run Mode: 1 = One-Shot, 0 = Continuous    |
   | Bit  2   |   Timer B Output Mode to PB7: 1 = Toggle, 0 = Pulse |
   | Bit  1   |   Timer B Output on PB7: 1 = Yes, 0 = No            |
   | Bit  0   |   Start/Stop Timer B: 1 = Start, 0 = Stop           |
   +----------+-----------------------------------------------------+

   Default Value: $08/8 (%00001000)

Kernal-Reference:

 STA $DD0F   : $FDB9 $FEF3 $FF15


                               Port B - $DC01
              +-----+-----+-----+-----+-----+-----+-----+-----+
              |Bit 7|Bit 6|Bit 5|Bit 4|Bit 3|Bit 2|Bit 1|Bit 0|
        +-----+-----+-----+-----+-----+-----+-----+-----+-----+
        |Bit 7| R/S |  Q  |  C= |SPACE|  2  | CTRL|A_LFT|  1  |
        +-----+-----+-----+-----+-----+-----+-----+-----+-----+
        |Bit 6|  /  | A_UP|  =  | S_R | HOME|  ;  |  *  |POUND|
        +-----+-----+-----+-----+-----+-----+-----+-----+-----+
        |Bit 5|  ,  |  @  |  :  |  .  |  -  |  L  |  P  |  +  |
        +-----+-----+-----+-----+-----+-----+-----+-----+-----+
        |Bit 4|  N  |  O  |  K  |  M  |  0  |  J  |  I  |  9  |
 Port A +-----+-----+-----+-----+-----+-----+-----+-----+-----+
 $DC00  |Bit 3|  V  |  U  |  H  |  B  |  8  |  G  |  Y  |  7  |
        +-----+-----+-----+-----+-----+-----+-----+-----+-----+
        |Bit 2|  X  |  T  |  F  |  C  |  6  |  D  |  R  |  5  |
        +-----+-----+-----+-----+-----+-----+-----+-----+-----+
        |Bit 1| S_L |  E  |  S  |  Z  |  4  |  A  |  W  |  3  |
        +-----+-----+-----+-----+-----+-----+-----+-----+-----+
        |Bit 0|C_U/D|  F5 |  F3 |  F1 |  F7 |C_L/R|  CR | DEL |
        +-----+-----+-----+-----+-----+-----+-----+-----+-----+

  C_L/R = Cursor left/right  ;  C_U/D = Cursor up/down
  S_L = Shift, left  ;  S_R = Shift, right  ;  R/S = RUN/STOP
  A_UP = Arrow up    ;  A_LFT = Arrow left

 C128 only:
                               Port B - $DC01
              +-----+-----+-----+-----+-----+-----+-----+-----+
              |Bit 7|Bit 6|Bit 5|Bit 4|Bit 3|Bit 2|Bit 1|Bit 0|
        +-----+-----+-----+-----+-----+-----+-----+-----+-----+
        |Bit 2|NOSCR| 'R' | 'L' | 'D' | 'U' | "." | "0" | ALT |
 Port A*+-----+-----+-----+-----+-----+-----+-----+-----+-----+
 $D02F  |Bit 1| "3" | "9" | "6" | "CR"|  LF | "-" | "+" | ESC |
        +-----+-----+-----+-----+-----+-----+-----+-----+-----+
        |Bit 0| "1" | "7" | "4" | "2" | TAB | "5" | "8" | HELP|
        +-----+-----+-----+-----+-----+-----+-----+-----+-----+

  "x" = means key is on the keypad to the right
  'x' = means grey cursor-control key at the upper side
        (U/D/L/R = up/down/left/right)


  +------------------------------------------------------------------------
  |
  |      MEMORY-MAPS OF DIFFERENT PROGRAMS
  |
  +------------------------------------------------------------------------
  |
  |   pucrunch                       Jiffy-DOS (Zeropage)
  |   ByteBoiler 1.0
  |   The Cruncher AB 2.0
  |   Exomizer
  |
  +------------------------------------------------------------------------



 PUCRUNCH:

  A freeware cross-cruncher by Pasi 'Albert' Ojala.
  [http://www.cs.tut.fi/~albert/Dev/pucrunch]

  Used memory:

   $2D+$2E: Temporary (LZPOS), after depacking: End of Program
   $F7+$F8: Bit-Stream, Escape Code
   $F9+$FA: Depacker - Part 1 ($FA = destination address lo)
   $FB-$FE: Depacker - Part 1 ($FB = destination address hi)
   $FF: Depacker - Part 1
   $0100-$01E0: Depacker - Part 1
   $0200-$0258: Depacker - Part 2 ($0202+$0203 = source address)


 EXOMIZER 1.0 - 2.0:

 An open-source cross-cruncher by Magnus Lind.
 [http://covertbitops.cjb.net]

  Except for the addresses covered by the file itself ($0801-$XXXX), the
  default decruncher also clobbers the following addresses:

   $A7    : Length of sequence
   $AE+$AF: Source address
   $FB-$FE: Bit buffers, Destination address lo ($FE)
   $FF    : Destination address hi
   $0100-$01BA: Depacker - main code (for V1.1.1+ see below!)
   $0334-$033B: Depacker - tables
   $033C-$03CF: Depacker - tables

 EXOMIZER 2.0:

  The decruncher uses the same ZP-addresses, buffers and stack space like
  the previous version. As it assembles the decruncher on the fly, it is
  too hard to precisely predict all cases where further memory areas are
  clobbered. It should be at least similar to version 1.1.5, though.

 EXOMIZER 1.1.1 - 1.1.5:

  The decruncher clobbers the stack from $0100 to the stackpointer by copying
  186 bytes of itself (and possibly some more) to the stack at $0100-$01xx.

  If the start address of the decrunched data, [start], is lower than $0835
  then the decruncher will clobber the memory from MIN([start] - 25, $07e7)
  to but not including $081d, too. This space is used as a safety buffer.

  If selected, the address $07e7 will be overwritten in order to make the
  decrunch effect visible. This address is the lower right corner of the
  screen.

 EXOMIZER 1.1:

  If the start address of the decrunched data is lower than $0826 then the
  decruncher will clobber the memory from [(the start address) - $30] to
  $0801. This space is used as a safety buffer.

  In all cases the address $07E7 will be overwritten in order to make the
  decrunch effect visible. This address is the lower right corner of the
  screen.

 EXOMIZER 1.0:

  If the start adress of the decrunched data is lower than $0817 then the
  decruncher will clobber the memory from [(the start adress) - $30] to
  $0801. This space is used as a safety buffer.

  If the start adress of the decrunched data is between $0817 and $084D
  then the decruncher will clobber the memory from $07E7 to $0801. This
  space is used as a safety buffer.


 JIFFY-DOS:

  A kernal replacement providing better disk-access by CMD.

  Used Zeropage:

   $26: ALLFLAG/RSIZE
   $27: COMSAV
   $9B: KEYBYT
   $9F: CJLA
   $A3: LDFLG/QFLAG
   $A6: TFLAG
   $B0+$B1: KEYPTR
   $B0: SPRSAV
   $B1: RASSAV
   $B2: REGSAV
   $BE: DRVBYT
   $BF: DEST


 BYTE-BOILER 1.0:

  A cruncher by Skyflash and Zizyphus of Oneway.

  Used memory:

   $A3: Temporary
   $A4: Temporary
   $C3+$C4: Temporary
   $F0-$F2: Depacker
   $F3-$F4: Depacker
   $F5-$F6: Depacker
   $F7-$F8: Depacker
   $F9-$FA: Depacker
   $FB-$FE: Depacker
   $FF: Depacker
   $0100-$01EF: Depacker
   $071E-Start of data: Tables


 The Cruncher AB 2.0:

  A level-cruncher by Skyflash and Zizyphus of Oneway.
  Very similar to ByteBoiler.

  Used zeropage:

   $FB-$FE: Temporary
   $FF: Temporary


 Memory Configuration


  The signals /CharEn, /HiRam and /LoRam are used to select the memory
  configuration. They can be set using the processor port $01. The following
  logic applies (if expression on the right side is true, area mentioned on
  the left side will be activated. Otherwise, there is RAM):

    Kernal ROM = (/HiRam)

    Basic ROM  = (/LoRam AND /HiRam)

      That means, you cannot switch in Basic when the Kernal is off. Please
      note also, that an EPROM starting at $8000 will be disabled when you
      switch off the Basic ROM.

    Char. ROM  = ((NOT (/CharEn)) AND (/LoRam OR /HiRam))

    I/O-Area   = (/CharEn AND (/LoRam OR /HiRam))

      These two areas can just be activated, if at least one other signal is
      high. Then /CharEn selects either Char. ROM or I/O-Area.

  As a result, we get the following possibilities for the corresponding
  bits of $01:


       Bit+-------------+-----------+------------+
       210| $8000-$BFFF |$D000-$DFFF|$E000-$FFFF |
  +---+---+-------------+-----------+------------+
  | 7 |111| Cart.+Basic |    I/O    | Kernal ROM |
  +---+---+-------------+-----------+------------+
  | 6 |110|     RAM     |    I/O    | Kernal ROM |
  +---+---+-------------+-----------+------------+
  | 5 |101|     RAM     |    I/O    |    RAM     |
  +---+---+-------------+-----------+------------+
  | 4 |100|     RAM     |    RAM    |    RAM     |
  +---+---+-------------+-----------+------------+
  | 3 |011| Cart.+Basic | Char. ROM | Kernal ROM |
  +---+---+-------------+-----------+------------+
  | 2 |010|     RAM     | Char. ROM | Kernal ROM |
  +---+---+-------------+-----------+------------+
  | 1 |001|     RAM     | Char. ROM |    RAM     |
  +---+---+-------------+-----------+------------+
  | 0 |000|     RAM     |    RAM    |    RAM     |
  +---+---+-------------+-----------+------------+
       |||
 /CharEn|/LoRam
        |
      /HiRam


  +------------------------------------------------------------------------
  |
  |      ZEROPAGE AND EXTENDED ZEROPAGE - DESCRIPTIONS
  |
  +------------------------------------------------------------------------
  |
  | Zeropage:
  |
  |   $00/0                   6510 On-chip Data Direction Register
  |   $01/1                   6510 On-chip 8-bit Input/Output Register
  |   $02/2                   Unused
  |   $03-$04/3-4             Jump Vector: Convert FAC to Integer
  |   $05-$06/5-6             Jump Vector: Convert Integer to Floating point
  |   $07/7                   Search Character/Temporary Integer during INT
  |   $08/8                   Flag: Scan for Quote at end of String
  |   $07-$08/7-8             Temporary Integer during OR/AND
  |   $09/9                   Screen Column for last TAB
  |   $0A/10                  Load/Verify-Flag
  |   $0B/11                  Input Buffer Pointer/Number of Subscripts
  |   $0C/12                  Flag: Default Array dimension
  |   $0D/13                  Data type Flag
  |   $0E/14                  Data type Flag
  |   $0F/15                  Flag: DATA scan/List Quote/Garbage collection
  |   $10/16                  Flag: Subscript reference/User Function call
  |   $11/17                  Input Flag
  |   $12/18                  Flag: TAN sign/Comparative result
  |   $13/19                  File number of current Input Device
  |   $14-$15/20-21           Temporary: Integer value
  |   $16/22                  Pointer: Temporary String Stack
  |   $17-$18/23-24           Last temporary String Address
  |   $19-$21/25-33           Stack for temporary Strings
  |   $22-$25/34-37           Utility Pointer Area
  |   $22-$23/34-35           First Utility Pointer
  |   $24-$25/36-37           Second Utility Pointer
  |   $26-$2A/38-42           Floating point product of Multiply and Divide
  |   $2B-$2C/43-44           Pointer: Start of BASIC Text Area
  |   $2D-$2E/45-46           Pointer: Start of BASIC Variables
  |   $2F-$30/47-48           Pointer: Start of BASIC Arrays
  |   $31-$32/49-50           Pointer: End of BASIC Arrays + 1
  |   $33-$34/51-52           Pointer: Bottom of String space
  |   $35-$36/53-54           Utility String Pointer
  |   $37-$38/55-56           Pointer: Highest Address available to BASIC
  |   $39-$3A/57-58           Current BASIC Line number
  |   $3B-$3C/59-60           Previous BASIC Line number
  |   $3D-$3E/61-62           Pointer: BASIC Statement for CONT
  |   $3F-$40/63-64           Current DATA Line number
  |   $41-$42/65-66           Pointer: Used by READ - current DATA Item
  |   $43-$44/67-68           Pointer: Temporary storage during INPUT
  |   $45-$46/69-70           Name of Variable being sought in Variable Table
  |   $47-$48/71-72           Value/Descriptor-Pointer
  |   $49-$4A/73-74           Pointer: Index Variable for FOR/NEXT loop
  |   $4B-$4C/75-76           Temporary storage for TXTPTR
  |   $4D/77                  Mask used during FRMEVL
  |   $4E-$52/78-82           Temporary storage for FLPT value
  |   $53/83                  Length of String during Garbage collection
  |   $54-$56/84-86           Jump Vector used in Function Evaluation
  |   $57-$5B/87-91           Temporary storage for FLPT value
  |   $5C-$60/92-96           Temporary storage for FLPT value
  |   $61-$66/97-102          Main Floating point Accumulator
  |   $61/97                  FAC Exponent
  |   $62-$65/98-101          FAC Mantissa
  |   $66/102                 FAC Sign
  |   $67/103                 Pointer: Series Evaluation Constant
  |   $68/104                 Bit Overflow Area during normalisation Routine
  |   $69-$6E/105-110         Auxiliary Floating point Accumulator
  |   $69/105                 AFAC Exponent
  |   $6A-$6D/106-109         AFAC Mantissa
  |   $6E/110                 AFAC Sign
  |   $6F/111                 Sign of result of Arithmetic Evaluation
  |   $70/112                 FAC low-order rounding
  |   $71-$72/113-114         Pointer: Used during CRUNCH/ASCII conversion
  |   $73-$78/115-120         CHRGET: Get next Byte of BASIC Text
  |   $79-$8A/121-138         CHRGOT: Get same Byte again
  |   $7A-$7B/122-123         Pointer: Current Byte of BASIC Text
  |   $8B-$8F/139-143         Floating RND Function Seed Value
  |   $90/144                 Kernal I/O Status Word ST
  |   $91/145                 Flag: $7F = STOP key
  |   $92/146                 Timing Constant for Tape
  |   $93/147                 Flag: 0 = Load, 1 = Verify
  |   $94/148                 Flag: Serial Bus - Output Character buffered
  |   $95/149                 Buffered Character for Serial Bus
  |   $96/150                 Cassette Sync number
  |   $97/151                 Storage of X Register during CHRIN
  |   $97/151                 Storage of Y Register during RS232 fetch
  |   $98/152                 Number of Open Files/Index to File Table
  |   $99/153                 Default Input Device (0)
  |   $9A/154                 Default Output Device (3)
  |   $9B/155                 Parity of Byte Output to Tape
  |   $9C/156                 Flag: Byte received from Tape
  |   $9D/157                 Error-Mode-Flag
  |   $9E/158                 Index to Tape File name/Header ID for Tape write
  |   $9E/158                 Tape Error log pass 1
  |   $9F/159                 Tape Error log pass 2
  |   $A0-$A2/160-162         Real-time jiffy Clock
  |   $A3/163                 Bit Counter Tape Read or Write
  |   $A3/163                 Serial Bus EOI (End Of Input) Flag
  |   $A4/164                 Pulse Counter Tape Read or Write
  |   $A4/164                 Serial Bus shift Counter
  |   $A5/165                 Tape Synchronising count down
  |   $A6/166                 Pointer: Tape I/O buffer
  |   $A7/167                 RS232 temporary for received Bit
  |   $A7/167                 Tape temporary
  |   $A8/168                 RS232 Input Bit count/Tape temporary
  |   $A9/169                 RS232 Flag: Start Bit check/Tape temporary
  |   $AA/170                 RS232 Input Byte Buffer/Tape temporary
  |   $AB/171                 RS232 Input parity/Tape temporary
  |   $AC-$AD/172-173         Pointer: Tape Buffer/Screen scrolling
  |   $AE-$AF/174-175         Tape End Address/End of Program
  |   $B0-$B1/176-177         Tape timing Constants
  |   $B2-$B3/178-179         Pointer: Start Address of Tape Buffer
  |   $B4/180                 RS232 Write bit count/Tape Read timing Flag
  |   $B5/181                 RS232 Next Bit to send/Tape Read - End of Tape
  |   $B6/182                 RS232 Output Byte Buffer/Tape Read Error Flag
  |   $B7/183                 Number of Characters in Filename
  |   $B8/184                 Current File - Logical File number
  |   $B9/185                 Current File - Secondary Address
  |   $BA/186                 Current File - First Address (Device number)
  |   $BB-$BC/187-188         Pointer: Current File name Address
  |   $BD/189                 RS232 Output Parity/Tape Byte temporary
  |   $BE/190                 Tape Input/Output Block count
  |   $BF/191                 Serial Word Buffer
  |   $C0/192                 Tape Motor Switch
  |   $C1-$C2/193-194         Start Address for LOAD and Cassette Write
  |   $C3-$C4/195-196         Pointer: Type 3 Tape LOAD and general use
  |   $C5/197                 Matrix value of last Key pressed
  |   $C6/198                 Number of Characters in Keyboard Buffer queue
  |   $C7/199                 Flag: Reverse On/Off
  |   $C8/200                 Pointer: End of Line for Input
  |   $C9-$CA/201-202         Cursor X/Y position at start of Input
  |   $CB/203                 Matrix value of last Key pressed
  |   $CC/204                 Flag: Cursor blink
  |   $CD/205                 Timer: Count down for Cursor blink toggle
  |   $CE/206                 Character under Cursor while Cursor Inverted
  |   $CF/207                 Flag: Cursor Status
  |   $D0/208                 Flag: Input from ...
  |   $D1-$D2/209-210         Pointer: Current Screen Line Address
  |   $D3/211                 Cursor Column on current Line
  |   $D4/212                 Flag: Editor in Quote Mode
  |   $D5/213                 Current logical Line length: 39 or 79
  |   $D6/214                 Current Screen Line number of Cursor
  |   $D7/215                 Current Input Character/Last Character Output
  |   $D8/216                 Count of number of inserts outstanding
  |   $D9-$F2/217-242         Screen Line Link Table
  |   $F3-$F4/243-244         Pointer: Current Color RAM Location
  |   $F5-$F6/245-246         Vector: Current Keyboard decoding Table
  |   $F7-$F8/247-248         RS232 Input Buffer Pointer
  |   $F9-$FA/249-250         RS232 Output Buffer Pointer
  |   $FB-$FE/251-254         Free ZeroPage space for User Programs
  |   $FF/255                 BASIC temporary Data Area
  |   $FF-$010A/255-266       Assembly Area for Floating point to ASCII
  |
  | Extended Zeropage:
  |
  |   $0100-$013E/256-318     Tape Input Error log
  |   $0100-$01FF/256-511     6510 Hardware Stack Area
  |   $013F-$01FF/319-511     BASIC Stack Area
  |   $0200-$0258/512-600     BASIC Input Buffer (Input Line from Screen)
  |   $0259-$0262/601-610     Active logical File numbers
  |   $0263-$026C/611-620     Active File First Addresses (Device numbers)
  |   $026D-$0276/621-630     Active File Secondary Addresses
  |   $0277-$0280/631-640     Keyboard Buffer Queue (FIFO)
  |   $0281-$0282/641-642     Pointer: Bottom of Memory for Operating System
  |   $0283-$0284/643-644     Pointer: Top of Memory for Operating System
  |   $0285/645               Serial IEEE Bus timeout defeat Flag
  |   $0286/646               Current Character Color code
  |   $0287/647               Background Color under Cursor
  |   $0288/648               High Byte of Screen Memory Address
  |   $0289/649               Maximum number of Bytes in Keyboard Buffer
  |   $028A/650               Flag: Repeat keys
  |   $028B/651               Repeat Key: Speed Counter
  |   $028C/652               Repeat Key: First repeat delay Counter
  |   $028D/653               Flag: Shift Keys
  |   $028E/654               Last Shift Key used for debouncing
  |   $028F-$0290/655-656     Vector: Routine to determine Keyboard table
  |   $0291/657               Flag: Upper/Lower Case change
  |   $0292/658               Flag: Auto scroll down
  |   $0293/659               RS232 Pseudo 6551 control Register Image
  |   $0294/660               RS232 Pseudo 6551 command Register Image
  |   $0295-$0296/661-662     RS232 Non-standard Bits/Second
  |   $0297/663               RS232 Pseudo 6551 Status Register Image
  |   $0298/664               RS232 Number of Bits left to send
  |   $0299-$029A/665-666     RS232 Baud Rate; Full Bit time microseconds
  |   $029B/667               RS232 Index to End of Input Buffer
  |   $029C/668               RS232 Pointer: High Byte of Input Buffer
  |   $029D/669               RS232 Pointer: High Byte of Output Buffer
  |   $029E/670               RS232 Index to End of Output Buffer
  |   $029F-$02A0/671-672     Temp. store for IRQ Vector during Tape I/O
  |   $02A1/673               RS232 Enables
  |   $02A2/674               TOD sense during Tape I/O
  |   $02A3/675               Temporary storage during Tape READ
  |   $02A4/676               Temporary D1IRQ Indicator during Tape READ
  |   $02A5/677               Temporary for Line Index
  |   $02A6/678               Flag: TV Standard
  |   $02A7-$02FF/679-767     Unused
  |   $02C0-$02FE/704-766     Sprite #11 Data Area
  |   $0300-$0301/768-769     Vector: BASIC Error Message
  |   $0302-$0303/770-771     Vector: BASIC Input Line and Decode
  |   $0304-$0305/772-773     Vector: BASIC Tokenise Routine
  |   $0306-$0307/774-775     Vector: BASIC LIST Routine
  |   $0308-$0309/776-777     Vector: BASIC Character dispatch Routine
  |   $030A-$030B/778-779     Vector: BASIC Token evaluation
  |   $030C/780               Storage for 6510 Accumulator during SYS
  |   $030D/781               Storage for 6510 X-Register during SYS
  |   $030E/782               Storage for 6510 Y-Register during SYS
  |   $030F/783               Storage for 6510 Status Register during SYS
  |   $0310/784               USR Function JMP Instruction
  |   $0311-$0312/785-786     USR Address
  |   $0313/787               Unused
  |   $0314-$0315/788-789     Vector: Hardware IRQ Interrupt Address
  |   $0316-$0317/790-791     Vector: BRK Instruction Interrupt Address
  |   $0318-$0319/792-793     Vector: Hardware NMI Interrupt Address
  |   $031A-$031B/794-795     Vector: Kernal OPEN Routine
  |   $031C-$031D/796-797     Vector: Kernal CLOSE Routine
  |   $031E-$031F/798-799     Vector: Kernal CHKIN Routine
  |   $0320-$0321/800-801     Vector: Kernal CHKOUT Routine
  |   $0322-$0323/802-803     Vector: Kernal CLRCHN Routine
  |   $0324-$0325/804-805     Vector: Kernal CHRIN Routine
  |   $0326-$0327/806-807     Vector: Kernal CHROUT Routine
  |   $0328-$0329/808-809     Vector: Kernal STOP Routine
  |   $032A-$032B/810-811     Vector: Kernal GETIN Routine
  |   $032C-$032D/812-813     Vector: Kernal CLALL Routine
  |   $032E-$032F/814-815     User Defined Vector
  |   $0330-$0331/816-817     Vector: Kernal LOAD Routine
  |   $0332-$0333/818-819     Vector: Kernal SAVE Routine
  |   $0334-$033B/820-827     Unused
  |   $033C-$03FB/828-1019    Tape I/O Buffer
  |   $0340-$037E/832-894     Sprite #13
  |   $0380-$03BE/896-958     Sprite #14
  |   $03C0-$03FE/960-1022    Sprite #15
  |   $03FC-$03FF/1020-1023   Unused
  |
  +------------------------------------------------------------------------



  $00/0:   6510 On-chip Data Direction Register

   +----------+---------------------------------------------------+
   | Bit  7   |   Undefined                                       |
   | Bit  6   |   Only available on C128, otherwise undefined     |
   | Bits 0-5 |   1 = Output, 0 = Input (see $01 for description) |
   +----------+---------------------------------------------------+
   Default Value is $2F/47 (%00101111).

Kernal-Reference:

 LDA $00,X   : $F5E2
 STA $00     : $FDDB
     $00,X   : $B4D7



  $01/1:   6510 On-chip 8-bit Input/Output Register

   +----------+---------------------------------------------------+
   | Bits 7-6 |   Undefined                                       |
   | Bit  5   |   Cassette Motor Control (0 = On, 1 = Off)        |
   | Bit  4   |   Cassette Switch Sense: 1 = Switch Closed        |
   | Bit  3   |   Cassette Data Output Line                       |
   | Bit  2   |   /CharEn-Signal (see Memory Configuration)       |
   | Bit  1   |   /HiRam-Signal  (see Memory Configuration)       |
   | Bit  0   |   /LoRam-Signal  (see Memory Configuration)       |
   +----------+---------------------------------------------------+
   Default Value is $37/55 (%00110111).

  (German-?)C128 only:

   +--------+-----------------------------------------------------+
   | Bit  6 |   ASCII/DIN-Switch (0=DIN, 1=ASCII)                 |
   +--------+-----------------------------------------------------+
   Default Value is $77/119 (%01110111).

  Flash_8 only:

   +--------+-----------------------------------------------------+
   | Bit  7 |   1 = 1 MHz, 0 = 8 MHz (if DIP1 closed)             |
   | Bit  6 |   (?)                                               |
   +--------+-----------------------------------------------------+
   Default Value is $37/55 (%00110111).

Kernal-Reference:

 ASL $01,X   : $B9A6
 BIT $01     : $F830 $F834
 INC $01,X   : $B9AA
 LDA $01     : $EA61 $EA6B $EA75 $F8AB $FBBF $FCCA
     $01,X   : $F5E6
     $0001,Y : $B8CB
 LDY $01,X   : $B991
 LSR $01,X   : $B89E
 ROR $01,X   : $B9AC $B9AE
 SBC $01,X   : $B8CE
 STA $01     : $EA79 $F8AF $FBC3 $FCCE $FDD7
     $01,X   : $B4DB
 STY $01,X   : $B997



 $02/2:   Unused

Kernal-Reference:

 LDA $0002,Y : $B8C4
 LDY $02,X   : $B98D
 ROR $02,X   : $B9B0
 SBC $02,X   : $B8C7
 STA $02,X   : $B4DF
     $0002,Y : $FD53
 STY $02,X   : $B993



 $03-$04/3-4:   Jump Vector: Convert FAC to Integer in (A/Y)

   Points to $B1AA

Kernal-Reference:

 LDA $0003,Y : $B8BD
 LDY $03,X   : $B989
 ROR $03,X   : $B9B2
 SBC $03,X   : $B8C0
 STA $03     : $E3DC
 STY $03,X   : $B98F

 LDA $0004,Y : $B8B6
 LDY $04,X   : $B985
 ROR $04,X   : $B9B4
 SBC $04,X   : $B8B9
 STY $04     : $E3DE
     $04,X   : $B98B



 $05-$06/5-6:   Jump Vector: Convert Integer in (A/Y) to Floating point
                             in (FAC)
   Points to $B391

Kernal-Reference:

 STA $05     : $E3D4

 STY $06     : $E3D6



 $07/7:   Search Character/Temporary Integer during INT
 $07-$08/7-8:   Temporary Integer during OR/AND

Kernal-Reference:

 ADC $07     : $A997
 AND $07     : $B00F
 CMP $07     : $B49C
 LDA $07     : $E011
 LDX $07     : $A913
 LDY $07     : $BF9C
 STA $07     : $A915 $A975 $AC61 $AC65 $AC6D $AFF4 $BCE4
 STX $07     : $A90B $B489



 $08/8:   Flag: Scan for Quote at end of String
 $07-$08/7-8:   Temporary Integer during OR/AND

Kernal-Reference:

 AND $08     : $B006
 CMP $08     : $A5EA $A91D $B4A0
 LDA $08     : $A911
 STA $08     : $A592 $A5E3 $AC72 $AFFA
 STX $08     : $A917 $B48B
 STY $08     : $A90F



 $09/9:   Screen Column for last TAB

Kernal-Reference:

 SBC $09     : $AB0A
 STY $09     : $AAFD



 $0A/10:   Flag: 0 = Load, 1 = Verify

Kernal-Reference:

 LDA $0A     : $E16F $E17A
 STA $0A     : $E16A



 $0B/11:   Input Buffer Pointer/Number of Subscripts

Kernal-Reference:

 ADC $0B     : $A4FD
 DEC $0B     : $B2A6 $B324
 EOR $0B     : $AFF2 $AFF8 $B004 $B008 $B00D $B011
 INC $0B     : $A5F7
 LDA $0B     : $B194 $B256 $B27F
 LDY $0B     : $A51F
 ORA $0B     : $A5C5
 STA $0B     : $B2EC
 STY $0B     : $A4A2 $A5B0 $AFEB $B209



 $0C/12:   Flag: Default Array dimension

Kernal-Reference:

 BIT $0C     : $B28A
 LDA $0C     : $B1D1 $B24F $B2E5
 STA $0C     : $B216
 STX $0C     : $B090



 $0D/13:   Data type Flag

   $00 = Numeric, $FF = String

Kernal-Reference:

 ADC $0D     : $ADE1
 BIT $0D     : $AAB8 $AC54 $AD90
 LDA $0D     : $A9B4 $AF33 $B1D6 $B37D
 LSR $0D     : $AE07
 STA $0D     : $AE88 $B030 $B0C0 $B20F
 STX $0D     : $B0A1 $B393 $B787
 STY $0D     : $B4EA



 $0E/14:   Data type Flag

   $00 = Floating point, $80 = Integer

Kernal-Reference:

 BIT $0E     : $AF5D
 LDA $0E     : $A9B1 $AC8C
 ORA $0E     : $B1D3
 STA $0E     : $B0CE $B212
 STX $0E     : $B0A3



 $0F/15:   Flag: DATA scan/List Quote/Garbage collection

Kernal-Reference:

 BIT $0F     : $A598 $A720
 LDA $0F     : $A6FA $B518
 LSR $0F     : $B4F4
 STA $0F     : $A5DC $A6FE $B521
 STY $0F     : $A580 $A6CB



 $10/16:   Flag: Subscript reference/User Function call

Kernal-Reference:

 LDA $10     : $B0C8
 ORA $10     : $B0DE
 STA $10     : $A68B $A744 $B3BE $B3E8
 STY $10     : $B0E9



 $11/17:   Input Flag: $00 = INPUT, $40 = GET, $98 = READ

Kernal-Reference:

 BIT $11     : $AC31 $AC58
 LDA $11     : $AB4D
 LDX $11     : $ACE3
 STA $11     : $AC0F



 $12/18:   Flag: TAN sign/Comparative result

Kernal-Reference:

 AND $12     : $B075
 LDA $12     : $E297 $E2D0
 STA $12     : $AE68 $E29B $E2B9



 $13/19:   File number of current Input Device

Kernal-Reference:

 BIT $13     : $AADC
 LDA $13     : $AAD3 $AB3B $AB62 $ABB5 $ABD9 $ABEF $ABF9 $AC43 $ACF0
 LDX $13     : $ABA0
 STA $13     : $A44C $E380 $E3F2
 STX $13     : $AA91 $AB8D $ABAD $ABBC



 $14-$15/20-21:   Temporary: Integer value

Kernal-Reference:

 ADC $14     : $A987
 ASL $14     : $A991
 CPX $14     : $A6E2
 JMP ($0014) : $E144
 LDA $14     : $A50D $A62E $A6BD $A97F $A995 $B810
     ($14),Y : $B818 $B840
 SBC $14     : $A8A9
 STA $14     : $A6C5 $A989 $A999 $B81C
     ($14),Y : $B82A
 STX $14     : $A96D
 STY $14     : $B808

 ADC $15     : $A98D
 CMP $15     : $A6DE
 INC $15     : $A99D
 LDA $15     : $A623 $A977 $B80D
 LDY $15     : $A50F
 ORA $15     : $A6BF
 ROL $15     : $A993
 SBC $15     : $A8AD
 STA $15     : $A6C7 $A98F $B80A $B81F
 STX $15     : $A96F



 $16/22:   Pointer: Temporary String Stack

Kernal-Reference:

 CMP $16     : $B544
 LDX $16     : $B4CA
 STA $16     : $B6E3
 STX $16     : $A67C $B4F1 $E400



 $17-$18/23-24:   Last temporary String Address

Kernal-Reference:

 CMP $17     : $B6DF
 STA $17     : $B6E7
 STX $17     : $B4EC

 BIT $18     : $F5A8 $F68C
 CPY $18     : $B6DB
 STA $18     : $E3F4



 $19-$21/25-33:   Stack for temporary Strings



 $22-$25/34-37:   Utility Pointer Area
 $22-$23/34-35:   First Utility Pointer
 $24-$25/36-37:   Second Utility Pointer

Kernal-Reference:

 ADC $22     : $A4D8 $A54B $ADED $B5A6 $B5F9 $B71D $B7C2
 CPX $22     : $A403
 INC $22     : $AE3C
 JMP ($0022) : $AE55
 LDA $22     : $A98B $B5EA
     ($22),Y : $A456 $A4DF $A53E $A545 $AA1D $AB2B $B583 $B587 $B58B $B592
               $B59F $B5BD $B5C2 $B5C7 $B5CC $B5D0 $B691 $B6B4 $B6B8 $B6BC
               $B792 $BA92 $BA97 $BA9C $BAA1 $BAB0 $BBA8 $BBAD $BBB2 $BBB7
               $BBC0 $E0A7 $E0AC $E0B2 $E0B7
 LDX $22     : $B7BD $E25D
 LDY $22     : $B2A4 $B31E
 ROL $22     : $A982 $A985
 SBC $22     : $A3D3 $A3DE
 STA $22     : $A3C4 $A400 $A440 $A4B1 $A537 $A784 $A979 $ADEA $AE3A $B540
               $B555 $B57D $B5A8 $B5FB $B6AA $B71F $BA8C $BBA2
     ($22),Y : $A550 $A557 $BBDF $BBE4 $BBE9 $BBF2 $BBF7
 STX $22     : $A559 $B688 $B6D6 $BBD7 $E0A1
 STY $22     : $B34C

 DEC $23     : $A4DC
 INC $23     : $A4E6 $B5AC $B5FF $B723
 LDA $23     : $A552
 LDX $23     : $B5AE $B5EC $B601 $B7C6
 LDY $23     : $E25F
 STA $23     : $A445 $A4AD $A55B $AE3F
 STX $23     : $B542 $B557 $B57F
 STY $23     : $A539 $A786 $B68A $B6AC $B6D8 $BA8E $BBA4 $BBD9 $E0A3

 LDA ($24),Y : $B7D1 $BC61 $BC67 $BC71 $BC7A $BC81 $BC8C
 STA $24     : $A4C1 $AD3D $B7C4 $BC5B
     ($24),Y : $A4E1 $B7D5 $B7E0

 DEC $25     : $A4D5
 INC $25     : $A4E8
 STA $25     : $A4B5
 STX $25     : $B7CD
 STY $25     : $BC5D



 $26-$2A/38-42:   Floating point product of Multiply and Divide

  Used by Jiffy-DOS: ALLFLAG/RSIZE ($26)
  Used by Jiffy-DOS: COMSAV ($27)

   Used only from Basic for Jiffy-DOS wedge comands, device
   toggle and function keys.

Kernal-Reference:

 LDA $26     : $BA77 $BB8F
 ROR $26     : $BA7D
 STA $26     : $BA35 $BA7B

 LDA $27     : $BA71 $BB93
 ROR $27     : $BA7F
 STA $27     : $BA37 $BA75

 ADC $28     : $B36F
 LDA $28     : $BA6B $BB97
 ROR $28     : $BA81
 STA $28     : $B350 $BA39 $BA6F
 STX $28     : $B337

 ADC $29     : $B373
 LDA $29     : $BA65 $BB9B
 ROR $29     : $BA83
 STA $29     : $B355 $BA3B $BA69
     $29,X   : $BB44



 $2B-$2C/43-44:   Pointer: Start of BASIC Text Area

   Default Value is $0801

Kernal-Reference:

 INC $2B     : $E41B
 LDA $2B     : $A533 $A613 $A64C $A68F $A81E $A8BC $E422
 LDX $2B     : $E171
 SBC $2B     : $E433
 STA ($2B),Y : $A647 $A64A $E419
 STX $2B     : $E406

 INC $2C     : $E41F
 LDA $2C     : $A653 $A695
 LDX $2C     : $A615 $A8BE
 LDY $2C     : $A535 $A822 $E173 $E424
 SBC $2C     : $E438
 STY $2C     : $E408



 $2D-$2E/45-46:   Pointer: Start of BASIC Variables

  Used by pucrunch: Temporary (LZPOS),
                              after depacking: End of Program

Kernal-Reference:

 CMP $2D     : $AA47
 LDA $2D     : $A4AF $A4F9 $A66B $B0EB $B551
 LDX $2D     : $E159
 SBC $2D     : $A4CF
 STA $2D     : $A4BF $A51B $A651
 STX $2D     : $E1A7

 CPY $2E     : $AA3F
 LDA $2E     : $A4C3
 LDX $2E     : $B0ED $B553
 LDY $2E     : $A501 $A66D $E15B
 STA $2E     : $A4C7 $A657
 STY $2E     : $A51D $E1A9



 $2F-$30/47-48:   Pointer: Start of BASIC Arrays

Kernal-Reference:

 CMP $2F     : $B0F7 $B55D
 LDA $2F     : $B143
 LDX $2F     : $B218
 STA $2F     : $A66F $B165

 CPX $30     : $B0F3 $B559
 LDA $30     : $B21A
 LDY $30     : $B145
 STY $30     : $A671 $B167



 $31-$32/49-50:   Pointer: End of BASIC Arrays + 1

Kernal-Reference:

 CMP $31     : $B507 $B576
 CPX $31     : $B224
 LDA $31     : $A517 $B14B $B2D6 $B534
 SBC $31     : $B38A
 STA $31     : $A3BB $A673 $B2BC

 CMP $32     : $B220
 CPX $32     : $B572
 CPY $32     : $B501
 LDA $32     : $B2DE
 LDX $32     : $B536
 LDY $32     : $A519 $B14D
 SBC $32     : $B38F
 STY $32     : $A3BD $A675 $B2BE



 $33-$34/51-52:   Pointer: Bottom of String space

Kernal-Reference:

 ADC $33     : $B4FA $B6CD
 CMP $33     : $A40E $A430 $AA39
 CPX $33     : $B5D8 $B6C7
 LDA $33     : $B388 $B620
 STA $33     : $A667 $B50B $B6CF
 STX $33     : $B52A $E412

 CMP $34     : $AA30 $B5D2
 CPY $34     : $A408 $A42A $B6C3
 INC $34     : $B6D3
 LDA $34     : $B38D
 LDX $34     : $B622
 LDY $34     : $B4FC
 STA $34     : $B52C
 STY $34     : $A669 $B50D $E414



 $35-$36/53-54:   Utility String Pointer

Kernal-Reference:

 ADC $35     : $B69A
 STA $35     : $B50F $B69C
     ($35),Y : $B693

 INC $36     : $B6A0
 STY $36     : $B511



 $37-$38/55-56:   Pointer: Highest Address available to BASIC

   Default Value is $A000

Kernal-Reference:

 LDA $37     : $A663 $E430
 LDX $37     : $B526
 STX $37     : $E0FF $E40E

 BIT $38     : $AD8E
 LDA $38     : $B528 $E436
 LDY $38     : $A665
 STY $38     : $E0FD $E410



 $39-$3A/57-58:   Current BASIC Line number

Kernal-Reference:

 LDA $39     : $A76A $A841 $A891 $A8A7
 LDX $39     : $BDCB
 STA $39     : $A7D1 $A86C $A8ED $AB5B $AD64

 LDA $3A     : $A767 $A88E $A8AB $BDC9
 LDX $3A     : $A838 $B3A6
 LDY $3A     : $A46C $A843
 STA $3A     : $A7D6 $A8F0 $AD69
 STX $3A     : $A492
 STY $3A     : $A86E $AB5D



 $3B-$3C/59-60:   Previous BASIC Line number

Kernal-Reference:

 LDA $3B     : $A868
 STA $3B     : $A845

 LDY $3C     : $A86A
 STY $3C     : $A847



 $3D-$3E/61-62:   Pointer: BASIC Statement for CONT

Kernal-Reference:

 LDA $3D     : $A862 $AB72
 STA $3D     : $A7BA $A83D

 LDY $3E     : $A85B $AB74
 STA $3E     : $A689
 STY $3E     : $A7BC $A83F



 $3F-$40/63-64:   Current DATA Line number

Kernal-Reference:

 LDA $3F     : $AB57
 STA $3F     : $ACC9

 LDY $40     : $AB59
 STA $40     : $ACCF



 $41-$42/65-66:   Pointer: Used by READ - current DATA Item Address

Kernal-Reference:

 LDX $41     : $AC06
 STA $41     : $A827

 LDY $42     : $AC08
 STY $42     : $A829



 $43-$44/67-68:   Pointer: Temporary storage of Pointer during INPUT Routine

Kernal-Reference:

 LDA $43     : $ACDF
     ($43),Y : $ACEC
 LDX $43     : $AC24
 STA $43     : $ACA1
 STX $43     : $AC11

 LDY $44     : $AC26 $ACE1
 STY $44     : $AC13 $ACA3



 $45-$46/69-70:   Name of Variable being sought in Variable Table

Kernal-Reference:

 CMP $45     : $B22D
 LDA $45     : $B0FB $B128 $B16B $B1E0 $B26D $B32C
 LDX $45     : $AF2F
 ORA $45     : $B0D0
 STA $45     : $B092 $B0D2 $B1E7

 LDA $46     : $B101 $B170 $B1DD $B231 $B275 $B331
 LDY $46     : $AF31 $B12A
 STA $46     : $B1EA
 STX $46     : $B0DB



 $47-$48/71-72:   Pointer: to value of (VARNAM) if Integer, to descriptor
                           if String

Kernal-Reference:

 LDA $47     : $B349 $B3D2 $B435
     ($47),Y : $B418
 LDY $47     : $BEB4
 STA $47     : $B18F $B341 $B40D
 STY $47     : $BE9D

 LDA $48     : $B3CF $B432
 LDY $48     : $B41E
 STA $48     : $B346 $B415
 STY $48     : $B191



 $49-$4A/73-74:   Pointer: Index Variable for FOR/NEXT loop

Kernal-Reference:

 AND $49     : $B844
 LDA $49     : $A3A9 $A7A8 $AD4B $E1CA $E238 $E24C
 LDX $49     : $BBD0 $E1FB
 LDY $49     : $A6EF
 STA $49     : $A39D $A9A8 $AC18 $AD27
     ($49),Y : $A9CE $A9D3 $AA73 $AA78 $AA7D
 STX $49     : $B830 $E1EE $E224
 STY $49     : $A6E8 $A728

 EOR $4A     : $B842
 LDA $4A     : $A396 $A7A5
 LDX $4A     : $E24A
 LDY $4A     : $A9DA $AD4D $BBD2
 STA $4A     : $A3A2 $A8D6
 STX $4A     : $B83C $E234
 STY $4A     : $A9AA $AC1A $AD29



 $4B-$4C/75-76:   Temporary storage for TXTPTR during READ, INPUT and GET

Kernal-Reference:

 LDA $4B     : $ACA5
 LDY $4B     : $ADFE
 STA $4B     : $AC20
 STY $4B     : $AE64

 LDY $4C     : $ACA7
 STY $4C     : $AC22



 $4D/77:   Mask used during FRMEVL

Kernal-Reference:

 CMP $4D     : $ADCB
 DEC $4D     : $B032
 EOR $4D     : $ADC9
 LDA $4D     : $AE2B
 LDX $4D     : $ADD7
 STA $4D     : $ADB6 $ADCF $AE15



 $4E-$52/78-82:   Temporary storage for FLPT value

Kernal-Reference:

 LDA $4E     : $B3FA
     ($4E),Y : $B40B $B411 $B429 $B42E $B614
 ORA $4E     : $B608
 STA $4E     : $B3ED $B404 $B43C $B5EE
     ($4E),Y : $B452 $B456 $B45A $B45E $B462 $B630 $B638
 STY $4E     : $B532

 LDA $4F     : $B3F7 $B606
 STA $4F     : $B407 $B43F
 STX $4F     : $B5F0
 STY $4F     : $B3EF $B530

 CMP ($50),Y : $B703
 LDA $50     : $AA59 $B663 $B712
     ($50),Y : $AA71 $AA76 $AA7B $B708
 SBC ($50),Y : $B730 $B753
 STA $50     : $AA68 $B76E
 STX $50     : $B479

 LDY $51     : $AA5B $B665 $B714
 STA $51     : $B771
 STY $51     : $AA6A $B47B



 $53/83:   Length of String Variable during Garbage collection

Kernal-Reference:

 LDA $53     : $B5F2 $B5F6
 STA $53     : $B54F $B56C $E3EC



 $54-$56/84-86:   Jump Vector used in Function Evaluation

   JMP followed by Address: $4C,$LB,$HB

Jump from $AFE0

Kernal-Reference:

 STA $54     : $E3C1

 LDA $55     : $B60C $B773
 LDY $55     : $B62B
 STA $55     : $AFD9 $B5F4 $B612 $B767

 ADC $56     : $B8B2 $B8FE
 LDA $56     : $E029
 STA $56     : $AFDE $E000
 STX $56     : $B871
 STY $56     : $B88D



 $57-$5B/87-91:   Temporary storage for FLPT value

Kernal-Reference:

 LDA $57,X   : $A417

 ADC $58     : $B2B2 $B33F $B58D
 CMP $58     : $B5B4
 LDA $58     : $A3DC $B160 $B56E $B62E
 STA $58     : $A3E0 $A4FF $B159 $B1A0 $B566 $B58F $B624
     ($58),Y : $A3EA $A3F1 $B2C9

 ADC $59     : $B2AA $B344 $B594
 CPX $59     : $B5B0
 DEC $59     : $A3E4 $A3F5 $B2CD
 INC $59     : $B2D3 $B633
 LDA $59     : $B635
 LDX $59     : $B570
 LDY $59     : $B162
 STA $59     : $B2AE $B596
 STX $59     : $B568 $B626
 STY $59     : $A508 $B15B $B1A2

 LDA $5A     : $A3C0 $A3D0
     ($5A),Y : $A3E8 $A3EF
 STA $5A     : $A3D5 $A4FB $B14F $B618

 DEC $5B     : $A3D9 $A3F3
 LDA $5B     : $A3C7
 STA $5B     : $B61E
 STY $5B     : $A503 $B151



 $5C-$60/92-96:   Temporary storage for FLPT value

Kernal-Reference:

 DEC $5D     : $B378 $BE24 $BEA8
 INC $5D     : $BD6F $BE2B
 LDA $5D     : $BE37
 SBC $5D     : $BD4A
 STA $5D     : $B359 $BE09
 STX $5D     : $BE4C
 STY $5D     : $AF52
     $5D,X   : $BCF7

 ADC $5E     : $BDA3
 DEC $5E     : $BD5E
 INC $5E     : $BD55
 LDA $5E     : $BD47 $BD91
 LDX $5E     : $BED5
 SBC $5E     : $BD3C $BEDE
 STA $5E     : $BD4C $BDAE $BE4A
 STY $5E     : $AF4B

 ADC $5F     : $B199 $B23B $B616
 BIT $5F     : $BD43 $BD6B
 CMP ($5F),Y : $A625 $A631 $B0FD $B104 $B233 $B25A $B2FC $B304
 CPX $5F     : $B5E2
 LDA $5F     : $A4B7 $A4CD $A8C5 $B10A $B185
     ($5F),Y : $A4AB $A61D $A638 $A63C $A6CD $A6D8 $A6DC $A703 $A708 $A70C
               $B22A $B238 $B23F $B2EA $B34E $B353
 ROR $5F     : $BD41
 SBC $5F     : $A3C2 $B2D8
     ($5F),Y : $A4BA
 STA $5F     : $A619 $B0F1 $B147 $B538
     ($5F),Y : $A525 $B16D $B172 $B177 $B17A $B17D $B180 $B183 $B26F $B277
               $B284 $B297 $B29B $B2DC $B2E3
 STX $5F     : $A70E $B21C $B5E6

 ADC $60     : $B241
 BIT $60     : $BD35 $BD99
 CMP $60     : $B5DC
 LDA $60     : $A4B3 $A8CB $B61A
     $60,X   : $BC11
 LDY $60     : $B18A $B19B
 ROR $60     : $BD2E
 SBC $60     : $A3C9 $A4C9 $B2E1
 STA $60     : $A710 $B21E $B5E8
     $60,X   : $BC04
 STX $60     : $A61B $B0EF $B53A
 STY $60     : $B149



 $61-$66/97-102:   Main Floating point Accumulator
 $61/97:   FAC Exponent

Kernal-Reference:

 ADC $61     : $BABC
 CPX $61     : $BC6D
 INC $61     : $B938 $BAF4 $BB21
 LDA $61     : $A937 $AE52 $AE80 $B1BF $B4D5 $B7FB $B85D $B9F4 $BAB4 $BBF5
               $BC1B $BC2B $BC9B $BCCC $BFB4 $E005 $E0E7 $E316
 LDX $61     : $B052 $BD8C $BDF1
 LDY $61,X   : $E020
 SBC $61     : $B04A $B87B $B92C $BB1A
 STA $61     : $B037 $B484 $B8F9 $B934 $B9FB $BAC8 $BB1C $BBC2 $BCE0 $E0ED
     $61,X   : $A422 $E022
 STX $61     : $BC4F
 STY $61     : $A9E9 $B4A9 $B881



 $62-$65/98-101:   FAC Mantissa

Kernal-Reference:

 AND $62     : $A77C $BBF0
 CMP $62     : $BC75
     ($62),Y : $B068
 CPY $62     : $BB2B
 INC $62     : $B97B
 LDA $62     : $AE4F $B4D9 $B914 $B94D $BA51 $BC44 $BE80 $E0D5
 LDX $62     : $B8DB
 LSR $62     : $BCC0
 ORA $62     : $BCC2
 ROL $62     : $B927
 ROR $62     : $B93C
 SBC $62     : $BB72
 STA $62     : $A77E $B395 $B491 $B8D0 $B918 $B951 $BB91 $BBBD $BC3C $BCC4
               $BCE9 $BDCD $BE85 $E0A9
     ($62),Y : $B6F9
 STX $62     : $B039 $B480 $B8E1 $E0D9
 STY $62     : $AF8F

 CMP $63     : $BC7C
 CPY $63     : $BB31
 INC $63     : $B977
 LDA $63     : $AE4C $B4DD $B90E $B953 $BA4C $BBE7 $BE79
 LDX $63     : $B8DF $E0DB
 LDY $63     : $AA16
 ROL $63     : $B925
 ROR $63     : $B93E
 SBC $63     : $BB6C
 STA $63     : $B8C9 $B912 $B957 $BB95 $BBB4 $BC40 $BCEB $BE7E $E0B4 $E0DF
 STX $63     : $B8E5 $BDCF
 STY $63     : $AF89 $B03B $B397 $B482 $B493

 ADC $64     : $B31A
     ($64),Y : $B654
 CMP $64     : $BC83
 CPY $64     : $BB37
 INC $64     : $B973
 LDA $64     : $A9CC $AA45 $AA4B $AE49 $AEDC $AF15 $AFA0 $AFC2 $AFF0 $B00B
               $B1AD $B1F7 $B640 $B6A6 $B804 $B908 $B959 $BA47 $BBE2 $BE72
               $E0DD
     ($64),Y : $AA2E $AA37 $AA54 $AF63 $AF67
 LDX $64     : $AA14 $B475 $B7A4 $B8E3
 ROL $64     : $B923
 ROR $64     : $B940
 SBC $64     : $AF21 $BB66
 STA $64     : $AF2B $B2F7 $B8C2 $B90C $B95D $BB99 $BBAF $BC4D $BCED $BE77
               $E0AE
 STX $64     : $AF87 $B4E3 $B8E9 $E0E1

 ADC $65     : $B320
 CMP $65     : $B759
 CPY $65     : $BB3D
 DEC $65     : $A957
 INC $65     : $B96F
 LDA $65     : $A9D1 $AA18 $AE46 $AED7 $AF19 $AFBF $AFF6 $B002 $B1FC $B63D
               $B75D $B902 $B95F $BA42 $BBDD $BCE2 $BE6A
 LDX $65     : $B7A8 $B8E7 $E0D3
 LDY $65     : $AA3D $AA4D $AFA2 $B1AF $B477 $B6A8 $B806
 ROL $65     : $B921
 ROR $65     : $B942
 SBC $65     : $AF25 $BB60 $BC8E
 STA $65     : $AF8B $B2FA $B739 $B8BB $B906 $B963 $BB9D $BBAA $BC4B $BCEF
               $BE70 $E0B9 $E0D7
 STX $65     : $B8ED
 STY $65     : $AF2D $B4E5



 $66/102:   FAC Sign

Kernal-Reference:

 BIT $66     : $BCA2 $BDE1
 EOR $66     : $AE7C $BAA5 $BC69 $BD88
 LDA $66     : $A778 $AE33 $B1BB $B7F7 $B853 $B947 $BAD4 $BBEC $BC2F $BC92
               $BCBC $BCD7 $BFB8 $E28B $E293 $E30E
 LDX $66     : $B05F
 LSR $66     : $BC58
 STA $66     : $AD49 $B056 $B857 $B8FB $B94B $BAD1 $BBB9 $BBFE $BC53 $BDEA
               $BFBC $E0E5 $E2CE
 STY $66     : $A9EB $B885 $BCD9



 $67/103:   Pointer: Series Evaluation Constant

Kernal-Reference:

 DEC $67     : $E088
 LDA $67     : $BD62
 STA $67     : $E062
 STX $67     : $BD02



 $68/104:   Bit Overflow Area during normalisation Routine

Kernal-Reference:

 LDA $68,X   : $BC02
 LDY $68     : $B995
 STA $68     : $BCA9 $E3F0
     $68,X   : $BC13
 STY $68     : $BCB8 $BCC9



 $69-$6E/105-110:   Auxiliary Floating point Accumulator
 $69/105:   AFAC Exponent

Kernal-Reference:

 LDA $69     : $B875 $BAB7 $BF7D
     $69,X   : $E01E
 STA $69     : $AE6B $BAB2
 STY $69,X   : $E024



 $6A-$6D/106-109:   AFAC Mantissa

Kernal-Reference:

 ADC $6A     : $B916 $BA79
 AND $6A     : $B01F
 LDA $6A     : $BB70
 LDY $6A     : $BB29
 ROL $6A     : $BB55
 STA $6A     : $AE6E $B021 $BAAD $BB74

 ADC $6B     : $B910 $BA73
 LDA $6B     : $BB6A
 LDY $6B     : $BB2F
 ROL $6B     : $BB53
 STA $6B     : $AE71 $BA9E $BB6E

 ADC $6C     : $B90A $BA6D
 LDA $6C     : $B03D $BB64
     ($6C),Y : $B066
 LDY $6C     : $BB35
 ROL $6C     : $BB51
 STA $6C     : $AE74 $BA99 $BB68
 STX $6C     : $B044

 ADC $6D     : $B904 $BA67
 ASL $6D     : $BB4F
 LDA $6D     : $BB5E
 LDY $6D     : $B03F $BB3B
 STA $6D     : $AE77 $BA94 $BB62
 STY $6D     : $B046



 $6E/110:   AFAC Sign

Kernal-Reference:

 EOR $6E     : $B859
 LDA $6E     : $B01B $BAA9 $BBFC $BD86 $BF8B
 LDX $6E     : $E272
 LDY $6E     : $B883
 STA $6E     : $AE7A $BAA3



 $6F/111:   Sign of result of Arithmetic Evaluation

Kernal-Reference:

 ADC $6F     : $B4AC
 BIT $6F     : $B8A3
 LDA $6F     : $B66D $BACF
     ($6F),Y : $B498 $B651 $B67C $B680 $B684
 LDX $6F     : $B4C3
 STA $6F     : $AA5D $AE7E $B48D $B64A $B85B $BAA7 $BD8A $E03C $E27F
 STX $6F     : $BAEF $BB07



 $70/112:   FAC low-order rounding

Kernal-Reference:

 ASL $70     : $B91F $BC1F
 CMP $70     : $BC8A
 INC $70     : $B96B
 LDA $70     : $B4B7 $B89C $B965 $B9A2 $BA3D $BFF4
 LDX $70     : $B4B0 $B86F $B8EB
 LDY $70     : $B4C5 $B66F
 ROR $70     : $B944 $BA85
 STA $70     : $AF39 $B64D $B8B4 $B900 $B969 $BB84 $BC51 $E02B $E0E9
 STX $70     : $BC09 $BC18
 STY $70     : $AA5F $B48F $B4E7 $B895 $B8EF $B987 $BBC4 $BBF9 $BCD5



 $71-$72/113-114:   Pointer: Used during CRUNCH/ASCII conversion

Kernal-Reference:

 ASL $71     : $B367
 INC $71     : $A9F5
 LDA $71     : $E073
     ($71),Y : $E060
 LDX $71     : $B7E2
 LDY $71     : $A5C7 $A9F7 $AA07 $B2C4 $BE53 $BE9F $BEC4 $E064
 ORA $71     : $B311
 STA $71     : $B2F0 $B4AE $E043 $E059 $E06C $E07D
 STX $71     : $B27D $B2A0 $B322 $B7B9
 STY $71     : $A5AC $A9ED $AF4E $BDEC $BE64 $BEB2

 DEC $72     : $B2CF
 INC $72     : $B2C2 $E06A
 LDA $72     : $B30F
 LDY $72     : $B7E4 $E06E $E075
 ROL $72     : $B369
 STA $72     : $B2A2 $B2F2 $B328
 STX $72     : $B4B5
 STY $72     : $B269 $B7BB $E045 $E05B $E07F



 $73-$78/115-120:   CHRGET: Get next Byte of BASIC Text

Jump from $0082, $A48A, $A6B3, $A799, $A7E4, $A801, $A812, $A95F, $A99F,
          $AB13, $AB82, $AC51, $AD84, $ADD1, $AE8A, $AEA5, $AF05, $AFAA,
          $B0A5, $B0B0, $B0D8, $B1B2, $B79B, $BD0A, $BD17, $BD30:

0073: E6 7A     INC $7A       ; Pointer: Current Byte of BASIC Text
0075: D0 02     BNE $0079     ; CHRGOT: Get same Byte again
0077: E6 7B     INC $7B       ; Pointer: Current Byte of BASIC Text

Kernal-Reference:

 STA $73,X   : $E3E5



 $79-$8A/121-138:   CHRGOT: Get same Byte again

Jump from $0075, $A6AA, $A792, $A897, $A92B, $A940, $AA9D, $AC2C, $AC91,
          $ACAD, $ACD4, $AD7D, $ADB8, $B085, $B08D, $B094, $B202, $B441,
          $B73B, $B7AA, $B7D7, $B834, $E206, $E211:

0079: AD 60 EA  LDA $EA60     ; Main IRQ Entry Point
007C: C9 3A     CMP #$3A
007E: B0 0A     BCS $008A

Jump from $AA1F:

0080: C9 20     CMP #$20
0082: F0 EF     BEQ $0073     ; CHRGET: Get next Byte of BASIC Text
0084: 38        SEC
0085: E9 30     SBC #$30
0087: 38        SEC
0088: E9 D0     SBC #$D0

Jump from $007E:

008A: 60        RTS

Kernal-Reference:

 ADC $7A     : $A75F $A7D9 $A8B3 $A8FD
     ($7A),Y : $BDA9
 CMP ($7A),Y : $AF01
 DEC $7A     : $ADA4 $AE11
 INC $7A     : $E3A2
 LDA $7A     : $A7B1 $A834 $A88B $AC1C $AC74 $AC9D $AEBD $B3D8 $B426 $E187
     ($7A),Y : $A7C0 $A7C6 $A7CF $A7D4 $A919 $ACC2 $ACC7 $ACCC
 LDX $7A     : $A57C $A5F5 $AD9E $AE0B $B7B5
 STA $7A     : $A610 $A693 $A7DB $A864 $A8C9 $A8F3 $A8FF $AB76 $ACA9 $AD6E
               $B42B $B44A
 STX $7A     : $A486 $A5B3 $AC28 $AC4D $AC5D $B7BF $B7E6

 DEC $7B     : $A60C $ADA2 $AE0F
 INC $7B     : $A7DF $A903 $E3A6
 LDA $7B     : $A762 $A888 $B3D5 $B423 $E1A1
 LDX $7B     : $A8B5
 LDY $7B     : $A7B3 $A836 $AC1E $AC76 $AC9F $AEBF $B7B7
 STA $7B     : $A699 $A8CF $A8F6 $AD73 $B430 $B44D
 STX $7B     : $B7C8
 STY $7B     : $A488 $A866 $AB78 $AC2A $AC4F $ACAB $B7E8



 $7A-$7B/122-123   Pointer: Current Byte of BASIC Text

Kernal-Reference:

 ADC $7A     : $A75F $A7D9 $A8B3 $A8FD
     ($7A),Y : $BDA9
 CMP ($7A),Y : $AF01
 DEC $7A     : $ADA4 $AE11
 INC $7A     : $E3A2
 LDA $7A     : $A7B1 $A834 $A88B $AC1C $AC74 $AC9D $AEBD $B3D8 $B426 $E187
     ($7A),Y : $A7C0 $A7C6 $A7CF $A7D4 $A919 $ACC2 $ACC7 $ACCC
 LDX $7A     : $A57C $A5F5 $AD9E $AE0B $B7B5
 STA $7A     : $A610 $A693 $A7DB $A864 $A8C9 $A8F3 $A8FF $AB76 $ACA9 $AD6E
               $B42B $B44A
 STX $7A     : $A486 $A5B3 $AC28 $AC4D $AC5D $B7BF $B7E6

 DEC $7B     : $A60C $ADA2 $AE0F
 INC $7B     : $A7DF $A903 $E3A6
 LDA $7B     : $A762 $A888 $B3D5 $B423 $E1A1
 LDX $7B     : $A8B5
 LDY $7B     : $A7B3 $A836 $AC1E $AC76 $AC9F $AEBF $B7B7
 STA $7B     : $A699 $A8CF $A8F6 $AD73 $B430 $B44D
 STX $7B     : $B7C8
 STY $7B     : $A488 $A866 $AB78 $AC2A $AC4F $ACAB $B7E8



 $8B-$8F/139-143:   Floating RND Function Seed Value



 $90/144:   Kernal I/O Status Word ST

   +-------+---------------------------------+
   | Bit 7 |   1 = Device not present (S)    |
   |       |   1 = End of Tape (T)           |
   | Bit 6 |   1 = End of File (S+T)         |
   | Bit 5 |   1 = Checksum error (T)        |
   | Bit 4 |   1 = Different error (T)       |
   | Bit 3 |   1 = Too many bytes (T)        |
   | Bit 2 |   1 = Too few bytes (T)         |
   | Bit 1 |   1 = Timeout Read (S)          |
   | Bit 0 |   1 = Timeout Write (S)         |
   +-------+---------------------------------+

   (S) = Serial bus, (T) = Tape

Kernal-Reference:

 AND $90     : $F4F5
 BIT $90     : $EE79 $F249 $F28A $F524
 LDA $90     : $F1AD $F3ED $F4DA $F505 $F55D $FE1A
 ORA $90     : $FE1C
 STA $90     : $F311 $F3DF $F4A9 $F4F7 $F843 $FE1E



 $91/145:   Flag: $7F = STOP key

Kernal-Reference:

 LDA $91     : $F6ED
 LDY $91     : $E4E2
 STA $91     : $F6DA



 $92/146:   Timing Constant for Tape

Kernal-Reference:

 ADC $92     : $F99E
 LDA $92     : $F9D5
 STA $92     : $F9A0 $F9E2



 $93/147:   Flag: 0 = Load, 1 = Verify

Kernal-Reference:

 LDA $93     : $F5D4 $F72C $FADB $FB20 $FB3A
 LDY $93     : $F50C
 STA $93     : $F4A5 $F733 $F845



 $94/148:   Flag: Serial Bus - Output Character buffered

Kernal-Reference:

 BIT $94     : $ED12 $EDDD
 LSR $94     : $ED1C
 ROR $94     : $EDE2



 $95/149:   Buffered Character for Serial Bus

Kernal-Reference:

 ROR $95     : $ED71
 STA $95     : $ED21 $EDB9 $EDC7 $EDEB



 $96/150:   Cassette Sync number

Kernal-Reference:

 LDA $96     : $FA10 $FA33 $FA44
 STA $96     : $F9F3 $FA3B



 $97/151:   Temporary storage of X Register during CHRIN
 $97/151:   Temporary storage of Y Register during RS232 fetch

Kernal-Reference:

 LDX $97     : $F18F $F196
 LDY $97     : $F153
 STX $97     : $F179
 STY $97     : $F14E



 $98/152:   Number of Open Files/Index to File Table

Kernal-Reference:

 CPX $98     : $F2F5
 DEC $98     : $F2F3
 INC $98     : $F362
 LDX $98     : $F314 $F359
 LDY $98     : $F2F9
 STA $98     : $F331



 $99/153:   Default Input Device (0)

Kernal-Reference:

 CPX $99     : $F33C
 LDA $99     : $F13E $F157
 LDX $99     : $E663
 STA $99     : $E5A6 $F04D $F233 $F347



 $9A/154:   Default Output Device (3)

Kernal-Reference:

 CPX $9A     : $F335
 LDA $9A     : $F1CB
 LDX $9A     : $E669
 STA $9A     : $E5A2 $EFE1 $F275
 STX $9A     : $F343



 $9B/155:   Parity of Byte Output to Tape

  Used by Jiffy-DOS: KEYBYT

   Used only from Basic for Jiffy-DOS wedge comands, device
   toggle and function keys.

Kernal-Reference:

 EOR $9B     : $F9F8 $FC05
 LDA $9B     : $F9CE $FC4E
 STA $9B     : $F9FA $FBA1 $FC07



 $9C/156:   Flag: Byte received from Tape

Kernal-Reference:

 INC $9C     : $FA2D
 LDX $9C     : $F962
 STA $9C     : $F85C $FA63



 $9D/157:   Flag: $00 = Program mode: Suppress Error Messages
                  $40 = Kernal Error Messages only
                  $80 = Direct mode: Full Error Messages

Kernal-Reference:

 BIT $9D     : $F12B $F71B $F74C
 LDA $9D     : $F5AF $F68F
 STA $9D     : $FE18



 $9E/158:   Index to Cassette File name/Header ID for Tape write
 $9E/158:   Tape Error log pass 1

Kernal-Reference:

 CPX $9E     : $FAF1 $FB0A
 INC $9E     : $F7B1 $F803
 LDA $9E     : $F024 $F1F8 $F201 $F786 $FB60
 LDX $9E     : $FAF5
 LDY $9E     : $F7A5 $F807
 STA $9E     : $F1DD $F76A $F858
 STX $9E     : $FB03
 STY $9E     : $F7A3 $F7F5



 $9F/159:   Tape Error log pass 2

  Used by Jiffy-DOS: CJLA

   Used only from Basic for Jiffy-DOS wedge comands, device
   toggle and function keys.

Kernal-Reference:

 INC $9F     : $F7B3 $F805 $FB1C $FB1E
 LDX $9F     : $FB08
 LDY $9F     : $F7AD $F7FD
 STA $9F     : $F85A
 STY $9F     : $F79F $F7F1



 $A0-$A2/160-162:   Real-time jiffy Clock

   Updated by IRQ Interrupt approx every 1/60 of Second

   Update Routine is at $F69B

Kernal-Reference:

 BIT $00A0   : $AFE8
 INC $A0     : $F6A5
 LDA $A0     : $F6B0
 LDY $A0     : $F6E2
 STX $A0     : $F6B6
 STY $A0     : $F6E9

 CMP $A1     : $E4E7
 INC $A1     : $F6A1
 LDA $A1     : $F6AC $F761
 LDX $A1     : $F6E0
 STX $A1     : $F6B8 $F6E7

 BIT $00A2   : $A908
 INC $A2     : $F69D
 LDA $A2     : $F6DE
 STA $A2     : $F6E5
 STX $A2     : $F6BA



 $A3/163:   Bit Counter Tape Read or Write
            Serial Bus EOI (End Of Input) Flag

  Used by Jiffy-DOS: LDFLG/QFLAG

   Used in all disk access and Load routines.

  Used by ByteBoiler: Temporary

Kernal-Reference:

 BIT $A3     : $ED4C
 DEC $A3     : $FA00 $FC0E
 LDA $A3     : $F9C3 $FA18 $FC10
 LDX $A3     : $F969
 LSR $A3     : $ED1E
 ROR $A3     : $ED17
 STA $A3     : $FB99



 $A4/164:   Pulse Counter Tape Read or Write/Serial Bus shift Counter

  Used by ByteBoiler: Temporary

Kernal-Reference:

 LDA $A4     : $EE80 $F9A2 $FBF5
 ROR $A4     : $EE65
 STA $A4     : $F9A6 $F9BE $FB9D $FBF9



 $A5/165:   Tape Synchronising count down

Kernal-Reference:

 DEC $A5     : $ED8E $EE72 $FC22
 INC $A5     : $EE52
 LDA $A5     : $EE3E $FC1A
 STA $A5     : $ED64 $EE16 $EE58
 STX $A5     : $FC8D



 $A6/166:   Pointer: Tape I/O buffer

  Used by Jiffy-DOS: TFLAG

   Used only from Basic for Jiffy-DOS wedge comands, device
   toggle and function keys.

Kernal-Reference:

 DEC $A6     : $F18D
 INC $A6     : $F810
 LDY $A6     : $F812
 STA $A6     : $F1A5 $F3D1
 STY $A6     : $F1F6



 $A7/167:   RS232 temporary for received Bit/Tape temporary

  Used by Exomizer: Length of sequence

Kernal-Reference:

 DEC $A7     : $FB5C $FC71
 LDA $A7     : $EF63 $EF70 $EF90 $EFBC $FA99
 LDX $A7     : $FAD6
 LSR $A7     : $EF69
 STA $A7     : $FA6E $FC60 $FEDB



 $A8/168:   RS232 Input Bit count/Tape temporary

Kernal-Reference:

 ADC $A8     : $EF7A
 DEC $A8     : $EF5D $EF6E
 INC $A8     : $FBDA
 LDA $A8     : $FA57 $FBCD
 STA $A8     : $F98F $FA37 $FB9F
 STX $A8     : $FF2B



 $A9/169:   RS232 Flag: Start Bit check/Tape temporary

Kernal-Reference:

 BIT $00A9   : $AC0C $E167
 DEC $A9     : $F997
 INC $A9     : $F993 $FBEC
 LDA $A9     : $F9EB $FBE3
 LDX $A9     : $EF59
 ORA $A9     : $FA59
 STA $A9     : $EF89 $FBA3



 $AA/170:   RS232 Input Byte Buffer/Tape temporary

Kernal-Reference:

 BIT $AA     : $FA72
 DEC $AA     : $FAA9
 LDA $AA     : $EFA4 $EFDB
 ROR $AA     : $EF6B
 STA $AA     : $F852 $FA88 $FAA7 $FAAF $FABC $FB4A



 $AB/171:   RS232 Input parity/Tape temporary

Kernal-Reference:

 DEC $AB     : $FC78
 EOR $AB     : $EF65 $EFBE $FB74
 INC $AB     : $FC82
 LDA $AB     : $FB80
 STA $AB     : $EF67 $F7BC $F869 $FAB6 $FB76
 STY $AB     : $FB70



 $AC-$AD/172-173:   Pointer: Tape Buffer/Screen scrolling

Kernal-Reference:

 CMP ($AC),Y : $FAE3 $FB28
 INC $AC     : $FCDB
 LDA $AC     : $E8EA $E981 $E9E3 $F61A $FAFC $FB0E $FCD2
     ($AC),Y : $E9D4 $F629 $FB72 $FC41
 STA $AC     : $E90A $E962 $E99D $FB94
     ($AC),Y : $FB41

 INC $AD     : $FC37 $FCDF
 LDA $AD     : $E8ED $E984 $E9E7 $F61F $FAF7 $FB15 $FCD6
 STA $AD     : $E95F $E9CD $FB90



 $AE-$AF/174-175:   Tape End Address/End of Program

  Used by Exomizer: Source address

Kernal-Reference:

 CMP ($AE),Y : $F512
 INC $AE     : $F51E
 LDA $AE     : $E8F0 $E987 $F77A $F795
     ($AE),Y : $E9D8
 LDX $AE     : $F5AA
 SBC $AE     : $FCD4
 STA $AE     : $E95C $E9E5 $F4D8 $F4EA $F593 $F7C3 $F7E0
     ($AE),Y : $F51C
 STX $AE     : $F5DD

 INC $AF     : $F522
 LDA $AF     : $E8F3 $E98A $F777 $F79A
 LDY $AF     : $F5AC
 SBC $AF     : $FCD8
 STA $AF     : $E959 $E9ED $F4E3 $F4EE $F598 $F7C6 $F7E7
 STY $AF     : $F5DF



 $B0-$B1/176-177:   Tape timing Constants

  Used by Jiffy-DOS: SPRSAV ($B0)
  Used by Jiffy-DOS: RASSAV ($B1)

   Saved, then restored by Load routine (no other usage).

  Used by Jiffy-DOS: KEYPTR

   Used only from Basic for Jiffy-DOS wedge comands, device
   toggle and function keys.

Kernal-Reference:

 ADC $B0     : $F8E9 $F971 $F97A $F982 $FA26
 BIT $B0     : $F8F2
 DEC $B0     : $F9DB
 INC $B0     : $F9DE
 LDA $B0     : $F8E4 $F959
 STA $B0     : $F856

 ADC $B1     : $F8EC $F905
 ASL $B1     : $F8F7 $F8FA
 CMP $B1     : $F95E $F973 $F97C $F984
 LSR $B1     : $FA1F
 ROR $B1     : $F954 $F957
 SBC $B1     : $F94F $F99C $FA24
 STA $B1     : $F8EE
 STX $B1     : $F8E2 $F93A $F951



 $B2-$B3/178-179:   Pointer: Start Address of Tape Buffer

  Points to $033C

  Used by Jiffy-DOS: REGSAV ($B2)

   Saved, then restored by Load routine (no other usage).

Kernal-Reference:

 CMP ($B2),Y : $F7FF
 LDA ($B2),Y : $F1A9 $F56E $F573 $F57F $F588 $F739 $F757
 LDX $B2     : $F7D0
 SBC ($B2),Y : $F583 $F58C
 STA ($B2),Y : $F1F3 $F1FA $F3CE $F781 $F788 $F78D $F792 $F797 $F79C $F7AF
 STX $B2     : $FD63

 LDY $B3     : $F7D2
 STY $B3     : $FD65



 $B4/180:   RS232 Write bit count/Tape Read timing Flag

Kernal-Reference:

 DEC $B4     : $EECD $EEE7 $EEEE
 INC $B4     : $EEF2 $EF00
 LDA $B4     : $EEBB $F98B $F9AC $F9FC $FA14 $FA2F
 STA $B4     : $F854 $FA42 $FA4C
 STX $B4     : $EF1C



 $B5/181:   RS232 Next Bit to send/Tape Read - End of Tape

Kernal-Reference:

 LDA $B5     : $FA76 $FA91 $FAC0
 ORA $B5     : $FE80
 STA $B5     : $EED4 $EF17 $FA46



 $B6/182:   RS232 Output Byte Buffer/Tape Read Error Flag

Kernal-Reference:

 LDA $B6     : $FA95 $FAEB $FB2F $FBDC
 LSR $B6     : $EEC1
 ROR $B6     : $FBC9
 STA $B6     : $EF28 $FA5B $FAE9
 STX $B6     : $FC8F
 STY $B6     : $FB2D



 $B7/183:   Number of Characters in Filename

Kernal-Reference:

 CPY $B7     : $F402 $F40F $F5CD $F7A7 $F7F7
 LDA $B7     : $F3A1 $F3F6 $F549 $F5B8
 LDY $B7     : $F3D9 $F4B8 $F5C1 $F5FE
 STA $B7     : $FDF9



 $B8/184:   Current File - Logical File number

Kernal-Reference:

 LDA $B8     : $F364
 LDX $B8     : $F34A
 STA $B8     : $F322 $FE00



 $B9/185:   Current File - Secondary Address

Kernal-Reference:

 BIT $B9     : $F642
 LDA $B9     : $F23B $F27D $F2C8 $F2E0 $F369 $F393 $F3D5 $F3E6 $F4D0 $F579
               $F610 $F64B $F66E $F681
 LDX $B9     : $F22A $F26F $F4BF
 LDY $B9     : $F3C4
 STA $B9     : $F32C $F36D $F4C6 $F5FC
 STY $B9     : $FE04



 $BA/186:   Current File - First Address (Device number)

Kernal-Reference:

 LDA $BA     : $F219 $F25B $F29D $F372 $F3E1 $F4AB $F4CB $F5ED $F60B $F646
               $FE07
 STA $BA     : $F327
 STX $BA     : $FE02



 $BB-$BC/187-188:   Pointer: Current File name Address

Kernal-Reference:

 LDA ($BB),Y : $F3FC $F413 $F5C7 $F7AB $F7FB
 STX $BB     : $FDFB

 STY $BC     : $FDFD



 $BD/189:   RS232 Output Parity/Tape Byte temporary

Kernal-Reference:

 EOR $BD     : $EEC9 $FB82
 LDA $BD     : $EEE2 $EEF6 $FA9C $FAE1 $FB24 $FB3F $FBA6 $FBFD
 LSR $BD     : $FC0C
 STA $BD     : $EECB $EF15 $FA55 $FC01 $FC2C $FC3B $FC43 $FC52



 $BE/190:   Tape Input/Output Block count

  Used by Jiffy-DOS: DRVBYT

   Used only from Basic for Jiffy-DOS wedge comands, device
   toggle and function keys.

Kernal-Reference:

 DEC $BE     : $FC57
 LDA $BE     : $FA6A $FC84
 LDX $BE     : $FA7A $FB55 $FC24
 STA $BE     : $F8A6 $FB64
 STX $BE     : $FB5A



 $BF/191:   Serial Word Buffer

  Used by Jiffy-DOS: DEST

   Used only from Basic for Jiffy-DOS wedge comands, device
   toggle and function keys.

Kernal-Reference:

 LDA $BF     : $FA53
 ROR $BF     : $FA06



 $C0/192:   Tape Motor Switch

Kernal-Reference:

 LDA $C0     : $EA71
 STA $C0     : $F8B1
 STY $C0     : $EA69



 $C1-$C2/193-194:   Start Address for LOAD and Cassette Write

Kernal-Reference:

 CMP ($C1),Y : $FD75 $FD7C
 LDA $C1     : $F774 $F78B $FB92
     ($C1),Y : $FD6E
 STA $C1     : $F59C $F5E4 $F7C9 $F7DB
     ($C1),Y : $FD73 $FD7A $FD81

 INC $C2     : $FD6C
 LDA $C2     : $F771 $F790 $FB8E
 LDY $C2     : $FD8A
 STA $C2     : $F5A0 $F5E8 $F7CC $F7E3 $FD6A



 $C3-$C4/195-196:   Pointer: Type 3 Tape LOAD and general use

  Used by ByteBoiler: Temporary

Kernal-Reference:

 ADC $C3     : $F591
 LDA $C3     : $F4E8 $F59A
     ($C3),Y : $FD25
 STA $C3     : $F570
     ($C3),Y : $FD27
 STX $C3     : $F49E $FD1A

 ADC $C4     : $F596
 LDA $C4     : $F4EC $F59E
 STA $C4     : $F575
 STY $C4     : $F4A0 $FD1C



 $C5/197   : Current Key pressed
 $CB/203

  +------------------------------------+-----------------------------------+
  | $00/0  = 'INST/DEL'                | $20/32 = '9 )'                    |
  | $01/1  = 'CR'                      | $21/33 = 'I'                      |
  | $02/2  = (Cursor left/right)       | $22/34 = 'J'                      |
  | $03/3  = 'F7'                      | $23/35 = '0'                      |
  | $04/4  = 'F1'                      | $24/36 = 'M'                      |
  | $05/5  = 'F3'                      | $25/37 = 'K'                      |
  | $06/6  = 'F5'                      | $26/38 = 'O'                      |
  | $07/7  = (Cursor up/down)          | $27/39 = 'N'                      |
  | $08/8  = '3 #'                     | $28/40 = '+'                      |
  | $09/9  = 'W'                       | $29/41 = 'P'                      |
  | $0A/10 = 'A'                       | $2A/42 = 'L'                      |
  | $0B/11 = '4 $'                     | $2B/43 = '-'                      |
  | $0C/12 = 'Z'                       | $2C/44 = '. >'                    |
  | $0D/13 = 'S'                       | $2D/45 = ': ['                    |
  | $0E/14 = 'E'                       | $2E/46 = '@'                      |
  | $0F/15 = Unused                    | $2F/47 = ', <'                    |
  | $10/16 = '5 %'                     | $30/48 = '(Pound)'                |
  | $11/17 = 'R'                       | $31/49 = '*'                      |
  | $12/18 = 'D'                       | $32/50 = '; ]'                    |
  | $13/19 = '6 &'                     | $33/51 = 'CLR/HOME'               |
  | $14/20 = 'C'                       | $34/52 = Unused                   |
  | $15/21 = 'F'                       | $35/53 = '='                      |
  | $16/22 = 'T'                       | $36/54 = (Up Arrow/Pi)            |
  | $17/23 = 'X'                       | $37/55 = '? /'                    |
  | $18/24 = '7 ''                     | $38/56 = '1 !'                    |
  | $19/25 = 'Y'                       | $39/57 = (Left Arrow)             |
  | $1A/26 = 'G'                       | $3A/58 = Unused                   |
  | $1B/27 = '8 ('                     | $3B/59 = '2 "'                    |
  | $1C/28 = 'B'                       | $3C/60 = ' ' (Space)              |
  | $1D/29 = 'H'                       | $3D/61 = Unused                   |
  | $1E/30 = 'U'                       | $3E/62 = 'Q'                      |
  | $1F/31 = 'V'                       | $3F/63 = 'RUN/STOP'               |
  +------------------------------------+                                   |
                                       | $40/64 = No Key pressed           |
                                       +-----------------------------------+

Kernal-Reference:

 CPY $C5     : $EAE5
 STY $C5     : $EB28

 LDY $CB     : $EAE0 $EB26
 STY $CB     : $EA8E $EAC9



 $C6/198:   Number of Characters in Keyboard Buffer queue

Kernal-Reference:

 CPX $C6     : $E5C0
 DEC $C6     : $E5C4
 LDA $C6     : $E5CD $F142
 LDX $C6     : $EB35
 LDY $C6     : $EB21
 STA $C6     : $F6F7
 STX $C6     : $E5F1 $EB40
 STY $C6     : $E954



 $C7/199:   Flag: Reverse On/Off; On = $01, Off = $00

Kernal-Reference:

 LDX $C7     : $E693
 STA $C7     : $E789 $E852
 STX $C7     : $E895



 $C8/200:   Pointer: End of Line for Input

   Used to suppress trailing spaces

Kernal-Reference:

 CMP $C8     : $E62C
 CPY $C8     : $E659
 STA $C8     : $F16E
 STY $C8     : $E610



 $C9-$CA/201-202:   Cursor X/Y (Line/Column) position at start of Input

Kernal-Reference:

 CPX $C9     : $E591 $E624
 DEC $C9     : $E8FA
 LDA $C9     : $E61B
 LSR $C9     : $E87C
 STA $C9     : $F161

 LDA $CA     : $E628
 STA $CA     : $F15D



 $CC/204:   Flag: Cursor blink; $00 = Enabled, $01 = Disabled

Kernal-Reference:

 LDA $CC     : $EA34
 STA $CC     : $E542 $E5CF



 $CD/205:   Timer: Count down for Cursor blink toggle

Kernal-Reference:

 DEC $CD     : $EA38
 STA $CD     : $E540 $EA16 $EA3E



 $CE/206:   Character under Cursor while Cursor Inverted

Kernal-Reference:

 LDA $CE     : $E5DB $EA5A
 STA $CE     : $EA4D



 $CF/207:   Flag: Cursor Status; $00 = Off, $01 = On

Kernal-Reference:

 INC $CF     : $EA4B
 LDA $CF     : $E5D7
 LSR $CF     : $EA42
 STA $CF     : $E520
 STY $CF     : $E5E2



 $D0/208:   Flag: Input from Screen = $03, Keyboard = $00

Kernal-Reference:

 LDA $D0     : $E636
 STA $D0     : $E65F $E71F $F16A
 STY $D0     : $E604



 $D1-$D2/209-210:   Pointer: Current Screen Line Address

Kernal-Reference:

 LDA $D1     : $EA24
     ($D1),Y : $E606 $E63C $E763 $E7F4 $E80B $EA47
 STA $D1     : $E9F3
     ($D1),Y : $E766 $E775 $E80E $E81D $E9D6 $EA0C $EA1E

 LDA $D2     : $EA28
 STA $D2     : $E9FC



 $D3/211:   Cursor Column on current Line, including Wrap-round Line, if any

Kernal-Reference:

 CMP $D3     : $E6BD $E8A5 $E8B7
 CPY $D3     : $E7FA $E817
 INC $D3     : $E654 $E6B9
 LDA $D3     : $E56E $E83C $F15B
 LDY $D3     : $E515 $E63A $E721 $EA1C $EA40
 STA $D3     : $E577 $E62A $E6FE $E7C4 $E843
 STX $D3     : $E705 $E899
 STY $D3     : $E50E $E568 $E617 $E713 $E75D $E79A $E7A8 $E85F



 $D4/212:   Flag: Editor in Quote Mode; $00 = Not

Kernal-Reference:

 LDA $D4     : $E688
 LDX $D4     : $E64C $E77E $E7EA
 LSR $D4     : $E6AE
 STA $D4     : $E68C
 STX $D4     : $E897
 STY $D4     : $E619



 $D5/213:   Current logical Line length: 39 or 79

Kernal-Reference:

 CMP $D5     : $E7B8
 CPY $D5     : $E76F $E79D
 LDA $D5     : $E6BB $E6E6 $F16C
 LDY $D5     : $E602 $E711 $E7F2 $E805
 STA $D5     : $E58C $E6EB



 $D6/214:   Current Screen Line number of Cursor

Kernal-Reference:

 DEC $D6     : $E6D6 $E6F7 $E7A1 $E7BE $E83A $E8B0 $E8F8 $E97C
 INC $D6     : $E7B6 $E8C8 $E933
 LDA $D6     : $F15F
 LDX $D6     : $E513 $E56C $E61F $E6CD $E6D8 $E701 $E836 $E87E $E8C2 $E956
               $E965
 STX $D6     : $E50C $E70C $E88C
 STY $D6     : $E56A



 $D7/215:   Screen value of current Input Character/Last Character Output

Kernal-Reference:

 ASL $D7     : $E642
 BIT $D7     : $E644
 CPX $D7     : $F9E4
 EOR $D7     : $FC45
 LDA $D7     : $E67A $E723 $FC39
 LSR $D7     : $FA04
 STA $D7     : $E63E $E674 $E717 $FC47
 STX $D7     : $F9AA $FC20



 $D8/216:   Count of number of inserts outstanding

Kernal-Reference:

 DEC $D8     : $E69D
 INC $D8     : $E824
 LDA $D8     : $E6AA
     $D8,X   : $E99F
 LDX $D8     : $E699 $E745 $E829
 STX $D8     : $E893



 $D9-$F2/217-242:   Screen Line Link Table

  Used by ByteBoiler: Depacker ($F0-$F2)

Kernal-Reference:

 ASL $D9,X   : $E6DA
 LDA $D9     : $E92F
     $D9,X   : $E6DF $E6ED $E888 $E918 $E968 $E9F5
 LDY $D9,X   : $E570 $E582 $E9B4
 LSR $D9,X   : $E6DC
 STA $D9,X   : $E55C $E6E3 $E922
 STY $D9,X   : $E54D

 LDA $DA,X   : $E90C $E9B0
 LDY $DA,X   : $E91C
 STA $DA,X   : $E9BA

 LDA $F1     : $E929
 STA $F1     : $E92D



 $F3-$F4/243-244:   Pointer: Current Color RAM Location

  Used by ByteBoiler: Depacker

Kernal-Reference:

 LDA ($F3),Y : $E769 $E811 $EA52
 STA $F3     : $EA26
     ($F3),Y : $E4DD $E76C $E77A $E814 $E822 $E9DA $EA21

 STA $F4     : $EA2E



 $F5-$F6/245-246:   Vector: Current Keyboard decoding Table

   Points to $EB81

  Used by ByteBoiler: Depacker

Kernal-Reference:

 LDA ($F5),Y : $EAB7 $EAE2
 STA $F5     : $EA9D $EB6F

 STA $F6     : $EAA1 $EB74



 $F7-$F8/247-248:   RS232 Input Buffer Pointer

  Used by pucrunch: Bit-Stream, Escape Code

  Used by ByteBoiler: Depacker

Kernal-Reference:

 LDA ($F7),Y : $F096
 STA ($F7),Y : $EFB1
 STX $F7     : $F472

 LDA $F8     : $F2B5 $F46B
 STA $F8     : $F2C1
 STY $F8     : $F470



 $F9-$FA/249-250:   RS232 Output Buffer Pointer

  Used by pucrunch: Depacker - Part 1
                              ($FA = destination address lo)

  Used by ByteBoiler: Depacker

Kernal-Reference:

 LDA ($F9),Y : $EF26
 STA ($F9),Y : $F026
 STX $F9     : $F47B

 LDA $FA     : $F2BA $F474
 STA $FA     : $F2C3
 STY $FA     : $F479



 $FB-$FE/251-254:   Free ZeroPage space for User Programs

  Used by pucrunch: Depacker - Part 1
                              ($FB = destination address hi)

  Used by ByteBoiler: Depacker

  Used by The Cruncher AB: Temporary

  Used by Exomizer: Bit buffers, Destination address lo ($FE)



 $FF/255:   BASIC temporary Data Area
 $FF-$010A/255-266:   Assembly Area for Floating point to ASCII
                              conversion

  Used by pucrunch: Depacker - Part 1

  Used by ByteBoiler: Depacker

  Used by The Cruncher AB: Temporary

  Used by Exomizer: Destination address hi

Kernal-Reference:

 LDA $00FF,Y : $BEC6
 STA $00FF,Y : $BDE7 $BE58 $BE61 $BEA5 $BEAF $BF04



 $0100-$01FF/256-511:   6510 Hardware Stack Area
 $0100-$013E/256-318:   Tape Input Error log

  Used by pucrunch: Depacker - Part 1  ($0100 - $01E0)

  Used by ByteBoiler: Depacker ($0100 - $01EF)

  Used by Exomizer: Depacker - main code ($0100 - $01BA)

Kernal-Reference:

 CMP $0100,X : $FB10
 STA $0100,X : $FAFE
     $0100,Y : $BEE8 $BF09

 CMP $0101,X : $FB17
 LDA $0101,X : $A38F $B1F3
 STA $0101,X : $B1FE $FAF9
     $0101,Y : $BEE3

 CMP $0102,X : $A3AB
 LDA $0102,X : $A39A $B1EF
 STA $0102,X : $B1F9
     $0102,Y : $BEFA

 CMP $0103,X : $A3A4
 LDA $0103,X : $A39F
 STA $0103,Y : $BEF6

 LDA $0104,X : $FF4E
 STA $0104,Y : $BEFF

 LDA $0109,X : $AD46
 SBC $0109,X : $AD5C

 LDA $010F,X : $AD61

 LDA $0110,X : $AD66

 LDA $0111,X : $AD70

 LDA $0112,X : $AD6B



 $013F-$01FF/319-511:   BASIC Stack Area

Kernal-Reference:

 LDA $01FB,Y : $A5CE
 STA $01FB,Y : $A5CB $A5EF

 LDA $01FC,Y : $A522
 STX $01FC   : $E3FB

 STA $01FD,Y : $A609
 STX $01FD   : $E3F8

 STA $01FE   : $A511

 STA $01FF   : $ABD3
 STY $01FF   : $A514



 $0200-$0258/512-600:   BASIC Input Buffer (Input Line from Screen)

  Used by pucrunch: Depacker - Part 2  ($0200 - $0258)
                              ($0202+$0203 = source address)

Kernal-Reference:

 LDA $0200   : $A4F3 $ABEA
     $0200,X : $A582 $A5B8 $A5E5 $A604
 STA $0200   : $AC38
     $0200,X : $A569 $AACC
     $0200,Y : $FD56

 STA $0201   : $AB98



 $0259-$0262/601-610:   Active logical File numbers

Kernal-Reference:

 CMP $0259,X : $F319
 LDA $0259,X : $F31F
     $0259,Y : $F2FB
 STA $0259,X : $F2FE $F366



 $0263-$026C/611-620:   Active File First Addresses (Device numbers)

Kernal-Reference:

 LDA $0263,X : $F324
     $0263,Y : $F301
 STA $0263,X : $F304 $F374



 $026D-$0276/621-630:   Active File Secondary Addresses

Kernal-Reference:

 LDA $026D,X : $F329
     $026D,Y : $F307
 STA $026D,X : $F30A $F36F

 STA $0276,X : $E5F6



 $0277-$0280/631-640:   Keyboard Buffer Queue (FIFO)

Kernal-Reference:

 LDY $0277   : $E5B4
 STA $0277,X : $E5BC $EB3C

 LDA $0278,X : $E5B9



 $0281-$0282/641-642:   Pointer: Bottom of Memory for Operating System

   Default Value is $0800

Kernal-Reference:

 LDX $0281   : $FE36
 STX $0281   : $FE3C

 LDY $0282   : $FE39
 STA $0282   : $FD92
 STY $0282   : $FE3F



 $0283-$0284/643-644:   Pointer: Top of Memory for Operating System

   Default Value is $A000

Kernal-Reference:

 LDX $0283   : $FE27
 STX $0283   : $FE2D

 LDY $0284   : $FE2A
 STY $0284   : $FE30



 $0285/645:   Serial IEEE Bus timeout defeat Flag

Kernal-Reference:

 STA $0285   : $FE21



 $0286/646:   Current Character Color code

Kernal-Reference:

 LDA $0286   : $E4DA $E777 $E81F
 LDX $0286   : $E69F $EA57
 STA $0286   : $E536
 STX $0286   : $E8D6



 $0287/647:   Background Color under Cursor

Kernal-Reference:

 LDX $0287   : $E5DD $EA44
 STA $0287   : $EA54



 $0288/648:   High Byte of Screen Memory Address

   Default Value is $04

Kernal-Reference:

 LDA $0288   : $E544
 ORA $0288   : $E9CA $E9F9
 STA $0288   : $FD97



 $0289/649:   Maximum number of Bytes in Keyboard Buffer

   Default Value is $0A

Kernal-Reference:

 CPX $0289   : $EB37
 STA $0289   : $E52E



 $028A/650:   Flag: Repeat keys:

   $00 = Cursors, INST/DEL & Space repeat    (Default)
   $40 = no Keys repeat
   $80 = all Keys repeat

Kernal-Reference:

 BIT $028A   : $EAF2



 $028B/651:   Repeat Key: Speed Counter

   Default Value is $04

Kernal-Reference:

 DEC $028B   : $EB17



 $028C/652:   Repeat Key: First repeat delay Counter

   Default Value is $10

Kernal-Reference:

 DEC $028C   : $EB12
 LDY $028C   : $EB0D
 STA $028C   : $E531
 STY $028C   : $EAEB



 $028D/653:   Flag: Shift Keys

   +-------+--------------------------------------------------------+
   | Bit 2 |  1 = CTRL pressed                                      |
   | Bit 1 |  1 = CBM pressed                                       |
   | Bit 0 |  1 = Shift pressed                                     |
   +-------+--------------------------------------------------------+

Kernal-Reference:

 LDA $028D   : $EB48
 LDY $028D   : $EB2A
 ORA $028D   : $EAC1
 STA $028D   : $EA89 $EAC4



 $028E/654:   Last Shift Key used for debouncing

Kernal-Reference:

 CMP $028E   : $EB4F
 STY $028E   : $EB2D



 $028F-$0290/655-656:   Vector: Routine to determine Keyboard table
                                to use based on Shift Key Pattern

   Points to $EB48

Kernal-Reference:

 JMP ($028F) : $EADD
 STA $028F   : $E524

 STA $0290   : $E529



 $0291/657:   Flag: Upper/Lower Case change

   $00 = Enabled    (Default)
   $80 = Disabled

Kernal-Reference:

 AND $0291   : $EC6F
 LDA $0291   : $EB54
 ORA $0291   : $EC64
 STA $0291   : $E51D $EC72



 $0292/658:   Flag: Auto scroll down

   $00 = Disabled    (Default)

Kernal-Reference:

 LDA $0292   : $E6C5
 STA $0292   : $E5D1
 STY $0292   : $E614



 $0293/659:   RS232 Pseudo 6551 control Register Image

Kernal-Reference:

 BIT $0293   : $EF4E
 LDA $0293   : $EEE9 $EF74 $F423
 STA $0293,Y : $F415



 $0294/660:   RS232 Pseudo 6551 command Register Image

Kernal-Reference:

 BIT $0294   : $EED9 $EFB5
 LDA $0294   : $EF06 $EFE3 $F04F $F44D



 $0295-$0296/661-662:   RS232 Non-standard Bits/Second

Kernal-Reference:

 LDA $0295   : $F446 $FF07
 STA $0295   : $F443

 LDA $0296   : $FF0D $FF2F
 STY $0296   : $F440



 $0297/663:   RS232 Pseudo 6551 Status Register Image

Kernal-Reference:

 LDA $0297   : $F086 $F1C1 $FE0D
 ORA $0297   : $EF33 $EFD2
 STA $0297   : $EF36 $EFD5 $F00F $F093 $F09E $FE13
 STY $0297   : $F40C



 $0298/664:   RS232 Number of Bits left to send

Kernal-Reference:

 LDX $0298   : $EF19 $EFA6 $FF28
 STX $0298   : $F420



 $0299-$029A/665-666:   RS232 Baud Rate; Full Bit time microseconds

Kernal-Reference:

 ADC $0299   : $FEE2
 LDA $0299   : $F033
 STA $0299   : $FF37

 ADC $029A   : $FEEB
 LDA $029A   : $F039
 STA $029A   : $FF3D



 $029B/667:   RS232 Index to End of Input Buffer

Kernal-Reference:

 CPY $029B   : $F08C
 LDA $029B   : $F45C
 LDY $029B   : $EF97
 STY $029B   : $EFA0



 $029C/668:   RS232 Pointer: High Byte of Address of Input Buffer

Kernal-Reference:

 CPY $029C   : $EF9B
 INC $029C   : $F098
 LDY $029C   : $F089
 STA $029C   : $F45F



 $029D/669:   RS232 Pointer: High Byte of Address of Output Buffer

Kernal-Reference:

 CPY $029D   : $F01B
 INC $029D   : $EF2A
 LDY $029D   : $EF1E
 STA $029D   : $F465



 $029E/670:   RS232 Index to End of Output Buffer

Kernal-Reference:

 CPY $029E   : $EF21
 LDA $029E   : $F462
 LDY $029E   : $F017
 STY $029E   : $F020



 $029F-$02A0/671-672:   Temporary store for IRQ Vector during Tape
                        operations

Kernal-Reference:

 LDA $029F   : $FCB0
 STA $029F   : $F898

 LDA $02A0   : $F8BE $FCA8
 STA $02A0   : $F89E $F8DE



 $02A1/673:   RS232 Enables

Kernal-Reference:

 AND $02A1   : $FE73
 EOR $02A1   : $EF3E $FF1A
 LDA $02A1   : $EFF2 $F028 $F062 $F07D $F0A5 $F0AA $FE85 $FEB6 $FEF6
 ORA $02A1   : $EF83
 STA $02A1   : $EF43 $EF86 $F0B8 $FF1D
 STY $02A1   : $F49A



 $02A2/674:   TOD sense during Tape I/O

Kernal-Reference:

 LDA $02A2   : $F911
 STA $02A2   : $F887



 $02A3/675:   Temporary storage during Tape READ

Kernal-Reference:

 LDA $02A3   : $F9B0
 STA $02A3   : $F94B



 $02A4/676:   Temporary D1IRQ Indicator during Tape READ

Kernal-Reference:

 LDA $02A4   : $F9B7
 STA $02A4   : $F917 $F9C0



 $02A5/677:   Temporary for Line Index

Kernal-Reference:

 CPX $02A5   : $E993 $E9AB
 DEC $02A5   : $E8FC
 INC $02A5   : $E935
 LDX $02A5   : $E978 $E9BF
 STX $02A5   : $E96C



 $02A6/678:   Flag: TV Standard: $00 = NTSC, $01 = PAL

Kernal-Reference:

 LDA $02A6   : $F42C $FDDD
 STA $02A6   : $FF68



 $02A7-$02FF/679-767:   Unused



 $02C0-$02FE/704-766:   Sprite #11 Data Area



 $0300-$0301/768-769:   Vector: BASIC Error Message

   Points to $E38B

   X-register holds number of error message

Kernal-Reference:

 JMP ($0300) : $A437 $E388
 STA $0300,X : $E458
     $0300,Y : $FD59



 $0302-$0303/770-771:   Vector: BASIC Input Line and Decode

   Points to $A483
   Modified by AR6 (goes to $DF01)
   Modified by FC3 (goes to $DE41)

Kernal-Reference:

 JMP ($0302) : $A480



 $0304-$0305/772-773:   Vector: BASIC Tokenise Routine

   Points to $A57C
   Modified by FC3 (goes to $DF8D)

Kernal-Reference:

 JMP ($0304) : $A579



 $0306-$0307/774-775:   Vector: BASIC LIST Routine

   Points to $A71A
   Modified by FC3 (goes to $DE49)

Kernal-Reference:

 JMP ($0306) : $A717



 $0308-$0309/776-777:   Vector: BASIC Character dispatch Routine

   Points to $A7E4
   Modified by FC3 (goes to $DE73)

Kernal-Reference:

 JMP ($0308) : $A7E1



 $030A-$030B/778-779:   Vector: BASIC Token evaluation

   Points to $AE86
   Modified by AR6 (goes to $DFB1)
   Modified by FC3 (goes to $DE4F)

Kernal-Reference:

 JMP ($030A) : $AE83



 $030C/780:   Storage for 6510 Accumulator during SYS

Kernal-Reference:

 LDA $030C   : $E13A
 STA $030C   : $E148



 $030D/781:   Storage for 6510 X-Register during SYS

Kernal-Reference:

 LDX $030D   : $E13D
 STX $030D   : $E14B



 $030E/782:   Storage for 6510 Y-Register during SYS

Kernal-Reference:

 LDY $030E   : $E140
 STY $030E   : $E14E



 $030F/783:   Storage for 6510 Status Register during SYS

Kernal-Reference:

 LDA $030F   : $E136
 STA $030F   : $E152



 $0310/784:   USR Function JMP Instruction ($4C)

Kernal-Reference:

 STA $0310   : $E3C3



 $0311-$0312/785-786:   USR Address ($LB,$MB)

Kernal-Reference:

 STA $0311   : $E3CA

 STY $0312   : $E3CD



 $0313/787:   Unused



 $0314-$0315/788-789:   Vector: Hardware IRQ Interrupt Address

   Points to $EA31

Kernal-Reference:

 LDA $0314   : $F895
     $0314,Y : $FD20
 STA $0314   : $FCB3 $FCC0
     $0314,Y : $FD29

 CMP $0315   : $F8C1
 LDA $0315   : $F89B
 STA $0315   : $FCAD $FCC6

Kernal-Reference:

 JMP ($0314) : $FF58



 $0316-$0317/790-791:   Vector: BRK Instruction Interrupt Address

   Points to $FE66
   Modified by AR6 (goes to $DFCD)

Kernal-Reference:

 JMP ($0316) : $FF55



 $0318-$0319/792-793:   Vector: Hardware NMI Interrupt Address

   Points to $FE47

Kernal-Reference:

 JMP ($0318) : $FE44



 $031A-$031B/794-795:   Vector: Kernal OPEN Routine

   Points to $F34A

Kernal-Reference:

 JMP ($031A) : $FFC0



 $031C-$031D/796-797:   Vector: Kernal CLOSE Routine

   Points to $F291

Kernal-Reference:

 JMP ($031C) : $FFC3



 $031E-$031F/798-799:   Vector: Kernal CHKIN Routine

   Points to $F20E

Kernal-Reference:

 JMP ($031E) : $FFC6



 $0320-$0321/800-801:   Vector: Kernal CHKOUT Routine

   Points to $F250

Kernal-Reference:

 JMP ($0320) : $FFC9



 $0322-$0323/802-803:   Vector: Kernal CLRCHN Routine

   Points to $F333

Kernal-Reference:

 JMP ($0322) : $FFCC



 $0324-$0325/804-805:   Vector: Kernal CHRIN Routine

   Points to $F157

Kernal-Reference:

 JMP ($0324) : $FFCF



 $0326-$0327/806-807:   Vector: Kernal CHROUT Routine

   Points to $F1CA

Kernal-Reference:

 JMP ($0326) : $FFD2



 $0328-$0329/808-809:   Vector: Kernal STOP Routine

   Points to $F6ED

Kernal-Reference:

 JMP ($0328) : $FFE1



 $032A-$032B/810-811:   Vector: Kernal GETIN Routine

   Points to $F13E

Kernal-Reference:

 JMP ($032A) : $FFE4



 $032C-$032D/812-813:   Vector: Kernal CLALL Routine

   Points to $F32F

Kernal-Reference:

 JMP ($032C) : $FFE7



 $032E-$032F/814-815:   User Defined Vector

   Points to $FE66



 $0330-$0331/816-817:   Vector: Kernal LOAD Routine

   Points to $F4A5
   Modified by AR6 (goes to $DF6D)
   Modified by FC3 (goes to $DE21)

Kernal-Reference:

 JMP ($0330) : $F4A2



 $0332-$0333/818-819:   Vector: Kernal SAVE Routine

   Points to $F5ED
   Modified by AR6 (goes to $DF6F)
   Modified by FC3 (goes to $DE35)

Kernal-Reference:

 JMP ($0332) : $F5EA



 $0334-$033B/820-827:   Unused

  Used by Exomizer: Depacker - tables ($0334 - $03CF)



 $033C-$03FB/828-1019:   Tape I/O Buffer

  Used by Exomizer: Depacker - tables ($0334 - $03CF)



 $0340-$037E/832-894:   Sprite #13



 $0380-$03BE/896-958:   Sprite #14



 $03C0-$03FE/960-1022:   Sprite #15



 $03FC-$03FF/1020-1023:   Unused



  +------------------------------------------------------------------------
  |
  |      BASIC ROM LISTING
  |
  +------------------------------------------------------------------------
  |
  | BASIC related topics:
  |
  |   CHR$/ASC-Table for Upper Case/Graphics
  |   CHR$/ASC-Table for Lower Case/Upper Case
  |
  |
  |   $A000/40960      Restart Vectors
  |   $A004/40964      'CBMBASIC'-Identifier
  |   $A00C/40972      BASIC Command Vectors - 1
  |   $A052/41042      BASIC Function Vectors
  |   $A080/41088      BASIC Operator Vectors
  |   $A09E/41118      BASIC Command Keyword Table
  |   $A129/41257      BASIC Misc. Keyword Table
  |   $A140/41280      BASIC Operator Keyword Table
  |   $A14D/41293      BASIC Function Keyword Table
  |   $A19E/41374      Error Message Table
  |   $A328/41768      Error Message Pointers
  |   $A364/41828      Misc. Messages
  |   $A38A/41866      Find FOR/GOSUB Entry on Stack
  |   $A3B8/41912      Open Space in Memory
  |   $A3FB/41979      Check Stack Depth
  |   $A408/41992      Check Memory Overlap
  |   $A435/42037      Output ?OUT OF MEMORY Error
  |   $A437/42039      Error Routine
  |   $A469/42089      Break Entry
  |   $A474/42100      Restart BASIC
  |   $A480/42112      Input & Identify BASIC Line
  |   $A49C/42140      Get Line Number & Tokenise Text
  |   $A4A2/42146      Insert BASIC Text
  |   $A533/42291      Rechain Lines
  |   $A560/42336      Input Line Into Buffer
  |   $A579/42361      Tokenise Input Buffer
  |   $A613/42515      Search for Line Number
  |   $A642/42562      Perform [new]
  |   $A65E/42590      Perform [clr]
  |   $A68E/42638      Reset TXTPTR
  |   $A69C/42652      Perform [list]
  |   $A717/42775      Handle LIST Character
  |   $A742/42818      Perform [for]
  |   $A7AE/42926      BASIC Warm Start
  |   $A7C4/42948      Check End of Program
  |   $A7E1/42977      Prepare to execute statement
  |   $A7ED/42989      Perform BASIC Keyword
  |   $A81D/43037      Perform [restore]
  |   $A82C/43052      Perform [stop]
  |   $A82F/43055      Perform [end]
  |   $A831/43057      Perform Break
  |   $A857/43095      Perform [cont]
  |   $A871/43121      Perform [run]
  |   $A883/43139      Perform [gosub]
  |   $A8A0/43168      Perform [goto]
  |   $A8D2/43218      Perform [return]
  |   $A8F8/43256      Perform [data]
  |   $A906/43270      Search for Next Statement / Line
  |   $A928/43304      Perform [if]
  |   $A93B/43323      Perform [rem]
  |   $A94B/43339      Perform [on]
  |   $A96B/43371      Fetch linnum From BASIC
  |   $A9A5/43429      Perform [let]
  |   $A9C4/43460      Assign Integer
  |   $A9D6/43478      Assign Floating Point
  |   $A9D9/43481      Assign String
  |   $A9E3/43491      Assign TI$
  |   $AA2C/43564      Add Digit to FAC#1
  |   $AA80/43648      Perform [print#]
  |   $AA86/43654      Perform [cmd]
  |   $AA9A/43674      Print String From Memory
  |   $AAA0/43680      Perform [print]
  |   $AAB8/43704      Output Variable
  |   $AACA/43722      -Add zero terminator to string
  |   $AAD7/43735      Output CR/LF
  |   $AAE8/43752      Handle comma, TAB(, SPC(
  |   $AB1E/43806      Output String
  |   $AB3B/43835      Output Format Character
  |   $AB4D/43853      Handle Bad Data
  |   $AB7B/43899      Perform [get]
  |   $ABA5/43941      Perform [input#]
  |   $ABBF/43967      Perform [input]
  |   $ABEA/44010      Read Input Buffer
  |   $ABF9/44025      Do Input Prompt
  |   $AC06/44038      Perform [read]
  |   $AC35/44085      General Purpose Read Routine
  |   $ACFC/44284      Input Error Messages
  |   $AD1E/44318      Perform [next]
  |   $AD61/44385      Check Valid Loop
  |   $AD8A/44426      Confirm Result
  |   $AD9E/44446      Evaluate Expression in Text
  |   $AE83/44675      Evaluate Single Term
  |   $AEA8/44712      Constant - pi
  |   $AEAD/44717      Continue Expression
  |   $AEF1/44785      Expression in Brackets
  |   $AEF7/44791      Test ')'
  |   $AEFA/44794      Test '('
  |   $AEFD/44797      Test ','
  |   $AF08/44808      Output ?SYNTAX Error
  |   $AF0D/44813      Set up NOT Function
  |   $AF14/44820      Identify Reserved Variable
  |   $AF28/44840      Search for Variable
  |   $AF48/44872      Convert TI to ASCII String
  |   $AFA7/44967      Identify Function Type
  |   $AFB1/44977      Evaluate String Function
  |   $AFD1/45009      Evaluate Numeric Function
  |   $AFE6/45030      Perform [or], [and]
  |   $B016/45078      Perform <, =, >
  |   $B01B/45083      Numeric Comparison
  |   $B02E/45102      String Comparison
  |   $B07E/45182      Perform [dim]
  |   $B08B/45195      Identify Variable
  |   $B0E7/45287      Locate Ordinary Variable
  |   $B113/45331      Does A hold an alphabetic character?
  |   $B11D/45341      Create New Variable
  |   $B128/45352      Create Variable
  |   $B194/45460      Allocate Array Pointer Space
  |   $B1A5/45477      Constant 32768 in Flpt
  |   $B1AA/45482      FAC#1 to Integer in A/Y
  |   $B1B2/45490      Evaluate Text for Integer
  |   $B1BF/45503      FAC#1 to Positive Integer
  |   $B1D1/45521      Get Array Parameters
  |   $B218/45592      Find Array
  |   $B245/45637      ?BAD SUBSCRIPT
  |   $B248/45640      ?ILLEGAL QUANTITY
  |   $B24D/45645      ?REDIM'D ARRAY
  |   $B261/45665      Create Array
  |   $B30E/45838      Locate Element in Array
  |   $B34C/45900      Number of Bytes in Subscript
  |   $B37D/45949      Evaluate <fre>
  |   $B391/45969      Convert Integer in (AC/YR) to Flpt
  |   $B39E/45982      Evaluate <pos>
  |   $B3A6/45990      Confirm Program Mode
  |   $B3AE/45998      ?UNDEF'D FUNCTION
  |   $B3B3/46003      Perform [def fn]
  |   $B3E1/46049      Check Syntax of FN
  |   $B3F4/46068      Perform [fn]
  |   $B465/46181      Evaluate <str$>
  |   $B487/46215      Set Up String
  |   $B4D5/46293      Save String Descriptor
  |   $B4F4/46324      Allocate Space for String
  |   $B526/46374      Garbage Collection
  |   $B5BD/46525      Search for Next String
  |   $B606/46598      Collect a String
  |   $B63D/46653      Concatenate Two Strings
  |   $B67A/46714      Store String in High RAM
  |   $B6A3/46755      Perform String Housekeeping
  |   $B6DB/46811      Clean Descriptor Stack
  |   $B6EC/46828      Evaluate <chr$>
  |   $B700/46848      Evaluate <left$>
  |   $B72C/46892      Evaluate <right$>
  |   $B737/46903      Evaluate <mid$>
  |   $B761/46945      Pull String Parameters
  |   $B77C/46972      Evaluate <len>
  |   $B782/46978      Exit String Mode
  |   $B78B/46987      Evaluate <asc>
  |   $B79B/47003      Evaluate Text to 1 Byte in XR
  |   $B7AD/47021      Evaluate <val>
  |   $B7B5/47029      Convert ASCII String to Flpt
  |   $B7EB/47083      Get parameters for POKE/WAIT
  |   $B7F7/47095      Convert FAC#1 to Integer in LINNUM
  |   $B80D/47117      Evaluate <peek>
  |   $B824/47140      Perform [poke]
  |   $B82D/47149      Perform [wait]
  |   $B849/47177      Add 0.5 to FAC#1
  |   $B850/47184      Perform Subtraction
  |   $B862/47202      Normalise Addition
  |   $B867/47207      Perform Addition
  |   $B947/47431      2's Complement FAC#1
  |   $B97E/47486      Output ?OVERFLOW Error
  |   $B983/47491      Multiply by Zero Byte
  |   $B9BC/47548      Table of Flpt Constants  1.00
  |   $B9C1/47553      Table of Flpt Constants  #03
  |   $B9C2/47554      Table of Flpt Constants  0.434255942
  |   $B9C7/47559      Table of Flpt Constants  0.57658454
  |   $B9CC/47564      Table of Flpt Constants  0.961800759
  |   $B9D1/47569      Table of Flpt Constants  2.885390073
  |   $B9D6/47574      Table of Flpt Constants  0.707106781
  |   $B9DB/47579      Table of Flpt Constants  1.41421356
  |   $B9E0/47584      Table of Flpt Constants  -0.5
  |   $B9E5/47589      Table of Flpt Constants  0.693147181
  |   $B9EA/47594      Evaluate <log>
  |   $BA28/47656      Perform Multiply
  |   $BA59/47705      Multiply by a Byte
  |   $BA8C/47756      Load FAC#2 From Memory
  |   $BAB7/47799      Test Both Accumulators
  |   $BAD4/47828      Overflow / Underflow
  |   $BAE2/47842      Multiply FAC#1 by 10
  |   $BAF9/47865      Constant 10 in Flpt
  |   $BAFE/47870      Divide FAC#1 by 10
  |   $BB07/47879      Divide FAC#2 by Flpt at (AC/YR)
  |   $BB0F/47887      Divide FAC#2 by FAC#1
  |   $BBA2/48034      Load FAC#1 From Memory
  |   $BBC7/48071      Store FAC#1 in Memory
  |   $BBFC/48124      Copy FAC#2 into FAC#1
  |   $BC0C/48140      Copy FAC#1 into FAC#2
  |   $BC1B/48155      Round FAC#1
  |   $BC2B/48171      Check Sign of FAC#1
  |   $BC39/48185      Evaluate <sgn>
  |   $BC58/48216      Evaluate <abs>
  |   $BC5B/48219      Compare FAC#1 With Memory
  |   $BC9B/48283      Convert FAC#1 to Integer
  |   $BCCC/48332      Evaluate <int>
  |   $BCF3/48371      Convert ASCII String to a Number in FAC
  |   $BDB3/48563      String Conversion Constants    99999999
  |   $BDB8/48568      String Conversion Constants   999999999
  |   $BDBD/48573      String Conversion Constants  1000000000
  |   $BDC2/48578      Output 'IN' and Line Number
  |   $BDCD/48589      Output Positive Integer in A/X
  |   $BDDD/48605      Convert FAC#1 to ASCII String
  |   $BE68/48744      Convert TI to String
  |   $BF11/48913      Table of Constants  0.5
  |   $BF16/48918      Table of Constants  4-byte powers of 10
  |   $BF3A/48954      Table of Constants  TI Constants
  |   $BF71/49009      Evaluate <sqr>
  |   $BF7B/49019      Evaluate <power>
  |   $BFB4/49076      Negate FAC#1
  |   $BFBF/49087      Table of Constants  1.44269504
  |   $BFC4/49092      Table of Constants  #07
  |   $BFC5/49093      Table of Constants  2.149875 E-5
  |   $BFCA/49098      Table of Constants  1.435231 E-4
  |   $BFCF/49103      Table of Constants  1.342263 E-3
  |   $BFD4/49108      Table of Constants  9.6414017 E-3
  |   $BFD9/49113      Table of Constants  5.550513 E-2
  |   $BFDE/49118      Table of Constants  2.402263 E-4
  |   $BFE3/49123      Table of Constants  6.931471 E-1
  |   $BFE8/49128      Table of Constants  1.00
  |   $BFED/49133      Evaluate <exp>
  |
  +------------------------------------------------------------------------



  +------------------------------------------------------------------------
  |
  |      KERNAL ROM LISTING
  |
  +------------------------------------------------------------------------
  |
  | KERNAL related topics:
  |
  |   CHR$/ASC-Table for Upper Case/Graphics
  |   CHR$/ASC-Table for Lower Case/Upper Case
  |   Kernal Differences
  |
  |
  |   $E000/57344      EXP continued From BASIC ROM
  |   $E043/57411      Series Evaluation
  |   $E08D/57485      Constants for RND
  |   $E097/57495      Evaluate <rnd>
  |   $E0F9/57593      Handle I/O Error in BASIC
  |   $E10C/57612      Output Character
  |   $E112/57618      Input Character
  |   $E118/57624      Set Up For Output
  |   $E11E/57630      Set Up For Input
  |   $E124/57636      Get One Character
  |   $E12A/57642      Perform [sys]
  |   $E156/57686      Perform [save]
  |   $E165/57701      Perform [verify]
  |   $E168/57704      Perform [load]
  |   $E1BE/57790      Perform [open]
  |   $E1C7/57799      Perform [close]
  |   $E1D4/57812      Get Parameters For LOAD/SAVE
  |   $E200/57856      Get Next One Byte Parameter
  |   $E206/57862      Check Default Parameters
  |   $E20E/57870      Check For Comma
  |   $E219/57881      Get Parameters For OPEN/CLOSE
  |   $E264/57956      Evaluate <cos>
  |   $E26B/57963      Evaluate <sin>
  |   $E2B4/58036      Evaluate <tan>
  |   $E2E0/58080      Table of Trig Constants   1.570796327
  |   $E2E5/58085      Table of Trig Constants   6.28318531
  |   $E2EA/58090      Table of Trig Constants   0.25
  |   $E2EF/58095      Table of Trig Constants   #05
  |   $E2F0/58096      Table of Trig Constants   -14.3813907
  |   $E2F5/58101      Table of Trig Constants   42.0077971
  |   $E2FA/58106      Table of Trig Constants   -76.7041703
  |   $E2FF/58111      Table of Trig Constants   81.6052237
  |   $E304/58116      Table of Trig Constants   -41.3417021
  |   $E309/58121      Table of Trig Constants   6.28318531
  |   $E30E/58126      Evaluate <atn>
  |   $E33E/58174      Table of ATN Constants   #0b
  |   $E33F/58175      Table of ATN Constants   -0.00068479391
  |   $E344/58180      Table of ATN Constants   0.00485094216
  |   $E349/58185      Table of ATN Constants   -0.161117018
  |   $E34E/58190      Table of ATN Constants   0.034209638
  |   $E353/58195      Table of ATN Constants   -0.0542791328
  |   $E358/58200      Table of ATN Constants   0.0724571965
  |   $E35D/58205      Table of ATN Constants   -0.0898023954
  |   $E362/58210      Table of ATN Constants   0.110932413
  |   $E367/58215      Table of ATN Constants   -0.142839808
  |   $E36C/58220      Table of ATN Constants   0.19999912
  |   $E371/58225      Table of ATN Constants   -0.333333316
  |   $E376/58230      Table of ATN Constants   1.00
  |   $E37B/58235      BASIC Warm Start [RUNSTOP-RESTORE]
  |   $E394/58260      BASIC Cold Start
  |   $E3A2/58274      CHRGET For Zero-page
  |   $E3BA/58298      RND Seed For zero-page
  |   $E3BF/58303      Initialize BASIC RAM
  |   $E422/58402      Output Power-Up Message
  |   $E447/58439      Table of BASIC Vectors (for 0300)
  |   $E453/58451      Initialize Vectors
  |   $E45F/58463      Power-Up Message
  |   $E4AC/58540      Version Indicator(?)
  |   $E4AD/58541      Patch for BASIC Call to CHKOUT
  |   $E4B7/58551      Unused Bytes For Future Patches
  |   $E4D3/58579      Patch for RS232-Routines
  |   $E4DA/58586      Reset Character Color
  |   $E4E0/58592      Pause After Finding Tape File
  |   $E4EC/58604      RS232 Timing Table -- PAL
  |   $E500/58624      Get I/O Address
  |   $E505/58629      Get Screen Size
  |   $E50A/58634      Put / Get Row And Column
  |   $E518/58648      Initialize I/O
  |   $E544/58692      Clear Screen
  |   $E566/58726      Home Cursor
  |   $E56C/58732      Set Screen Pointers
  |   $E59A/58778      Set I/O Defaults (Unused Entry)
  |   $E5A0/58784      Set I/O Defaults
  |   $E5B4/58804      Get Character From Keyboard Buffer
  |   $E5CA/58826      Input From Keyboard
  |   $E632/58930      Input From Screen or Keyboard
  |   $E684/59012      Quotes Test
  |   $E691/59025      Set Up Screen Print
  |   $E6B6/59062      Advance Cursor
  |   $E6ED/59117      Retreat Cursor
  |   $E701/59137      Back on to Previous Line
  |   $E716/59158      Output to Screen
  |   $E72A/59178      -unshifted characters-
  |   $E7D4/59348      -shifted characters-
  |   $E87C/59516      Go to Next Line
  |   $E891/59537      Output <CR>
  |   $E8A1/59553      Check Line Decrement
  |   $E8B3/59571      Check Line Increment
  |   $E8CB/59595      Set Color Code
  |   $E8DA/59610      Color Code Table
  |   $E8EA/59626      Scroll Screen
  |   $E965/59749      Open A Space On The Screen
  |   $E9C8/59848      Move A Screen Line
  |   $E9E0/59872      Syncronise Color Transfer
  |   $E9F0/59888      Set Start of Line
  |   $E9FF/59903      Clear Screen Line
  |   $EA13/59923      Print To Screen
  |   $EA24/59940      Syncronise Color Pointer
  |   $EA31/59953      Main IRQ Entry Point
  |   $EA81/60033      Restore A/X/Y and End IRQ
  |   $EA87/60039      Scan Keyboard
  |   $EADD/60125      Process Key Image
  |   $EB48/60232      Check for Shift, CTRL, C=
  |   $EB79/60281      Pointers to Keyboard decoding tables
  |   $EB81/60289      Keyboard 1 -- Unshifted
  |   $EBC2/60354      Keyboard 2 -- Shifted
  |   $EC03/60419      Keyboard 3 -- Commodore
  |   $EC44/60484      Graphics/Text Control
  |   $EC78/60536      Keyboard 4 -- Control
  |   $ECB9/60601      Video Chip Setup Table
  |   $ECE7/60647      Shift-Run Equivalent
  |   $ECF0/60656      Low Byte Screen Line Addresses
  |   $ED09/60681      Send TALK Command on Serial Bus
  |   $ED0C/60684      Send LISTEN Command on Serial Bus
  |   $ED40/60736      Send Data On Serial Bus
  |   $EDAD/60845      Flag Errors: Status #80 - DEVICE NOT PRESENT
  |   $EDB0/60848      Flag Errors: Status #03 - WRITE TIMEOUT
  |   $EDB9/60857      Send LISTEN Secondary Address
  |   $EDBE/60862      Clear ATN
  |   $EDC7/60871      Send TALK Secondary Address
  |   $EDCC/60876      Wait For Clock
  |   $EDDD/60893      Send Serial Deferred
  |   $EDEF/60911      Send UNTALK
  |   $EDFE/60926      Send UNLISTEN
  |   $EE13/60947      Receive From Serial Bus
  |   $EE85/61061      Serial Clock On
  |   $EE8E/61070      Serial Clock Off
  |   $EE97/61079      Serial Output 1
  |   $EEA0/61088      Serial Output 0
  |   $EEA9/61097      Get Serial Data And Clock In
  |   $EEB3/61107      Delay 1 ms
  |   $EEBB/61115      RS232 Send
  |   $EF06/61190      Send New RS232 Byte
  |   $EF2E/61230      'No DSR' / 'No CTS' Error
  |   $EF39/61241      Disable Timer
  |   $EF4A/61258      Compute Bit Count
  |   $EF59/61273      RS232 Receive
  |   $EF7E/61310      Set Up To Receive
  |   $EF90/61328      Process RS232 Byte
  |   $EFE1/61409      Submit to RS232
  |   $F00D/61453      No DSR (Data Set Ready) Error
  |   $F017/61463      Send to RS232 Buffer
  |   $F04D/61517      Input From RS232
  |   $F086/61574      Get From RS232
  |   $F0A4/61604      Serial Bus Idle
  |   $F0BD/61629      Table of Kernal I/O Messages
  |   $F12B/61739      Print Message if Direct
  |   $F12F/61743      Print Message
  |   $F13E/61758      Get a byte
  |   $F157/61783      Input a byte
  |   $F199/61849      Get From Tape / Serial / RS232
  |   $F1CA/61898      Output One Character
  |   $F20E/61966      Set Input Device
  |   $F250/62032      Set Output Device
  |   $F291/62097      Close File
  |   $F30F/62223      Find File
  |   $F31F/62239      Set File values
  |   $F32F/62255      Abort All Files
  |   $F333/62259      Restore Default I/O
  |   $F34A/62282      Open File
  |   $F3D5/62421      Send Secondary Address
  |   $F409/62473      Open RS232
  |   $F49E/62622      Load RAM
  |   $F4B8/62648      Load File From Serial Bus
  |   $F533/62771      Load File From Tape
  |   $F5AF/62895      Print "SEARCHING"
  |   $F5C1/62913      Print Filename
  |   $F5D2/62930      Print "LOADING / VERIFYING"
  |   $F5DD/62941      Save RAM
  |   $F5FA/62970      Save to Serial Bus
  |   $F659/63065      Save to Tape
  |   $F68F/63119      Print "SAVING"
  |   $F69B/63131      Bump Clock
  |   $F6DD/63197      Get Time
  |   $F6E4/63204      Set Time
  |   $F6ED/63213      Check STOP Key
  |   $F6FB/63227      Output I/O Error Messages: 'TOO MANY FILES'
  |   $F6FE/63230      Output I/O Error Messages: 'FILE OPEN'
  |   $F701/63233      Output I/O Error Messages: 'FILE NOT OPEN'
  |   $F704/63236      Output I/O Error Messages: 'FILE NOT FOUND'
  |   $F707/63239      Output I/O Error Messages: 'DEVICE NOT PRESENT'
  |   $F70A/63242      Output I/O Error Messages: 'NOT INPUT FILE'
  |   $F70D/63245      Output I/O Error Messages: 'NOT OUTPUT FILE'
  |   $F710/63248      Output I/O Error Messages: 'MISSING FILENAME'
  |   $F713/63251      Output I/O Error Messages: 'ILLEGAL DEVICE NUMBER'
  |   $F72C/63276      Find Any Tape Header
  |   $F76A/63338      Write Tape Header
  |   $F7D0/63440      Get Buffer Address
  |   $F7D7/63447      Set Buffer Stat / End Pointers
  |   $F7EA/63466      Find Specific Tape Header
  |   $F80D/63501      Bump Tape Pointer
  |   $F817/63511      Print "PRESS PLAY ON TAPE"
  |   $F82E/63534      Check Tape Status
  |   $F838/63544      Print "PRESS RECORD..."
  |   $F841/63553      Initiate Tape Read
  |   $F864/63588      Initiate Tape Write
  |   $F875/63605      Common Tape Code
  |   $F8D0/63696      Check Tape Stop
  |   $F8E2/63714      Set Read Timing
  |   $F92C/63788      Read Tape Bits
  |   $FA60/64096      Store Tape Characters
  |   $FB8E/64398      Reset Tape Pointer
  |   $FB97/64407      New Character Setup
  |   $FBA6/64422      Send Tone to Tape
  |   $FBC8/64456      Write Data to Tape
  |   $FBCD/64461      IRQ Entry Point
  |   $FC57/64599      Write Tape Leader
  |   $FC93/64659      Restore Normal IRQ
  |   $FCB8/64696      Set IRQ Vector
  |   $FCCA/64714      Stop Tape Motor
  |   $FCD1/64721      Check Read / Write Pointer
  |   $FCDB/64731      Bump Read / Write Pointer
  |   $FCE2/64738      Power-Up RESET Entry
  |   $FD02/64770      Check For 8-ROM
  |   $FD10/64784      8-ROM Mask 'CBM80'
  |   $FD15/64789      Restore Kernal Vectors
  |   $FD1A/64794      Change Vectors For User
  |   $FD30/64816      Kernal Reset Vectors
  |   $FD50/64848      Initialise System Constants
  |   $FD9B/64923      IRQ Vectors For Tape I/O
  |   $FDA3/64931      Initialise I/O
  |   $FDDD/64989      Enable Timer
  |   $FDF9/65017      Set Filename
  |   $FE00/65024      Set Logical File Parameters
  |   $FE07/65031      Get I/O Status Word
  |   $FE18/65048      Control OS Messages
  |   $FE21/65057      Set IEEE Timeout
  |   $FE25/65061      Read / Set Top of Memory
  |   $FE34/65076      Read / Set Bottom of Memory
  |   $FE43/65091      NMI Transfer Entry
  |   $FE66/65126      Warm Start Basic
  |   $FEBC/65212      Exit Interrupt
  |   $FEC2/65218      RS232 Timing Table - NTSC
  |   $FED6/65238      NMI RS232 In
  |   $FF07/65287      NMI RS232 Out
  |   $FF43/65347      Fake IRQ Entry
  |   $FF48/65352      IRQ Entry
  |   $FF5B/65371      Initialize screen editor
  |   $FF80/65408      Kernal Version Number
  |   $FF81/65409      Init Editor & Video Chips
  |   $FF84/65412      Init I/O Devices, Ports & Timers
  |   $FF87/65415      Init Ram & Buffers
  |   $FF8A/65418      Restore Vectors
  |   $FF8D/65421      Change Vectors For User
  |   $FF90/65424      Control OS Messages
  |   $FF93/65427      Send SA After Listen
  |   $FF96/65430      Send SA After Talk
  |   $FF99/65433      Set/Read System RAM Top
  |   $FF9C/65436      Set/Read System RAM Bottom
  |   $FF9F/65439      Scan Keyboard
  |   $FFA2/65442      Set Timeout In IEEE
  |   $FFA5/65445      Handshake Serial Byte In
  |   $FFA8/65448      Handshake Serial Byte Out
  |   $FFAB/65451      Command Serial Bus UNTALK
  |   $FFAE/65454      Command Serial Bus UNLISTEN
  |   $FFB1/65457      Command Serial Bus LISTEN
  |   $FFB4/65460      Command Serial Bus TALK
  |   $FFB7/65463      Read I/O Status Word
  |   $FFBA/65466      Set Logical File Parameters
  |   $FFBD/65469      Set Filename
  |   $FFC0/65472      Open Vector
  |   $FFC3/65475      Close Vector
  |   $FFC6/65478      Set Input
  |   $FFC9/65481      Set Output
  |   $FFCC/65484      Restore I/O Vector
  |   $FFCF/65487      Input Vector, chrin
  |   $FFD2/65490      Output Vector, chrout
  |   $FFD5/65493      Load RAM From Device
  |   $FFD8/65496      Save RAM To Device
  |   $FFDB/65499      Set Real-Time Clock
  |   $FFDE/65502      Read Real-Time Clock
  |   $FFE1/65505      Test-Stop Vector
  |   $FFE4/65508      Get From Keyboad
  |   $FFE7/65511      Close All Channels And Files
  |   $FFEA/65514      Increment Real-Time Clock
  |   $FFED/65517      Return Screen Organization
  |   $FFF0/65520      Read / Set Cursor X/Y Position
  |   $FFF3/65523      Return I/O Base Address
  |   $FFF6/65526      -
  |   $FFF8/65528      SYSTEM
  |   $FFFA/65530      Vector: NMI
  |   $FFFC/65532      Vector: RESET
  |   $FFFE/65534      Vector: IRQ
  |
  +------------------------------------------------------------------------



 $A000/40960:   Restart Vectors

Jump from $FCFF ($A000):
Jump from $FE6F ($A002):

A000: 94 E3 7B E3                $E394,$E37B



 $A004/40964:   'CBMBASIC'-Identifier

A004: 43 42 4D 42 41 53 49 43    'CBMBASIC'



 $A00C/40972:   BASIC Command Vectors - 1

A00C: 30 A8 41 A7 1D AD F7 A8    $A830,$A741,$AD1D,$A8F7
A014: A4 AB BE AB 80 B0 05 AC    $ABA4,$ABBE,$B080,$AC05
A01C: A4 A9 9F A8 70 A8 27 A9    $A9A4,$A89F,$A870,$A927
A024: 1C A8 82 A8 D1 A8 3A A9    $A81C,$A882,$A8D1,$A93A
A02C: 2E A8 4A A9 2C B8 67 E1    $A82E,$A94A,$B82C,$E167
A034: 55 E1 64 E1 B2 B3 23 B8    $E155,$E164,$B3B2,$B823
A03C: 7F AA 9F AA 56 A8 9B A6    $AA7F,$AA9F,$A856,$A69B
A044: 5D A6 85 AA 29 E1 BD E1    $A65D,$AA85,$E129,$E1BD
A04C: C6 E1 7A AB 41 A6          $E1C6,$AB7A,$A641


Kernal-Reference:

 LDA $A00C,Y : $A7FD

 LDA $A00D,Y : $A7F9


 $A052/41042:   BASIC Function Vectors

A052: 39 BC CC BC 58 BC 10 03    $BC39,$BCCC,$BC58,$0310
A05A: 7D B3 9E B3 71 BF 97 E0    $B37D,$B39E,$BF71,$E097
A062: EA B9 ED BF 64 E2 6B E2    $B9EA,$BFED,$E264,$E26B
A06A: B4 E2 0E E3 0D B8 7C B7    $E2B4,$E30E,$B80D,$B77C
A072: 65 B4 AD B7 8B B7 EC B6    $B465,$B7AD,$B78B,$B6EC
A07A: 00 B7 2C B7 37 B7          $B700,$B72C,$B737



 $A080/41088:   BASIC Operator Vectors

A080: 79 69 B8 79 52 B8 7B 2A
A088: BA 7B 11 BB 7F 7A BF 50
A090: E8 AF 46 E5 AF 7D B3 BF
A098: 5A D3 AE 64 15 B0


Kernal-Reference:

 CMP $A080,Y : $ADF1 $AE19
 LDX $A080,Y : $AE35

 LDA $A081,Y : $AE24

 LDA $A082,Y : $AE20

 LDA $A09D,Y : $A5FA


 $A09E/41118:   BASIC Command Keyword Table

A09E: 45 4E C4 46 4F D2 4E 45    'END, FOR, NE'
A0A6: 58 D4 44 41 54 C1 49 4E    'XT, DATA, IN'
A0AE: 50 55 54 A3 49 4E 50 55    'PUT#, INPU'
A0B6: D4 44 49 CD 52 45 41 C4    'T, DIM, READ,'
A0BE: 4C 45 D4 47 4F 54 CF 52    'LET, GOTO, R'
A0C6: 55 CE 49 C6 52 45 53 54    'UN, IF, REST'
A0CE: 4F 52 C5 47 4F 53 55 C2    'ORE, GOSUB,'
A0D6: 52 45 54 55 52 CE 52 45    'RETURN, RE'
A0DE: CD 53 54 4F D0 4F CE 57    'M, STOP, ON, W'
A0E6: 41 49 D4 4C 4F 41 C4 53    'AIT, LOAD, S'
A0EE: 41 56 C5 56 45 52 49 46    'AVE, VERIF'
A0F6: D9 44 45 C6 50 4F 4B C5    'Y, DEF, POKE,'
A0FE: 50 52 49 4E 54 A3 50 52    'PRINT#, PR'
A106: 49 4E D4 43 4F 4E D4 4C    'INT, CONT, L'
A10E: 49 53 D4 43 4C D2 43 4D    'IST, CLR, CM'
A116: C4 53 59 D3 4F 50 45 CE    'D, SYS, OPEN,'
A11E: 43 4C 4F 53 C5 47 45 D4    'CLOSE, GET,'
A126: 4E 45 D7                   'NEW,'


Kernal-Reference:

 LDA $A09E,Y : $A5FF $A730 $A738
 SBC $A09E,Y : $A5BC


 $A129/41257:   BASIC Misc. Keyword Table

A129: 54 41 42 A8 54 CF 46 CE    'TAB(, TO, FN,'
A131: 53 50 43 A8 54 48 45 CE    'SPC(, THEN,'
A139: 4E 4F D4 53 54 45 D0       'NOT, STEP,'



 $A140/41280:   BASIC Operator Keyword Table

A140: AB AD AA AF DE 41 4E C4    '+, -, *, /, ^, AND,'
A148: 4F D2 BE BD BC             'OR, >, =, <,'



 $A14D/41293:   BASIC Function Keyword Table

A14D: 53 47 CE 49 4E D4 41 42    'SGN, INT, AB'
A155: D3 55 53 D2 46 52 C5 50    'S, USR, FRE, P'
A15D: 4F D3 53 51 D2 52 4E C4    'OS, SQR, RND,'
A165: 4C 4F C7 45 58 D0 43 4F    'LOG, EXP, CO'
A16D: D3 53 49 CE 54 41 CE 41    'S, SIN, TAN, A'
A175: 54 CE 50 45 45 CB 4C 45    'TN, PEEK, LE'
A17D: CE 53 54 52 A4 56 41 CC    'N, STR$, VAL,'
A185: 41 53 C3 43 48 52 A4 4C    'ASC, CHR$, L'
A18D: 45 46 54 A4 52 49 47 48    'EFT$, RIGH'
A195: 54 A4 4D 49 44 A4 47 CF    'T$, MID$, GO,'
A19D: 00                         '{0}'



 $A19E/41374:   Error Message Table

A19E: 54 4F 4F 20 4D 41 4E 59    'TOO MANY'
A1A6: 20 46 49 4C 45 D3 46 49    ' FILES, FI'
A1AE: 4C 45 20 4F 50 45 CE 46    'LE OPEN, F'
A1B6: 49 4C 45 20 4E 4F 54 20    'ILE NOT '
A1BE: 4F 50 45 CE 46 49 4C 45    'OPEN, FILE'
A1C6: 20 4E 4F 54 20 46 4F 55    ' NOT FOU'
A1CE: 4E C4 44 45 56 49 43 45    'ND, DEVICE'
A1D6: 20 4E 4F 54 20 50 52 45    ' NOT PRE'
A1DE: 53 45 4E D4 4E 4F 54 20    'SENT, NOT '
A1E6: 49 4E 50 55 54 20 46 49    'INPUT FI'
A1EE: 4C C5 4E 4F 54 20 4F 55    'LE, NOT OU'
A1F6: 54 50 55 54 20 46 49 4C    'TPUT FIL'
A1FE: C5 4D 49 53 53 49 4E 47    'E, MISSING'
A206: 20 46 49 4C 45 20 4E 41    ' FILE NA'
A20E: 4D C5 49 4C 4C 45 47 41    'ME, ILLEGA'
A216: 4C 20 44 45 56 49 43 45    'L DEVICE'
A21E: 20 4E 55 4D 42 45 D2 4E    ' NUMBER, N'
A226: 45 58 54 20 57 49 54 48    'EXT WITH'
A22E: 4F 55 54 20 46 4F D2 53    'OUT FOR, S'
A236: 59 4E 54 41 D8 52 45 54    'YNTAX, RET'
A23E: 55 52 4E 20 57 49 54 48    'URN WITH'
A246: 4F 55 54 20 47 4F 53 55    'OUT GOSU'
A24E: C2 4F 55 54 20 4F 46 20    'B, OUT OF '
A256: 44 41 54 C1 49 4C 4C 45    'DATA, ILLE'
A25E: 47 41 4C 20 51 55 41 4E    'GAL QUAN'
A266: 54 49 54 D9 4F 56 45 52    'TITY, OVER'
A26E: 46 4C 4F D7 4F 55 54 20    'FLOW, OUT '
A276: 4F 46 20 4D 45 4D 4F 52    'OF MEMOR'
A27E: D9 55 4E 44 45 46 27 44    'Y, UNDEF'D'
A286: 20 53 54 41 54 45 4D 45    ' STATEME'
A28E: 4E D4 42 41 44 20 53 55    'NT, BAD SU'
A296: 42 53 43 52 49 50 D4 52    'BSCRIPT, R'
A29E: 45 44 49 4D 27 44 20 41    'EDIM'D A'
A2A6: 52 52 41 D9 44 49 56 49    'RRAY, DIVI'
A2AE: 53 49 4F 4E 20 42 59 20    'SION BY '
A2B6: 5A 45 52 CF 49 4C 4C 45    'ZERO, ILLE'
A2BE: 47 41 4C 20 44 49 52 45    'GAL DIRE'
A2C6: 43 D4 54 59 50 45 20 4D    'CT, TYPE M'
A2CE: 49 53 4D 41 54 43 C8 53    'ISMATCH, S'
A2D6: 54 52 49 4E 47 20 54 4F    'TRING TO'
A2DE: 4F 20 4C 4F 4E C7 46 49    'O LONG, FI'
A2E6: 4C 45 20 44 41 54 C1 46    'LE DATA, F'
A2EE: 4F 52 4D 55 4C 41 20 54    'ORMULA T'
A2F6: 4F 4F 20 43 4F 4D 50 4C    'OO COMPL'
A2FE: 45 D8 43 41 4E 27 54 20    'EX, CAN'T '
A306: 43 4F 4E 54 49 4E 55 C5    'CONTINUE,'
A30E: 55 4E 44 45 46 27 44 20    'UNDEF'D '
A316: 46 55 4E 43 54 49 4F CE    'FUNCTION,'
A31E: 56 45 52 49 46 D9 4C 4F    'VERIFY, LO'
A326: 41 C4                      'AD'


Kernal-Reference:

 LDA $A326,X : $A43D

 LDA $A327,X : $A442


 $A328/41768:   Error Message Pointers

A328: 9E A1 AC A1 B5 A1 C2 A1    $A19E,$A1AC,$A1B5,$A1C2
A330: D0 A1 E2 A1 F0 A1 FF A1    $A1D0,$A1E2,$A1F0,$A1FF
A338: 10 A2 25 A2 35 A2 3B A2    $A210,$A225,$A235,$A23B
A340: 4F A2 5A A2 6A A2 72 A2    $A24F,$A25A,$A26A,$A272
A348: 7F A2 90 A2 9D A2 AA A2    $A27F,$A290,$A29D,$A2AA
A350: BA A2 C8 A2 D5 A2 E4 A2    $A2BA,$A2C8,$A2D5,$A2E4
A358: ED A2 00 A3 0E A3 1E A3    $A2ED,$A300,$A30E,$A31E
A360: 24 A3 83 A3                $A324,$A383



 $A364/41828:   Misc. Messages

A364: 0D 4F 4B 0D 00 20 20 45    '{CR}OK{CR}{0}  E'
A36C: 52 52 4F 52 00 20 49 4E    'RROR{0} IN'
A374: 20 00 0D 0A 52 45 41 44    ' {0}{CR}{10}READ'
A37C: 59 2E 0D 0A 00 0D 0A 42    'Y.{CR}{10}{0}{CR}{10}B'
A384: 52 45 41 4B 00 A0          'REAK{0} '



 $A38A/41866:   Find FOR/GOSUB Entry on Stack

Jump from $A749, $A8D8, $AD2B:

A38A: BA        TSX
A38B: E8        INX
A38C: E8        INX
A38D: E8        INX
A38E: E8        INX

Jump from $A3B5:

A38F: BD 01 01  LDA $0101,X   ; 6510 Hardware Stack Area
A392: C9 81     CMP #$81
A394: D0 21     BNE $A3B7
A396: A5 4A     LDA $4A       ; Pointer: Index Variable for FOR/NEXT loop
A398: D0 0A     BNE $A3A4
A39A: BD 02 01  LDA $0102,X   ; 6510 Hardware Stack Area
A39D: 85 49     STA $49       ; Pointer: Index Variable for FOR/NEXT loop
A39F: BD 03 01  LDA $0103,X   ; 6510 Hardware Stack Area
A3A2: 85 4A     STA $4A       ; Pointer: Index Variable for FOR/NEXT loop

Jump from $A398:

A3A4: DD 03 01  CMP $0103,X   ; 6510 Hardware Stack Area
A3A7: D0 07     BNE $A3B0
A3A9: A5 49     LDA $49       ; Pointer: Index Variable for FOR/NEXT loop
A3AB: DD 02 01  CMP $0102,X   ; 6510 Hardware Stack Area
A3AE: F0 07     BEQ $A3B7

Jump from $A3A7:

A3B0: 8A        TXA
A3B1: 18        CLC
A3B2: 69 12     ADC #$12
A3B4: AA        TAX
A3B5: D0 D8     BNE $A38F

Jump from $A394, $A3AE:

A3B7: 60        RTS



 $A3B8/41912:   Open Space in Memory

Jump from $A50A, $B15D:

A3B8: 20 08 A4  JSR $A408     ; Check Memory Overlap
A3BB: 85 31     STA $31       ; Pointer: End of BASIC Arrays + 1
A3BD: 84 32     STY $32       ; Pointer: End of BASIC Arrays + 1

Jump from $B628:

A3BF: 38        SEC
A3C0: A5 5A     LDA $5A       ; Temporary storage for FLPT value
A3C2: E5 5F     SBC $5F       ; Temporary storage for FLPT value
A3C4: 85 22     STA $22       ; Second Utility Pointer
A3C6: A8        TAY
A3C7: A5 5B     LDA $5B       ; Temporary storage for FLPT value
A3C9: E5 60     SBC $60       ; Temporary storage for FLPT value
A3CB: AA        TAX
A3CC: E8        INX
A3CD: 98        TYA
A3CE: F0 23     BEQ $A3F3
A3D0: A5 5A     LDA $5A       ; Temporary storage for FLPT value
A3D2: 38        SEC
A3D3: E5 22     SBC $22       ; Second Utility Pointer
A3D5: 85 5A     STA $5A       ; Temporary storage for FLPT value
A3D7: B0 03     BCS $A3DC
A3D9: C6 5B     DEC $5B       ; Temporary storage for FLPT value
A3DB: 38        SEC

Jump from $A3D7:

A3DC: A5 58     LDA $58       ; Temporary storage for FLPT value
A3DE: E5 22     SBC $22       ; Second Utility Pointer
A3E0: 85 58     STA $58       ; Temporary storage for FLPT value
A3E2: B0 08     BCS $A3EC
A3E4: C6 59     DEC $59       ; Temporary storage for FLPT value
A3E6: 90 04     BCC $A3EC

Jump from $A3ED:

A3E8: B1 5A     LDA ($5A),Y   ; Temporary storage for FLPT value
A3EA: 91 58     STA ($58),Y   ; Temporary storage for FLPT value

Jump from $A3E2, $A3E6, $A3F8:

A3EC: 88        DEY
A3ED: D0 F9     BNE $A3E8
A3EF: B1 5A     LDA ($5A),Y   ; Temporary storage for FLPT value
A3F1: 91 58     STA ($58),Y   ; Temporary storage for FLPT value

Jump from $A3CE:

A3F3: C6 5B     DEC $5B       ; Temporary storage for FLPT value
A3F5: C6 59     DEC $59       ; Temporary storage for FLPT value
A3F7: CA        DEX
A3F8: D0 F2     BNE $A3EC
A3FA: 60        RTS



 $A3FB/41979:   Check Stack Depth

Jump from $A757, $A885, $ADAE:

A3FB: 0A        ASL
A3FC: 69 3E     ADC #$3E
A3FE: B0 35     BCS $A435     ; Output ?OUT OF MEMORY Error
A400: 85 22     STA $22       ; Second Utility Pointer
A402: BA        TSX
A403: E4 22     CPX $22       ; Second Utility Pointer
A405: 90 2E     BCC $A435     ; Output ?OUT OF MEMORY Error
A407: 60        RTS



 $A408/41992:   Check Memory Overlap

Jump from $A3B8, $B264, $B2B9, $E426:

A408: C4 34     CPY $34       ; Pointer: Bottom of String space
A40A: 90 28     BCC $A434
A40C: D0 04     BNE $A412
A40E: C5 33     CMP $33       ; Pointer: Bottom of String space
A410: 90 22     BCC $A434

Jump from $A40C:

A412: 48        PHA
A413: A2 09     LDX #$09
A415: 98        TYA

Jump from $A41A:

A416: 48        PHA
A417: B5 57     LDA $57,X     ; Temporary storage for FLPT value
A419: CA        DEX
A41A: 10 FA     BPL $A416
A41C: 20 26 B5  JSR $B526     ; Garbage Collection
A41F: A2 F7     LDX #$F7

Jump from $A425:

A421: 68        PLA
A422: 95 61     STA $61,X     ; FAC Exponent
A424: E8        INX
A425: 30 FA     BMI $A421
A427: 68        PLA
A428: A8        TAY
A429: 68        PLA
A42A: C4 34     CPY $34       ; Pointer: Bottom of String space
A42C: 90 06     BCC $A434
A42E: D0 05     BNE $A435     ; Output ?OUT OF MEMORY Error
A430: C5 33     CMP $33       ; Pointer: Bottom of String space
A432: B0 01     BCS $A435     ; Output ?OUT OF MEMORY Error

Jump from $A40A, $A410, $A42C:

A434: 60        RTS



 $A435/42037:   Output ?OUT OF MEMORY Error

Jump from $A3FE, $A405, $A42E, $A432, $B30B:

A435: A2 10     LDX #$10



 $A437/42039:   Error Routine

Jump from $A573, $A85F, $A8E5, $AB68, $AD32, $AD9B, $AF0A, $B24A, $B3B0,
          $B4D2, $B65A, $B980, $BB8C, $E109, $E19E:

A437: 6C 00 03  JMP ($0300)   ; Vector: BASIC Error Message

Jump from $E38E:

A43A: 8A        TXA
A43B: 0A        ASL
A43C: AA        TAX
A43D: BD 26 A3  LDA $A326,X   ; Error Message Table
A440: 85 22     STA $22       ; Second Utility Pointer
A442: BD 27 A3  LDA $A327,X   ; Error Message Table
A445: 85 23     STA $23       ; Second Utility Pointer
A447: 20 CC FF  JSR $FFCC     ; Restore I/O Vector
A44A: A9 00     LDA #$00
A44C: 85 13     STA $13       ; File number of current Input Device
A44E: 20 D7 AA  JSR $AAD7     ; Output CR/LF
A451: 20 45 AB  JSR $AB45     ; Output Format Character
A454: A0 00     LDY #$00

Jump from $A460:

A456: B1 22     LDA ($22),Y   ; Second Utility Pointer
A458: 48        PHA
A459: 29 7F     AND #$7F
A45B: 20 47 AB  JSR $AB47     ; Output Format Character
A45E: C8        INY
A45F: 68        PLA
A460: 10 F4     BPL $A456
A462: 20 7A A6  JSR $A67A     ; Perform [clr]
A465: A9 69     LDA #$69
A467: A0 A3     LDY #$A3



 $A469/42089:   Break Entry

Jump from $A851:

A469: 20 1E AB  JSR $AB1E     ; Output String
A46C: A4 3A     LDY $3A       ; Current BASIC Line number
A46E: C8        INY
A46F: F0 03     BEQ $A474     ; Restart BASIC
A471: 20 C2 BD  JSR $BDC2     ; Output 'IN' and Line Number



 $A474/42100:   Restart BASIC

Jump from $A46F, $E391:

A474: A9 76     LDA #$76
A476: A0 A3     LDY #$A3
A478: 20 1E AB  JSR $AB1E     ; Output String
A47B: A9 80     LDA #$80
A47D: 20 90 FF  JSR $FF90     ; Control OS Messages



 $A480/42112:   Input & Identify BASIC Line

Jump from $A48E, $A4F6, $A530:

A480: 6C 02 03  JMP ($0302)   ; Vector: BASIC Input Line and Decode
A483: 20 60 A5  JSR $A560     ; Input Line Into Buffer
A486: 86 7A     STX $7A       ; Pointer: Current Byte of BASIC Text
A488: 84 7B     STY $7B       ; Pointer: Current Byte of BASIC Text
A48A: 20 73 00  JSR $0073     ; CHRGET: Get next Byte of BASIC Text
A48D: AA        TAX
A48E: F0 F0     BEQ $A480
A490: A2 FF     LDX #$FF
A492: 86 3A     STX $3A       ; Current BASIC Line number
A494: 90 06     BCC $A49C     ; Get Line Number & Tokenise Text
A496: 20 79 A5  JSR $A579     ; Tokenise Input Buffer
A499: 4C E1 A7  JMP $A7E1     ; Prepare to execute statement



 $A49C/42140:   Get Line Number & Tokenise Text

Jump from $A494:

A49C: 20 6B A9  JSR $A96B     ; Fetch linnum From BASIC
A49F: 20 79 A5  JSR $A579     ; Tokenise Input Buffer



 $A4A2/42146:   Insert BASIC Text

A4A2: 84 0B     STY $0B       ; Input Buffer Pointer/Number of Subscripts
A4A4: 20 13 A6  JSR $A613     ; Search for Line Number
A4A7: 90 44     BCC $A4ED
A4A9: A0 01     LDY #$01
A4AB: B1 5F     LDA ($5F),Y   ; Temporary storage for FLPT value
A4AD: 85 23     STA $23       ; Second Utility Pointer
A4AF: A5 2D     LDA $2D       ; Pointer: Start of BASIC Variables
A4B1: 85 22     STA $22       ; Second Utility Pointer
A4B3: A5 60     LDA $60       ; Temporary storage for FLPT value
A4B5: 85 25     STA $25       ; Second Utility Pointer
A4B7: A5 5F     LDA $5F       ; Temporary storage for FLPT value
A4B9: 88        DEY
A4BA: F1 5F     SBC ($5F),Y   ; Temporary storage for FLPT value
A4BC: 18        CLC
A4BD: 65 2D     ADC $2D       ; Pointer: Start of BASIC Variables
A4BF: 85 2D     STA $2D       ; Pointer: Start of BASIC Variables
A4C1: 85 24     STA $24       ; Second Utility Pointer
A4C3: A5 2E     LDA $2E       ; Pointer: Start of BASIC Variables
A4C5: 69 FF     ADC #$FF
A4C7: 85 2E     STA $2E       ; Pointer: Start of BASIC Variables
A4C9: E5 60     SBC $60       ; Temporary storage for FLPT value
A4CB: AA        TAX
A4CC: 38        SEC
A4CD: A5 5F     LDA $5F       ; Temporary storage for FLPT value
A4CF: E5 2D     SBC $2D       ; Pointer: Start of BASIC Variables
A4D1: A8        TAY
A4D2: B0 03     BCS $A4D7
A4D4: E8        INX
A4D5: C6 25     DEC $25       ; Second Utility Pointer

Jump from $A4D2:

A4D7: 18        CLC
A4D8: 65 22     ADC $22       ; Second Utility Pointer
A4DA: 90 03     BCC $A4DF
A4DC: C6 23     DEC $23       ; Second Utility Pointer
A4DE: 18        CLC

Jump from $A4DA, $A4E4, $A4EB:

A4DF: B1 22     LDA ($22),Y   ; Second Utility Pointer
A4E1: 91 24     STA ($24),Y   ; Second Utility Pointer
A4E3: C8        INY
A4E4: D0 F9     BNE $A4DF
A4E6: E6 23     INC $23       ; Second Utility Pointer
A4E8: E6 25     INC $25       ; Second Utility Pointer
A4EA: CA        DEX
A4EB: D0 F2     BNE $A4DF

Jump from $A4A7:

A4ED: 20 59 A6  JSR $A659     ; Perform [new]
A4F0: 20 33 A5  JSR $A533     ; Rechain Lines
A4F3: AD 00 02  LDA $0200     ; BASIC Input Buffer (Input Line from Screen)
A4F6: F0 88     BEQ $A480     ; Input & Identify BASIC Line
A4F8: 18        CLC
A4F9: A5 2D     LDA $2D       ; Pointer: Start of BASIC Variables
A4FB: 85 5A     STA $5A       ; Temporary storage for FLPT value
A4FD: 65 0B     ADC $0B       ; Input Buffer Pointer/Number of Subscripts
A4FF: 85 58     STA $58       ; Temporary storage for FLPT value
A501: A4 2E     LDY $2E       ; Pointer: Start of BASIC Variables
A503: 84 5B     STY $5B       ; Temporary storage for FLPT value
A505: 90 01     BCC $A508
A507: C8        INY

Jump from $A505:

A508: 84 59     STY $59       ; Temporary storage for FLPT value
A50A: 20 B8 A3  JSR $A3B8     ; Open Space in Memory
A50D: A5 14     LDA $14       ; Temporary: Integer value
A50F: A4 15     LDY $15       ; Temporary: Integer value
A511: 8D FE 01  STA $01FE     ; BASIC Stack Area
A514: 8C FF 01  STY $01FF     ; BASIC Stack Area
A517: A5 31     LDA $31       ; Pointer: End of BASIC Arrays + 1
A519: A4 32     LDY $32       ; Pointer: End of BASIC Arrays + 1
A51B: 85 2D     STA $2D       ; Pointer: Start of BASIC Variables
A51D: 84 2E     STY $2E       ; Pointer: Start of BASIC Variables
A51F: A4 0B     LDY $0B       ; Input Buffer Pointer/Number of Subscripts
A521: 88        DEY

Jump from $A528:

A522: B9 FC 01  LDA $01FC,Y   ; BASIC Stack Area
A525: 91 5F     STA ($5F),Y   ; Temporary storage for FLPT value
A527: 88        DEY
A528: 10 F8     BPL $A522

Jump from $E1B2:

A52A: 20 59 A6  JSR $A659     ; Perform [new]
A52D: 20 33 A5  JSR $A533     ; Rechain Lines
A530: 4C 80 A4  JMP $A480     ; Input & Identify BASIC Line



 $A533/42291:   Rechain Lines

Jump from $A4F0, $A52D, $E1B8:

A533: A5 2B     LDA $2B       ; Pointer: Start of BASIC Text Area
A535: A4 2C     LDY $2C       ; Pointer: Start of BASIC Text Area
A537: 85 22     STA $22       ; Second Utility Pointer
A539: 84 23     STY $23       ; Second Utility Pointer
A53B: 18        CLC

Jump from $A55D:

A53C: A0 01     LDY #$01
A53E: B1 22     LDA ($22),Y   ; Second Utility Pointer
A540: F0 1D     BEQ $A55F
A542: A0 04     LDY #$04

Jump from $A547:

A544: C8        INY
A545: B1 22     LDA ($22),Y   ; Second Utility Pointer
A547: D0 FB     BNE $A544
A549: C8        INY
A54A: 98        TYA
A54B: 65 22     ADC $22       ; Second Utility Pointer
A54D: AA        TAX
A54E: A0 00     LDY #$00
A550: 91 22     STA ($22),Y   ; Second Utility Pointer
A552: A5 23     LDA $23       ; Second Utility Pointer
A554: 69 00     ADC #$00
A556: C8        INY
A557: 91 22     STA ($22),Y   ; Second Utility Pointer
A559: 86 22     STX $22       ; Second Utility Pointer
A55B: 85 23     STA $23       ; Second Utility Pointer
A55D: 90 DD     BCC $A53C

Jump from $A540:

A55F: 60        RTS



 $A560/42336:   Input Line Into Buffer

Jump from $A483, $AC03:

A560: A2 00     LDX #$00

Jump from $A56F:

A562: 20 12 E1  JSR $E112     ; Input Character
A565: C9 0D     CMP #$0D
A567: F0 0D     BEQ $A576
A569: 9D 00 02  STA $0200,X   ; BASIC Input Buffer (Input Line from Screen)
A56C: E8        INX
A56D: E0 59     CPX #$59
A56F: 90 F1     BCC $A562
A571: A2 17     LDX #$17
A573: 4C 37 A4  JMP $A437     ; Error Routine

Jump from $A567:

A576: 4C CA AA  JMP $AACA     ; -Add zero terminator to string



 $A579/42361:   Tokenise Input Buffer

Jump from $A496, $A49F:

A579: 6C 04 03  JMP ($0304)   ; Vector: BASIC Tokenise Routine
A57C: A6 7A     LDX $7A       ; Pointer: Current Byte of BASIC Text
A57E: A0 04     LDY #$04
A580: 84 0F     STY $0F       ; Flag: DATA scan/List Quote/Garbage collection

Jump from $A58C, $A5E1:

A582: BD 00 02  LDA $0200,X   ; BASIC Input Buffer (Input Line from Screen)
A585: 10 07     BPL $A58E
A587: C9 FF     CMP #$FF
A589: F0 3E     BEQ $A5C9
A58B: E8        INX
A58C: D0 F4     BNE $A582

Jump from $A585:

A58E: C9 20     CMP #$20
A590: F0 37     BEQ $A5C9
A592: 85 08     STA $08       ; Flag: Scan for Quote at end of String
A594: C9 22     CMP #$22
A596: F0 56     BEQ $A5EE
A598: 24 0F     BIT $0F       ; Flag: DATA scan/List Quote/Garbage collection
A59A: 70 2D     BVS $A5C9
A59C: C9 3F     CMP #$3F
A59E: D0 04     BNE $A5A4
A5A0: A9 99     LDA #$99
A5A2: D0 25     BNE $A5C9

Jump from $A59E:

A5A4: C9 30     CMP #$30
A5A6: 90 04     BCC $A5AC
A5A8: C9 3C     CMP #$3C
A5AA: 90 1D     BCC $A5C9

Jump from $A5A6:

A5AC: 84 71     STY $71       ; Pointer: Used during CRUNCH/ASCII conversion
A5AE: A0 00     LDY #$00
A5B0: 84 0B     STY $0B       ; Input Buffer Pointer/Number of Subscripts
A5B2: 88        DEY
A5B3: 86 7A     STX $7A       ; Pointer: Current Byte of BASIC Text
A5B5: CA        DEX

Jump from $A5BF:

A5B6: C8        INY
A5B7: E8        INX

Jump from $A602:

A5B8: BD 00 02  LDA $0200,X   ; BASIC Input Buffer (Input Line from Screen)
A5BB: 38        SEC
A5BC: F9 9E A0  SBC $A09E,Y   ; BASIC Command Keyword Table
A5BF: F0 F5     BEQ $A5B6
A5C1: C9 80     CMP #$80
A5C3: D0 30     BNE $A5F5
A5C5: 05 0B     ORA $0B       ; Input Buffer Pointer/Number of Subscripts

Jump from $A607:

A5C7: A4 71     LDY $71       ; Pointer: Used during CRUNCH/ASCII conversion

Jump from $A589, $A590, $A59A, $A5A2, $A5AA, $A5E8, $A5EC:

A5C9: E8        INX
A5CA: C8        INY
A5CB: 99 FB 01  STA $01FB,Y   ; BASIC Stack Area
A5CE: B9 FB 01  LDA $01FB,Y   ; BASIC Stack Area
A5D1: F0 36     BEQ $A609
A5D3: 38        SEC
A5D4: E9 3A     SBC #$3A
A5D6: F0 04     BEQ $A5DC
A5D8: C9 49     CMP #$49
A5DA: D0 02     BNE $A5DE

Jump from $A5D6:

A5DC: 85 0F     STA $0F       ; Flag: DATA scan/List Quote/Garbage collection

Jump from $A5DA:

A5DE: 38        SEC
A5DF: E9 55     SBC #$55
A5E1: D0 9F     BNE $A582
A5E3: 85 08     STA $08       ; Flag: Scan for Quote at end of String

Jump from $A5F3:

A5E5: BD 00 02  LDA $0200,X   ; BASIC Input Buffer (Input Line from Screen)
A5E8: F0 DF     BEQ $A5C9
A5EA: C5 08     CMP $08       ; Flag: Scan for Quote at end of String
A5EC: F0 DB     BEQ $A5C9

Jump from $A596:

A5EE: C8        INY
A5EF: 99 FB 01  STA $01FB,Y   ; BASIC Stack Area
A5F2: E8        INX
A5F3: D0 F0     BNE $A5E5

Jump from $A5C3:

A5F5: A6 7A     LDX $7A       ; Pointer: Current Byte of BASIC Text
A5F7: E6 0B     INC $0B       ; Input Buffer Pointer/Number of Subscripts

Jump from $A5FD:

A5F9: C8        INY
A5FA: B9 9D A0  LDA $A09D,Y   ; BASIC Operator Vectors
A5FD: 10 FA     BPL $A5F9
A5FF: B9 9E A0  LDA $A09E,Y   ; BASIC Command Keyword Table
A602: D0 B4     BNE $A5B8
A604: BD 00 02  LDA $0200,X   ; BASIC Input Buffer (Input Line from Screen)
A607: 10 BE     BPL $A5C7

Jump from $A5D1:

A609: 99 FD 01  STA $01FD,Y   ; BASIC Stack Area
A60C: C6 7B     DEC $7B       ; Pointer: Current Byte of BASIC Text
A60E: A9 FF     LDA #$FF
A610: 85 7A     STA $7A       ; Pointer: Current Byte of BASIC Text
A612: 60        RTS



 $A613/42515:   Search for Line Number

Jump from $A4A4, $A6A7:

A613: A5 2B     LDA $2B       ; Pointer: Start of BASIC Text Area
A615: A6 2C     LDX $2C       ; Pointer: Start of BASIC Text Area

Jump from $A63E, $A8C0:

A617: A0 01     LDY #$01
A619: 85 5F     STA $5F       ; Temporary storage for FLPT value
A61B: 86 60     STX $60       ; Temporary storage for FLPT value
A61D: B1 5F     LDA ($5F),Y   ; Temporary storage for FLPT value
A61F: F0 1F     BEQ $A640
A621: C8        INY
A622: C8        INY
A623: A5 15     LDA $15       ; Temporary: Integer value
A625: D1 5F     CMP ($5F),Y   ; Temporary storage for FLPT value
A627: 90 18     BCC $A641
A629: F0 03     BEQ $A62E
A62B: 88        DEY
A62C: D0 09     BNE $A637

Jump from $A629:

A62E: A5 14     LDA $14       ; Temporary: Integer value
A630: 88        DEY
A631: D1 5F     CMP ($5F),Y   ; Temporary storage for FLPT value
A633: 90 0C     BCC $A641
A635: F0 0A     BEQ $A641

Jump from $A62C:

A637: 88        DEY
A638: B1 5F     LDA ($5F),Y   ; Temporary storage for FLPT value
A63A: AA        TAX
A63B: 88        DEY
A63C: B1 5F     LDA ($5F),Y   ; Temporary storage for FLPT value
A63E: B0 D7     BCS $A617

Jump from $A61F:

A640: 18        CLC

Jump from $A627, $A633, $A635, $A642, $A6B1, $A6B9:

A641: 60        RTS



 $A642/42562:   Perform [new]

A642: D0 FD     BNE $A641     ; Search for Line Number

Jump from $E444:

A644: A9 00     LDA #$00
A646: A8        TAY
A647: 91 2B     STA ($2B),Y   ; Pointer: Start of BASIC Text Area
A649: C8        INY
A64A: 91 2B     STA ($2B),Y   ; Pointer: Start of BASIC Text Area
A64C: A5 2B     LDA $2B       ; Pointer: Start of BASIC Text Area
A64E: 18        CLC
A64F: 69 02     ADC #$02
A651: 85 2D     STA $2D       ; Pointer: Start of BASIC Variables
A653: A5 2C     LDA $2C       ; Pointer: Start of BASIC Text Area
A655: 69 00     ADC #$00
A657: 85 2E     STA $2E       ; Pointer: Start of BASIC Variables

Jump from $A4ED, $A52A, $A87A:

A659: 20 8E A6  JSR $A68E     ; Reset TXTPTR
A65C: A9 00     LDA #$00


Kernal-Reference:

 BIT $A650   : $EFC4


 $A65E/42590:   Perform [clr]

A65E: D0 2D     BNE $A68D

Jump from $A87D:

A660: 20 E7 FF  JSR $FFE7     ; Close All Channels And Files

Jump from $E101:

A663: A5 37     LDA $37       ; Pointer: Highest Address available to BASIC
A665: A4 38     LDY $38       ; Pointer: Highest Address available to BASIC
A667: 85 33     STA $33       ; Pointer: Bottom of String space
A669: 84 34     STY $34       ; Pointer: Bottom of String space
A66B: A5 2D     LDA $2D       ; Pointer: Start of BASIC Variables
A66D: A4 2E     LDY $2E       ; Pointer: Start of BASIC Variables
A66F: 85 2F     STA $2F       ; Pointer: Start of BASIC Arrays
A671: 84 30     STY $30       ; Pointer: Start of BASIC Arrays
A673: 85 31     STA $31       ; Pointer: End of BASIC Arrays + 1
A675: 84 32     STY $32       ; Pointer: End of BASIC Arrays + 1

Jump from $E1BB:

A677: 20 1D A8  JSR $A81D     ; Perform [restore]

Jump from $A462, $E382:

A67A: A2 19     LDX #$19
A67C: 86 16     STX $16       ; Pointer: Temporary String Stack
A67E: 68        PLA
A67F: A8        TAY
A680: 68        PLA
A681: A2 FA     LDX #$FA
A683: 9A        TXS
A684: 48        PHA
A685: 98        TYA
A686: 48        PHA
A687: A9 00     LDA #$00
A689: 85 3E     STA $3E       ; Pointer: BASIC Statement for CONT
A68B: 85 10     STA $10       ; Flag: Subscript reference/User Function call

Jump from $A65E, $A6A2:

A68D: 60        RTS



 $A68E/42638:   Reset TXTPTR

Jump from $A659, $E1B5:

A68E: 18        CLC
A68F: A5 2B     LDA $2B       ; Pointer: Start of BASIC Text Area
A691: 69 FF     ADC #$FF
A693: 85 7A     STA $7A       ; Pointer: Current Byte of BASIC Text
A695: A5 2C     LDA $2C       ; Pointer: Start of BASIC Text Area
A697: 69 FF     ADC #$FF
A699: 85 7B     STA $7B       ; Pointer: Current Byte of BASIC Text
A69B: 60        RTS



 $A69C/42652:   Perform [list]

A69C: 90 06     BCC $A6A4
A69E: F0 04     BEQ $A6A4
A6A0: C9 AB     CMP #$AB
A6A2: D0 E9     BNE $A68D     ; Perform [clr]

Jump from $A69C, $A69E:

A6A4: 20 6B A9  JSR $A96B     ; Fetch linnum From BASIC
A6A7: 20 13 A6  JSR $A613     ; Search for Line Number
A6AA: 20 79 00  JSR $0079     ; CHRGOT: Get same Byte again
A6AD: F0 0C     BEQ $A6BB
A6AF: C9 AB     CMP #$AB
A6B1: D0 8E     BNE $A641     ; Search for Line Number
A6B3: 20 73 00  JSR $0073     ; CHRGET: Get next Byte of BASIC Text
A6B6: 20 6B A9  JSR $A96B     ; Fetch linnum From BASIC
A6B9: D0 86     BNE $A641     ; Search for Line Number

Jump from $A6AD:

A6BB: 68        PLA
A6BC: 68        PLA
A6BD: A5 14     LDA $14       ; Temporary: Integer value
A6BF: 05 15     ORA $15       ; Temporary: Integer value
A6C1: D0 06     BNE $A6C9
A6C3: A9 FF     LDA #$FF
A6C5: 85 14     STA $14       ; Temporary: Integer value
A6C7: 85 15     STA $15       ; Temporary: Integer value

Jump from $A6C1, $A712:

A6C9: A0 01     LDY #$01
A6CB: 84 0F     STY $0F       ; Flag: DATA scan/List Quote/Garbage collection
A6CD: B1 5F     LDA ($5F),Y   ; Temporary storage for FLPT value
A6CF: F0 43     BEQ $A714
A6D1: 20 2C A8  JSR $A82C     ; Perform [stop]
A6D4: 20 D7 AA  JSR $AAD7     ; Output CR/LF
A6D7: C8        INY
A6D8: B1 5F     LDA ($5F),Y   ; Temporary storage for FLPT value
A6DA: AA        TAX
A6DB: C8        INY
A6DC: B1 5F     LDA ($5F),Y   ; Temporary storage for FLPT value
A6DE: C5 15     CMP $15       ; Temporary: Integer value
A6E0: D0 04     BNE $A6E6
A6E2: E4 14     CPX $14       ; Temporary: Integer value
A6E4: F0 02     BEQ $A6E8

Jump from $A6E0:

A6E6: B0 2C     BCS $A714

Jump from $A6E4:

A6E8: 84 49     STY $49       ; Pointer: Index Variable for FOR/NEXT loop
A6EA: 20 CD BD  JSR $BDCD     ; Output Positive Integer in A/X
A6ED: A9 20     LDA #$20

Jump from $A73B:

A6EF: A4 49     LDY $49       ; Pointer: Index Variable for FOR/NEXT loop
A6F1: 29 7F     AND #$7F

Jump from $A71A, $A71E, $A722:

A6F3: 20 47 AB  JSR $AB47     ; Output Format Character
A6F6: C9 22     CMP #$22
A6F8: D0 06     BNE $A700
A6FA: A5 0F     LDA $0F       ; Flag: DATA scan/List Quote/Garbage collection
A6FC: 49 FF     EOR #$FF
A6FE: 85 0F     STA $0F       ; Flag: DATA scan/List Quote/Garbage collection

Jump from $A6F8:

A700: C8        INY
A701: F0 11     BEQ $A714
A703: B1 5F     LDA ($5F),Y   ; Temporary storage for FLPT value
A705: D0 10     BNE $A717     ; Handle LIST Character
A707: A8        TAY
A708: B1 5F     LDA ($5F),Y   ; Temporary storage for FLPT value
A70A: AA        TAX
A70B: C8        INY
A70C: B1 5F     LDA ($5F),Y   ; Temporary storage for FLPT value
A70E: 86 5F     STX $5F       ; Temporary storage for FLPT value
A710: 85 60     STA $60       ; Temporary storage for FLPT value
A712: D0 B5     BNE $A6C9

Jump from $A6CF, $A6E6, $A701:

A714: 4C 86 E3  JMP $E386     ; BASIC Warm Start [RUNSTOP-RESTORE]



 $A717/42775:   Handle LIST Character

Jump from $A705:

A717: 6C 06 03  JMP ($0306)   ; Vector: BASIC LIST Routine
A71A: 10 D7     BPL $A6F3     ; Perform [list]
A71C: C9 FF     CMP #$FF
A71E: F0 D3     BEQ $A6F3     ; Perform [list]
A720: 24 0F     BIT $0F       ; Flag: DATA scan/List Quote/Garbage collection
A722: 30 CF     BMI $A6F3     ; Perform [list]
A724: 38        SEC
A725: E9 7F     SBC #$7F
A727: AA        TAX
A728: 84 49     STY $49       ; Pointer: Index Variable for FOR/NEXT loop
A72A: A0 FF     LDY #$FF

Jump from $A735:

A72C: CA        DEX
A72D: F0 08     BEQ $A737

Jump from $A733:

A72F: C8        INY
A730: B9 9E A0  LDA $A09E,Y   ; BASIC Command Keyword Table
A733: 10 FA     BPL $A72F
A735: 30 F5     BMI $A72C

Jump from $A72D, $A740:

A737: C8        INY
A738: B9 9E A0  LDA $A09E,Y   ; BASIC Command Keyword Table
A73B: 30 B2     BMI $A6EF     ; Perform [list]
A73D: 20 47 AB  JSR $AB47     ; Output Format Character
A740: D0 F5     BNE $A737



 $A742/42818:   Perform [for]

A742: A9 80     LDA #$80
A744: 85 10     STA $10       ; Flag: Subscript reference/User Function call
A746: 20 A5 A9  JSR $A9A5     ; Perform [let]
A749: 20 8A A3  JSR $A38A     ; Find FOR/GOSUB Entry on Stack
A74C: D0 05     BNE $A753
A74E: 8A        TXA
A74F: 69 0F     ADC #$0F
A751: AA        TAX
A752: 9A        TXS

Jump from $A74C:

A753: 68        PLA
A754: 68        PLA
A755: A9 09     LDA #$09
A757: 20 FB A3  JSR $A3FB     ; Check Stack Depth
A75A: 20 06 A9  JSR $A906     ; Search for Next Statement / Line
A75D: 18        CLC
A75E: 98        TYA
A75F: 65 7A     ADC $7A       ; Pointer: Current Byte of BASIC Text
A761: 48        PHA
A762: A5 7B     LDA $7B       ; Pointer: Current Byte of BASIC Text
A764: 69 00     ADC #$00
A766: 48        PHA
A767: A5 3A     LDA $3A       ; Current BASIC Line number
A769: 48        PHA
A76A: A5 39     LDA $39       ; Current BASIC Line number
A76C: 48        PHA
A76D: A9 A4     LDA #$A4
A76F: 20 FF AE  JSR $AEFF     ; Test ','
A772: 20 8D AD  JSR $AD8D     ; Confirm Result
A775: 20 8A AD  JSR $AD8A     ; Confirm Result
A778: A5 66     LDA $66       ; FAC Sign
A77A: 09 7F     ORA #$7F
A77C: 25 62     AND $62       ; FAC Mantissa
A77E: 85 62     STA $62       ; FAC Mantissa
A780: A9 8B     LDA #$8B
A782: A0 A7     LDY #$A7
A784: 85 22     STA $22       ; Second Utility Pointer
A786: 84 23     STY $23       ; Second Utility Pointer
A788: 4C 43 AE  JMP $AE43     ; Evaluate Expression in Text
A78B: A9 BC     LDA #$BC
A78D: A0 B9     LDY #$B9
A78F: 20 A2 BB  JSR $BBA2     ; Load FAC#1 From Memory
A792: 20 79 00  JSR $0079     ; CHRGOT: Get same Byte again
A795: C9 A9     CMP #$A9
A797: D0 06     BNE $A79F
A799: 20 73 00  JSR $0073     ; CHRGET: Get next Byte of BASIC Text
A79C: 20 8A AD  JSR $AD8A     ; Confirm Result

Jump from $A797:

A79F: 20 2B BC  JSR $BC2B     ; Check Sign of FAC#1
A7A2: 20 38 AE  JSR $AE38     ; Evaluate Expression in Text
A7A5: A5 4A     LDA $4A       ; Pointer: Index Variable for FOR/NEXT loop
A7A7: 48        PHA
A7A8: A5 49     LDA $49       ; Pointer: Index Variable for FOR/NEXT loop
A7AA: 48        PHA
A7AB: A9 81     LDA #$81
A7AD: 48        PHA



 $A7AE/42926:   BASIC Warm Start

Jump from $A7EA, $A89D, $AD75:

A7AE: 20 2C A8  JSR $A82C     ; Perform [stop]
A7B1: A5 7A     LDA $7A       ; Pointer: Current Byte of BASIC Text
A7B3: A4 7B     LDY $7B       ; Pointer: Current Byte of BASIC Text
A7B5: C0 02     CPY #$02
A7B7: EA        NOP
A7B8: F0 04     BEQ $A7BE
A7BA: 85 3D     STA $3D       ; Pointer: BASIC Statement for CONT
A7BC: 84 3E     STY $3E       ; Pointer: BASIC Statement for CONT

Jump from $A7B8:

A7BE: A0 00     LDY #$00
A7C0: B1 7A     LDA ($7A),Y   ; Pointer: Current Byte of BASIC Text
A7C2: D0 43     BNE $A807     ; Perform BASIC Keyword



 $A7C4/42948:   Check End of Program

A7C4: A0 02     LDY #$02
A7C6: B1 7A     LDA ($7A),Y   ; Pointer: Current Byte of BASIC Text
A7C8: 18        CLC
A7C9: D0 03     BNE $A7CE
A7CB: 4C 4B A8  JMP $A84B     ; Perform Break

Jump from $A7C9:

A7CE: C8        INY
A7CF: B1 7A     LDA ($7A),Y   ; Pointer: Current Byte of BASIC Text
A7D1: 85 39     STA $39       ; Current BASIC Line number
A7D3: C8        INY
A7D4: B1 7A     LDA ($7A),Y   ; Pointer: Current Byte of BASIC Text
A7D6: 85 3A     STA $3A       ; Current BASIC Line number
A7D8: 98        TYA
A7D9: 65 7A     ADC $7A       ; Pointer: Current Byte of BASIC Text
A7DB: 85 7A     STA $7A       ; Pointer: Current Byte of BASIC Text
A7DD: 90 02     BCC $A7E1     ; Prepare to execute statement
A7DF: E6 7B     INC $7B       ; Pointer: Current Byte of BASIC Text



 $A7E1/42977:   Prepare to execute statement

Jump from $A499, $A7DD, $A809:

A7E1: 6C 08 03  JMP ($0308)   ; Vector: BASIC Character dispatch Routine
A7E4: 20 73 00  JSR $0073     ; CHRGET: Get next Byte of BASIC Text
A7E7: 20 ED A7  JSR $A7ED     ; Perform BASIC Keyword
A7EA: 4C AE A7  JMP $A7AE     ; BASIC Warm Start



 $A7ED/42989:   Perform BASIC Keyword

Jump from $A7E7, $A948:

A7ED: F0 3C     BEQ $A82B     ; Perform [restore]

Jump from $A95C:

A7EF: E9 80     SBC #$80
A7F1: 90 11     BCC $A804
A7F3: C9 23     CMP #$23
A7F5: B0 17     BCS $A80E
A7F7: 0A        ASL
A7F8: A8        TAY
A7F9: B9 0D A0  LDA $A00D,Y   ; BASIC Command Vectors - 1
A7FC: 48        PHA
A7FD: B9 0C A0  LDA $A00C,Y   ; BASIC Command Vectors - 1
A800: 48        PHA
A801: 4C 73 00  JMP $0073     ; CHRGET: Get next Byte of BASIC Text

Jump from $A7F1:

A804: 4C A5 A9  JMP $A9A5     ; Perform [let]

Jump from $A7C2:

A807: C9 3A     CMP #$3A
A809: F0 D6     BEQ $A7E1     ; Prepare to execute statement

Jump from $A810:

A80B: 4C 08 AF  JMP $AF08     ; Output ?SYNTAX Error

Jump from $A7F5:

A80E: C9 4B     CMP #$4B
A810: D0 F9     BNE $A80B
A812: 20 73 00  JSR $0073     ; CHRGET: Get next Byte of BASIC Text
A815: A9 A4     LDA #$A4
A817: 20 FF AE  JSR $AEFF     ; Test ','
A81A: 4C A0 A8  JMP $A8A0     ; Perform [goto]



 $A81D/43037:   Perform [restore]

Jump from $A677:

A81D: 38        SEC
A81E: A5 2B     LDA $2B       ; Pointer: Start of BASIC Text Area
A820: E9 01     SBC #$01
A822: A4 2C     LDY $2C       ; Pointer: Start of BASIC Text Area
A824: B0 01     BCS $A827
A826: 88        DEY

Jump from $A824, $ACE7:

A827: 85 41     STA $41       ; Pointer: Used by READ - current DATA Item
A829: 84 42     STY $42       ; Pointer: Used by READ - current DATA Item

Jump from $A7ED:

A82B: 60        RTS



 $A82C/43052:   Perform [stop]

Jump from $A6D1, $A7AE:

A82C: 20 E1 FF  JSR $FFE1     ; Test-Stop Vector



 $A82F/43055:   Perform [end]

A82F: B0 01     BCS $A832     ; Perform Break



 $A831/43057:   Perform Break

A831: 18        CLC

Jump from $A82F:

A832: D0 3C     BNE $A870     ; Perform [cont]
A834: A5 7A     LDA $7A       ; Pointer: Current Byte of BASIC Text
A836: A4 7B     LDY $7B       ; Pointer: Current Byte of BASIC Text
A838: A6 3A     LDX $3A       ; Current BASIC Line number
A83A: E8        INX
A83B: F0 0C     BEQ $A849
A83D: 85 3D     STA $3D       ; Pointer: BASIC Statement for CONT
A83F: 84 3E     STY $3E       ; Pointer: BASIC Statement for CONT
A841: A5 39     LDA $39       ; Current BASIC Line number
A843: A4 3A     LDY $3A       ; Current BASIC Line number
A845: 85 3B     STA $3B       ; Previous BASIC Line number
A847: 84 3C     STY $3C       ; Previous BASIC Line number

Jump from $A83B:

A849: 68        PLA
A84A: 68        PLA

Jump from $A7CB:

A84B: A9 81     LDA #$81
A84D: A0 A3     LDY #$A3
A84F: 90 03     BCC $A854
A851: 4C 69 A4  JMP $A469     ; Break Entry

Jump from $A84F:

A854: 4C 86 E3  JMP $E386     ; BASIC Warm Start [RUNSTOP-RESTORE]



 $A857/43095:   Perform [cont]

A857: D0 17     BNE $A870
A859: A2 1A     LDX #$1A
A85B: A4 3E     LDY $3E       ; Pointer: BASIC Statement for CONT
A85D: D0 03     BNE $A862
A85F: 4C 37 A4  JMP $A437     ; Error Routine

Jump from $A85D:

A862: A5 3D     LDA $3D       ; Pointer: BASIC Statement for CONT
A864: 85 7A     STA $7A       ; Pointer: Current Byte of BASIC Text
A866: 84 7B     STY $7B       ; Pointer: Current Byte of BASIC Text
A868: A5 3B     LDA $3B       ; Previous BASIC Line number
A86A: A4 3C     LDY $3C       ; Previous BASIC Line number
A86C: 85 39     STA $39       ; Current BASIC Line number
A86E: 84 3A     STY $3A       ; Current BASIC Line number

Jump from $A857, $A832:

A870: 60        RTS



 $A871/43121:   Perform [run]

A871: 08        PHP
A872: A9 00     LDA #$00
A874: 20 90 FF  JSR $FF90     ; Control OS Messages
A877: 28        PLP
A878: D0 03     BNE $A87D
A87A: 4C 59 A6  JMP $A659     ; Perform [new]

Jump from $A878:

A87D: 20 60 A6  JSR $A660     ; Perform [clr]
A880: 4C 97 A8  JMP $A897     ; Perform [gosub]



 $A883/43139:   Perform [gosub]

A883: A9 03     LDA #$03
A885: 20 FB A3  JSR $A3FB     ; Check Stack Depth
A888: A5 7B     LDA $7B       ; Pointer: Current Byte of BASIC Text
A88A: 48        PHA
A88B: A5 7A     LDA $7A       ; Pointer: Current Byte of BASIC Text
A88D: 48        PHA
A88E: A5 3A     LDA $3A       ; Current BASIC Line number
A890: 48        PHA
A891: A5 39     LDA $39       ; Current BASIC Line number
A893: 48        PHA
A894: A9 8D     LDA #$8D
A896: 48        PHA

Jump from $A880:

A897: 20 79 00  JSR $0079     ; CHRGOT: Get same Byte again
A89A: 20 A0 A8  JSR $A8A0     ; Perform [goto]
A89D: 4C AE A7  JMP $A7AE     ; BASIC Warm Start



 $A8A0/43168:   Perform [goto]

Jump from $A81A, $A89A, $A945:

A8A0: 20 6B A9  JSR $A96B     ; Fetch linnum From BASIC
A8A3: 20 09 A9  JSR $A909     ; Search for Next Statement / Line
A8A6: 38        SEC
A8A7: A5 39     LDA $39       ; Current BASIC Line number
A8A9: E5 14     SBC $14       ; Temporary: Integer value
A8AB: A5 3A     LDA $3A       ; Current BASIC Line number
A8AD: E5 15     SBC $15       ; Temporary: Integer value
A8AF: B0 0B     BCS $A8BC
A8B1: 98        TYA
A8B2: 38        SEC
A8B3: 65 7A     ADC $7A       ; Pointer: Current Byte of BASIC Text
A8B5: A6 7B     LDX $7B       ; Pointer: Current Byte of BASIC Text
A8B7: 90 07     BCC $A8C0
A8B9: E8        INX
A8BA: B0 04     BCS $A8C0

Jump from $A8AF:

A8BC: A5 2B     LDA $2B       ; Pointer: Start of BASIC Text Area
A8BE: A6 2C     LDX $2C       ; Pointer: Start of BASIC Text Area

Jump from $A8B7, $A8BA:

A8C0: 20 17 A6  JSR $A617     ; Search for Line Number
A8C3: 90 1E     BCC $A8E3     ; Perform [return]
A8C5: A5 5F     LDA $5F       ; Temporary storage for FLPT value
A8C7: E9 01     SBC #$01
A8C9: 85 7A     STA $7A       ; Pointer: Current Byte of BASIC Text
A8CB: A5 60     LDA $60       ; Temporary storage for FLPT value
A8CD: E9 00     SBC #$00
A8CF: 85 7B     STA $7B       ; Pointer: Current Byte of BASIC Text

Jump from $A8D2:

A8D1: 60        RTS



 $A8D2/43218:   Perform [return]

A8D2: D0 FD     BNE $A8D1     ; Perform [goto]
A8D4: A9 FF     LDA #$FF
A8D6: 85 4A     STA $4A       ; Pointer: Index Variable for FOR/NEXT loop
A8D8: 20 8A A3  JSR $A38A     ; Find FOR/GOSUB Entry on Stack
A8DB: 9A        TXS
A8DC: C9 8D     CMP #$8D
A8DE: F0 0B     BEQ $A8EB
A8E0: A2 0C     LDX #$0C
A8E2: 2C        .BYTE $2C

Jump from $A8C3:

A8E3: A2 11     LDX #$11
A8E5: 4C 37 A4  JMP $A437     ; Error Routine

Jump from $A955:

A8E8: 4C 08 AF  JMP $AF08     ; Output ?SYNTAX Error

Jump from $A8DE:

A8EB: 68        PLA
A8EC: 68        PLA
A8ED: 85 39     STA $39       ; Current BASIC Line number
A8EF: 68        PLA
A8F0: 85 3A     STA $3A       ; Current BASIC Line number
A8F2: 68        PLA
A8F3: 85 7A     STA $7A       ; Pointer: Current Byte of BASIC Text
A8F5: 68        PLA
A8F6: 85 7B     STA $7B       ; Pointer: Current Byte of BASIC Text



 $A8F8/43256:   Perform [data]

Jump from $ABE7, $B3DB:

A8F8: 20 06 A9  JSR $A906     ; Search for Next Statement / Line

Jump from $A93E, $ABF6, $ACD1:

A8FB: 98        TYA
A8FC: 18        CLC
A8FD: 65 7A     ADC $7A       ; Pointer: Current Byte of BASIC Text
A8FF: 85 7A     STA $7A       ; Pointer: Current Byte of BASIC Text
A901: 90 02     BCC $A905
A903: E6 7B     INC $7B       ; Pointer: Current Byte of BASIC Text

Jump from $A901, $A91B, $A91F:

A905: 60        RTS



 $A906/43270:   Search for Next Statement / Line

Jump from $A75A, $A8F8, $ABF3, $ACB8:

A906: A2 3A     LDX #$3A
A908: 2C        .BYTE $2C

Jump from $A8A3, $A93B:

A909: A2 00     LDX #$00
A90B: 86 07     STX $07       ; Temporary Integer during OR/AND
A90D: A0 00     LDY #$00
A90F: 84 08     STY $08       ; Flag: Scan for Quote at end of String

Jump from $A926:

A911: A5 08     LDA $08       ; Flag: Scan for Quote at end of String
A913: A6 07     LDX $07       ; Temporary Integer during OR/AND
A915: 85 07     STA $07       ; Temporary Integer during OR/AND
A917: 86 08     STX $08       ; Flag: Scan for Quote at end of String

Jump from $A924:

A919: B1 7A     LDA ($7A),Y   ; Pointer: Current Byte of BASIC Text
A91B: F0 E8     BEQ $A905     ; Perform [data]
A91D: C5 08     CMP $08       ; Flag: Scan for Quote at end of String
A91F: F0 E4     BEQ $A905     ; Perform [data]
A921: C8        INY
A922: C9 22     CMP #$22
A924: D0 F3     BNE $A919
A926: F0 E9     BEQ $A911



 $A928/43304:   Perform [if]

A928: 20 9E AD  JSR $AD9E     ; Evaluate Expression in Text
A92B: 20 79 00  JSR $0079     ; CHRGOT: Get same Byte again
A92E: C9 89     CMP #$89
A930: F0 05     BEQ $A937
A932: A9 A7     LDA #$A7
A934: 20 FF AE  JSR $AEFF     ; Test ','

Jump from $A930:

A937: A5 61     LDA $61       ; FAC Exponent
A939: D0 05     BNE $A940     ; Perform [rem]



 $A93B/43323:   Perform [rem]

A93B: 20 09 A9  JSR $A909     ; Search for Next Statement / Line
A93E: F0 BB     BEQ $A8FB     ; Perform [data]

Jump from $A939:

A940: 20 79 00  JSR $0079     ; CHRGOT: Get same Byte again
A943: B0 03     BCS $A948
A945: 4C A0 A8  JMP $A8A0     ; Perform [goto]

Jump from $A943:

A948: 4C ED A7  JMP $A7ED     ; Perform BASIC Keyword



 $A94B/43339:   Perform [on]

A94B: 20 9E B7  JSR $B79E     ; Evaluate Text to 1 Byte in XR
A94E: 48        PHA
A94F: C9 8D     CMP #$8D
A951: F0 04     BEQ $A957

Jump from $A97D:

A953: C9 89     CMP #$89
A955: D0 91     BNE $A8E8     ; Perform [return]

Jump from $A951, $A967:

A957: C6 65     DEC $65       ; FAC Mantissa
A959: D0 04     BNE $A95F
A95B: 68        PLA
A95C: 4C EF A7  JMP $A7EF     ; Perform BASIC Keyword

Jump from $A959:

A95F: 20 73 00  JSR $0073     ; CHRGET: Get next Byte of BASIC Text
A962: 20 6B A9  JSR $A96B     ; Fetch linnum From BASIC
A965: C9 2C     CMP #$2C
A967: F0 EE     BEQ $A957
A969: 68        PLA

Jump from $A971:

A96A: 60        RTS



 $A96B/43371:   Fetch linnum From BASIC

Jump from $A49C, $A6A4, $A6B6, $A8A0, $A962:

A96B: A2 00     LDX #$00
A96D: 86 14     STX $14       ; Temporary: Integer value
A96F: 86 15     STX $15       ; Temporary: Integer value

Jump from $A9A2:

A971: B0 F7     BCS $A96A     ; Perform [on]
A973: E9 2F     SBC #$2F
A975: 85 07     STA $07       ; Temporary Integer during OR/AND
A977: A5 15     LDA $15       ; Temporary: Integer value
A979: 85 22     STA $22       ; Second Utility Pointer
A97B: C9 19     CMP #$19
A97D: B0 D4     BCS $A953     ; Perform [on]
A97F: A5 14     LDA $14       ; Temporary: Integer value
A981: 0A        ASL
A982: 26 22     ROL $22       ; Second Utility Pointer
A984: 0A        ASL
A985: 26 22     ROL $22       ; Second Utility Pointer
A987: 65 14     ADC $14       ; Temporary: Integer value
A989: 85 14     STA $14       ; Temporary: Integer value
A98B: A5 22     LDA $22       ; Second Utility Pointer
A98D: 65 15     ADC $15       ; Temporary: Integer value
A98F: 85 15     STA $15       ; Temporary: Integer value
A991: 06 14     ASL $14       ; Temporary: Integer value
A993: 26 15     ROL $15       ; Temporary: Integer value
A995: A5 14     LDA $14       ; Temporary: Integer value
A997: 65 07     ADC $07       ; Temporary Integer during OR/AND
A999: 85 14     STA $14       ; Temporary: Integer value
A99B: 90 02     BCC $A99F
A99D: E6 15     INC $15       ; Temporary: Integer value

Jump from $A99B:

A99F: 20 73 00  JSR $0073     ; CHRGET: Get next Byte of BASIC Text
A9A2: 4C 71 A9  JMP $A971



 $A9A5/43429:   Perform [let]

Jump from $A746, $A804:

A9A5: 20 8B B0  JSR $B08B     ; Identify Variable
A9A8: 85 49     STA $49       ; Pointer: Index Variable for FOR/NEXT loop
A9AA: 84 4A     STY $4A       ; Pointer: Index Variable for FOR/NEXT loop
A9AC: A9 B2     LDA #$B2
A9AE: 20 FF AE  JSR $AEFF     ; Test ','
A9B1: A5 0E     LDA $0E       ; Data type Flag
A9B3: 48        PHA
A9B4: A5 0D     LDA $0D       ; Data type Flag
A9B6: 48        PHA
A9B7: 20 9E AD  JSR $AD9E     ; Evaluate Expression in Text
A9BA: 68        PLA
A9BB: 2A        ROL
A9BC: 20 90 AD  JSR $AD90     ; Confirm Result
A9BF: D0 18     BNE $A9D9     ; Assign String
A9C1: 68        PLA

Jump from $AC8E:

A9C2: 10 12     BPL $A9D6     ; Assign Floating Point



 $A9C4/43460:   Assign Integer

A9C4: 20 1B BC  JSR $BC1B     ; Round FAC#1
A9C7: 20 BF B1  JSR $B1BF     ; FAC#1 to Positive Integer
A9CA: A0 00     LDY #$00
A9CC: A5 64     LDA $64       ; FAC Mantissa
A9CE: 91 49     STA ($49),Y   ; Pointer: Index Variable for FOR/NEXT loop
A9D0: C8        INY
A9D1: A5 65     LDA $65       ; FAC Mantissa
A9D3: 91 49     STA ($49),Y   ; Pointer: Index Variable for FOR/NEXT loop
A9D5: 60        RTS



 $A9D6/43478:   Assign Floating Point

Jump from $A9C2:

A9D6: 4C D0 BB  JMP $BBD0     ; Store FAC#1 in Memory



 $A9D9/43481:   Assign String

Jump from $A9BF:

A9D9: 68        PLA

Jump from $AC83:

A9DA: A4 4A     LDY $4A       ; Pointer: Index Variable for FOR/NEXT loop
A9DC: C0 BF     CPY #$BF
A9DE: D0 4C     BNE $AA2C     ; Add Digit to FAC#1
A9E0: 20 A6 B6  JSR $B6A6     ; Perform String Housekeeping



 $A9E3/43491:   Assign TI$

A9E3: C9 06     CMP #$06
A9E5: D0 3D     BNE $AA24
A9E7: A0 00     LDY #$00
A9E9: 84 61     STY $61       ; FAC Exponent
A9EB: 84 66     STY $66       ; FAC Sign

Jump from $AA0C:

A9ED: 84 71     STY $71       ; Pointer: Used during CRUNCH/ASCII conversion
A9EF: 20 1D AA  JSR $AA1D
A9F2: 20 E2 BA  JSR $BAE2     ; Multiply FAC#1 by 10
A9F5: E6 71     INC $71       ; Pointer: Used during CRUNCH/ASCII conversion
A9F7: A4 71     LDY $71       ; Pointer: Used during CRUNCH/ASCII conversion
A9F9: 20 1D AA  JSR $AA1D
A9FC: 20 0C BC  JSR $BC0C     ; Copy FAC#1 into FAC#2
A9FF: AA        TAX
AA00: F0 05     BEQ $AA07
AA02: E8        INX
AA03: 8A        TXA
AA04: 20 ED BA  JSR $BAED     ; Multiply FAC#1 by 10

Jump from $AA00:

AA07: A4 71     LDY $71       ; Pointer: Used during CRUNCH/ASCII conversion
AA09: C8        INY
AA0A: C0 06     CPY #$06
AA0C: D0 DF     BNE $A9ED
AA0E: 20 E2 BA  JSR $BAE2     ; Multiply FAC#1 by 10
AA11: 20 9B BC  JSR $BC9B     ; Convert FAC#1 to Integer
AA14: A6 64     LDX $64       ; FAC Mantissa
AA16: A4 63     LDY $63       ; FAC Mantissa
AA18: A5 65     LDA $65       ; FAC Mantissa
AA1A: 4C DB FF  JMP $FFDB     ; Set Real-Time Clock

Jump from $A9EF, $A9F9:

AA1D: B1 22     LDA ($22),Y   ; Second Utility Pointer
AA1F: 20 80 00  JSR $0080     ; CHRGOT: Get same Byte again
AA22: 90 03     BCC $AA27

Jump from $A9E5:

AA24: 4C 48 B2  JMP $B248     ; ?ILLEGAL QUANTITY

Jump from $AA22:

AA27: E9 2F     SBC #$2F
AA29: 4C 7E BD  JMP $BD7E     ; Convert ASCII String to a Number in FAC



 $AA2C/43564:   Add Digit to FAC#1

Jump from $A9DE:

AA2C: A0 02     LDY #$02
AA2E: B1 64     LDA ($64),Y   ; FAC Mantissa
AA30: C5 34     CMP $34       ; Pointer: Bottom of String space
AA32: 90 17     BCC $AA4B
AA34: D0 07     BNE $AA3D
AA36: 88        DEY
AA37: B1 64     LDA ($64),Y   ; FAC Mantissa
AA39: C5 33     CMP $33       ; Pointer: Bottom of String space
AA3B: 90 0E     BCC $AA4B

Jump from $AA34:

AA3D: A4 65     LDY $65       ; FAC Mantissa
AA3F: C4 2E     CPY $2E       ; Pointer: Start of BASIC Variables
AA41: 90 08     BCC $AA4B
AA43: D0 0D     BNE $AA52
AA45: A5 64     LDA $64       ; FAC Mantissa
AA47: C5 2D     CMP $2D       ; Pointer: Start of BASIC Variables
AA49: B0 07     BCS $AA52

Jump from $AA32, $AA3B, $AA41:

AA4B: A5 64     LDA $64       ; FAC Mantissa
AA4D: A4 65     LDY $65       ; FAC Mantissa
AA4F: 4C 68 AA  JMP $AA68

Jump from $AA43, $AA49:

AA52: A0 00     LDY #$00
AA54: B1 64     LDA ($64),Y   ; FAC Mantissa
AA56: 20 75 B4  JSR $B475     ; Evaluate <str$>
AA59: A5 50     LDA $50       ; Temporary storage for FLPT value
AA5B: A4 51     LDY $51       ; Temporary storage for FLPT value
AA5D: 85 6F     STA $6F       ; Sign of result of Arithmetic Evaluation
AA5F: 84 70     STY $70       ; FAC low-order rounding
AA61: 20 7A B6  JSR $B67A     ; Store String in High RAM
AA64: A9 61     LDA #$61
AA66: A0 00     LDY #$00

Jump from $AA4F:

AA68: 85 50     STA $50       ; Temporary storage for FLPT value
AA6A: 84 51     STY $51       ; Temporary storage for FLPT value
AA6C: 20 DB B6  JSR $B6DB     ; Clean Descriptor Stack
AA6F: A0 00     LDY #$00
AA71: B1 50     LDA ($50),Y   ; Temporary storage for FLPT value
AA73: 91 49     STA ($49),Y   ; Pointer: Index Variable for FOR/NEXT loop
AA75: C8        INY
AA76: B1 50     LDA ($50),Y   ; Temporary storage for FLPT value
AA78: 91 49     STA ($49),Y   ; Pointer: Index Variable for FOR/NEXT loop
AA7A: C8        INY
AA7B: B1 50     LDA ($50),Y   ; Temporary storage for FLPT value
AA7D: 91 49     STA ($49),Y   ; Pointer: Index Variable for FOR/NEXT loop
AA7F: 60        RTS



 $AA80/43648:   Perform [print#]

AA80: 20 86 AA  JSR $AA86     ; Perform [cmd]
AA83: 4C B5 AB  JMP $ABB5     ; Perform [input#]



 $AA86/43654:   Perform [cmd]

Jump from $AA80:

AA86: 20 9E B7  JSR $B79E     ; Evaluate Text to 1 Byte in XR
AA89: F0 05     BEQ $AA90
AA8B: A9 2C     LDA #$2C
AA8D: 20 FF AE  JSR $AEFF     ; Test ','

Jump from $AA89:

AA90: 08        PHP
AA91: 86 13     STX $13       ; File number of current Input Device
AA93: 20 18 E1  JSR $E118     ; Set Up For Output
AA96: 28        PLP
AA97: 4C A0 AA  JMP $AAA0     ; Perform [print]



 $AA9A/43674:   Print String From Memory

Jump from $AABA:

AA9A: 20 21 AB  JSR $AB21     ; Output String

Jump from $AAC8:

AA9D: 20 79 00  JSR $0079     ; CHRGOT: Get same Byte again



 $AAA0/43680:   Perform [print]

Jump from $AA97:

AAA0: F0 35     BEQ $AAD7     ; Output CR/LF

Jump from $AB16:

AAA2: F0 43     BEQ $AAE7     ; Output CR/LF
AAA4: C9 A3     CMP #$A3
AAA6: F0 50     BEQ $AAF8     ; Handle comma, TAB(, SPC(
AAA8: C9 A6     CMP #$A6
AAAA: 18        CLC
AAAB: F0 4B     BEQ $AAF8     ; Handle comma, TAB(, SPC(
AAAD: C9 2C     CMP #$2C
AAAF: F0 37     BEQ $AAE8     ; Handle comma, TAB(, SPC(
AAB1: C9 3B     CMP #$3B
AAB3: F0 5E     BEQ $AB13     ; Handle comma, TAB(, SPC(
AAB5: 20 9E AD  JSR $AD9E     ; Evaluate Expression in Text



 $AAB8/43704:   Output Variable

AAB8: 24 0D     BIT $0D       ; Data type Flag
AABA: 30 DE     BMI $AA9A     ; Print String From Memory
AABC: 20 DD BD  JSR $BDDD     ; Convert FAC#1 to ASCII String
AABF: 20 87 B4  JSR $B487     ; Set Up String
AAC2: 20 21 AB  JSR $AB21     ; Output String
AAC5: 20 3B AB  JSR $AB3B     ; Output Format Character
AAC8: D0 D3     BNE $AA9D     ; Print String From Memory



 $AACA/43722:   -Add zero terminator to string

Jump from $A576:

AACA: A9 00     LDA #$00
AACC: 9D 00 02  STA $0200,X   ; BASIC Input Buffer (Input Line from Screen)
AACF: A2 FF     LDX #$FF
AAD1: A0 01     LDY #$01
AAD3: A5 13     LDA $13       ; File number of current Input Device
AAD5: D0 10     BNE $AAE7     ; Output CR/LF



 $AAD7/43735:   Output CR/LF

Jump from $A44E, $A6D4, $AAA0:

AAD7: A9 0D     LDA #$0D
AAD9: 20 47 AB  JSR $AB47     ; Output Format Character
AADC: 24 13     BIT $13       ; File number of current Input Device
AADE: 10 05     BPL $AAE5
AAE0: A9 0A     LDA #$0A
AAE2: 20 47 AB  JSR $AB47     ; Output Format Character

Jump from $AADE, $AB35:

AAE5: 49 FF     EOR #$FF

Jump from $AAA2, $AAD5, $AB29:

AAE7: 60        RTS



 $AAE8/43752:   Handle comma, TAB(, SPC(

Jump from $AAAF:

AAE8: 38        SEC
AAE9: 20 F0 FF  JSR $FFF0     ; Read / Set Cursor X/Y Position
AAEC: 98        TYA
AAED: 38        SEC

Jump from $AAF0:

AAEE: E9 0A     SBC #$0A
AAF0: B0 FC     BCS $AAEE
AAF2: 49 FF     EOR #$FF
AAF4: 69 01     ADC #$01
AAF6: D0 16     BNE $AB0E

Jump from $AAA6, $AAAB:

AAF8: 08        PHP
AAF9: 38        SEC
AAFA: 20 F0 FF  JSR $FFF0     ; Read / Set Cursor X/Y Position
AAFD: 84 09     STY $09       ; Screen Column for last TAB
AAFF: 20 9B B7  JSR $B79B     ; Evaluate Text to 1 Byte in XR
AB02: C9 29     CMP #$29
AB04: D0 59     BNE $AB5F     ; Handle Bad Data
AB06: 28        PLP
AB07: 90 06     BCC $AB0F
AB09: 8A        TXA
AB0A: E5 09     SBC $09       ; Screen Column for last TAB
AB0C: 90 05     BCC $AB13

Jump from $AAF6:

AB0E: AA        TAX

Jump from $AB07:

AB0F: E8        INX

Jump from $AB1C:

AB10: CA        DEX
AB11: D0 06     BNE $AB19

Jump from $AB0C, $AAB3:

AB13: 20 73 00  JSR $0073     ; CHRGET: Get next Byte of BASIC Text
AB16: 4C A2 AA  JMP $AAA2     ; Perform [print]

Jump from $AB11:

AB19: 20 3B AB  JSR $AB3B     ; Output Format Character
AB1C: D0 F2     BNE $AB10



 $AB1E/43806:   Output String

Jump from $A469, $A478, $AB6F, $ACF8, $BDDA, $E191, $E1AF, $E42D, $E441:

AB1E: 20 87 B4  JSR $B487     ; Set Up String

Jump from $AA9A, $AAC2, $ABCB:

AB21: 20 A6 B6  JSR $B6A6     ; Perform String Housekeeping
AB24: AA        TAX
AB25: A0 00     LDY #$00
AB27: E8        INX

Jump from $AB33, $AB38:

AB28: CA        DEX
AB29: F0 BC     BEQ $AAE7     ; Output CR/LF
AB2B: B1 22     LDA ($22),Y   ; Second Utility Pointer
AB2D: 20 47 AB  JSR $AB47     ; Output Format Character
AB30: C8        INY
AB31: C9 0D     CMP #$0D
AB33: D0 F3     BNE $AB28
AB35: 20 E5 AA  JSR $AAE5     ; Output CR/LF
AB38: 4C 28 AB  JMP $AB28



 $AB3B/43835:   Output Format Character

Jump from $AAC5, $AB19, $AC00:

AB3B: A5 13     LDA $13       ; File number of current Input Device
AB3D: F0 03     BEQ $AB42
AB3F: A9 20     LDA #$20
AB41: 2C        .BYTE $2C

Jump from $AB3D:

AB42: A9 1D     LDA #$1D
AB44: 2C        .BYTE $2C

Jump from $A451, $ABFD, $AC47:

AB45: A9 3F     LDA #$3F

Jump from $A45B, $A6F3, $A73D, $AAD9, $AAE2, $AB2D:

AB47: 20 0C E1  JSR $E10C     ; Output Character
AB4A: 29 FF     AND #$FF
AB4C: 60        RTS



 $AB4D/43853:   Handle Bad Data

Jump from $AC9A:

AB4D: A5 11     LDA $11       ; Input Flag
AB4F: F0 11     BEQ $AB62
AB51: 30 04     BMI $AB57
AB53: A0 FF     LDY #$FF
AB55: D0 04     BNE $AB5B

Jump from $AB51:

AB57: A5 3F     LDA $3F       ; Current DATA Line number
AB59: A4 40     LDY $40       ; Current DATA Line number

Jump from $AB55:

AB5B: 85 39     STA $39       ; Current BASIC Line number
AB5D: 84 3A     STY $3A       ; Current BASIC Line number

Jump from $AB04:

AB5F: 4C 08 AF  JMP $AF08     ; Output ?SYNTAX Error

Jump from $AB4F:

AB62: A5 13     LDA $13       ; File number of current Input Device
AB64: F0 05     BEQ $AB6B
AB66: A2 18     LDX #$18
AB68: 4C 37 A4  JMP $A437     ; Error Routine

Jump from $AB64:

AB6B: A9 0C     LDA #$0C
AB6D: A0 AD     LDY #$AD
AB6F: 20 1E AB  JSR $AB1E     ; Output String
AB72: A5 3D     LDA $3D       ; Pointer: BASIC Statement for CONT
AB74: A4 3E     LDY $3E       ; Pointer: BASIC Statement for CONT
AB76: 85 7A     STA $7A       ; Pointer: Current Byte of BASIC Text
AB78: 84 7B     STY $7B       ; Pointer: Current Byte of BASIC Text
AB7A: 60        RTS



 $AB7B/43899:   Perform [get]

AB7B: 20 A6 B3  JSR $B3A6     ; Confirm Program Mode
AB7E: C9 23     CMP #$23
AB80: D0 10     BNE $AB92
AB82: 20 73 00  JSR $0073     ; CHRGET: Get next Byte of BASIC Text
AB85: 20 9E B7  JSR $B79E     ; Evaluate Text to 1 Byte in XR
AB88: A9 2C     LDA #$2C
AB8A: 20 FF AE  JSR $AEFF     ; Test ','
AB8D: 86 13     STX $13       ; File number of current Input Device
AB8F: 20 1E E1  JSR $E11E     ; Set Up For Input

Jump from $AB80:

AB92: A2 01     LDX #$01
AB94: A0 02     LDY #$02
AB96: A9 00     LDA #$00
AB98: 8D 01 02  STA $0201     ; BASIC Input Buffer (Input Line from Screen)
AB9B: A9 40     LDA #$40
AB9D: 20 0F AC  JSR $AC0F     ; Perform [read]
ABA0: A6 13     LDX $13       ; File number of current Input Device
ABA2: D0 13     BNE $ABB7     ; Perform [input#]
ABA4: 60        RTS



 $ABA5/43941:   Perform [input#]

ABA5: 20 9E B7  JSR $B79E     ; Evaluate Text to 1 Byte in XR
ABA8: A9 2C     LDA #$2C
ABAA: 20 FF AE  JSR $AEFF     ; Test ','
ABAD: 86 13     STX $13       ; File number of current Input Device
ABAF: 20 1E E1  JSR $E11E     ; Set Up For Input
ABB2: 20 CE AB  JSR $ABCE     ; Perform [input]

Jump from $AA83, $ABE4:

ABB5: A5 13     LDA $13       ; File number of current Input Device

Jump from $ABA2:

ABB7: 20 CC FF  JSR $FFCC     ; Restore I/O Vector
ABBA: A2 00     LDX #$00
ABBC: 86 13     STX $13       ; File number of current Input Device
ABBE: 60        RTS



 $ABBF/43967:   Perform [input]

ABBF: C9 22     CMP #$22
ABC1: D0 0B     BNE $ABCE
ABC3: 20 BD AE  JSR $AEBD     ; Continue Expression
ABC6: A9 3B     LDA #$3B
ABC8: 20 FF AE  JSR $AEFF     ; Test ','
ABCB: 20 21 AB  JSR $AB21     ; Output String

Jump from $ABC1, $ABB2:

ABCE: 20 A6 B3  JSR $B3A6     ; Confirm Program Mode
ABD1: A9 2C     LDA #$2C
ABD3: 8D FF 01  STA $01FF     ; BASIC Stack Area

Jump from $ABF1:

ABD6: 20 F9 AB  JSR $ABF9     ; Do Input Prompt
ABD9: A5 13     LDA $13       ; File number of current Input Device
ABDB: F0 0D     BEQ $ABEA     ; Read Input Buffer
ABDD: 20 B7 FF  JSR $FFB7     ; Read I/O Status Word
ABE0: 29 02     AND #$02
ABE2: F0 06     BEQ $ABEA     ; Read Input Buffer
ABE4: 20 B5 AB  JSR $ABB5     ; Perform [input#]
ABE7: 4C F8 A8  JMP $A8F8     ; Perform [data]



 $ABEA/44010:   Read Input Buffer

Jump from $ABDB, $ABE2:

ABEA: AD 00 02  LDA $0200     ; BASIC Input Buffer (Input Line from Screen)
ABED: D0 1E     BNE $AC0D     ; Perform [read]
ABEF: A5 13     LDA $13       ; File number of current Input Device
ABF1: D0 E3     BNE $ABD6     ; Perform [input]
ABF3: 20 06 A9  JSR $A906     ; Search for Next Statement / Line
ABF6: 4C FB A8  JMP $A8FB     ; Perform [data]



 $ABF9/44025:   Do Input Prompt

Jump from $ABD6, $AC4A:

ABF9: A5 13     LDA $13       ; File number of current Input Device
ABFB: D0 06     BNE $AC03
ABFD: 20 45 AB  JSR $AB45     ; Output Format Character
AC00: 20 3B AB  JSR $AB3B     ; Output Format Character

Jump from $ABFB:

AC03: 4C 60 A5  JMP $A560     ; Input Line Into Buffer



 $AC06/44038:   Perform [read]

AC06: A6 41     LDX $41       ; Pointer: Used by READ - current DATA Item
AC08: A4 42     LDY $42       ; Pointer: Used by READ - current DATA Item
AC0A: A9 98     LDA #$98
AC0C: 2C        .BYTE $2C

Jump from $ABED:

AC0D: A9 00     LDA #$00

Jump from $AB9D:

AC0F: 85 11     STA $11       ; Input Flag
AC11: 86 43     STX $43       ; Pointer: Temporary storage during INPUT
AC13: 84 44     STY $44       ; Pointer: Temporary storage during INPUT

Jump from $ACB5:

AC15: 20 8B B0  JSR $B08B     ; Identify Variable
AC18: 85 49     STA $49       ; Pointer: Index Variable for FOR/NEXT loop
AC1A: 84 4A     STY $4A       ; Pointer: Index Variable for FOR/NEXT loop
AC1C: A5 7A     LDA $7A       ; Pointer: Current Byte of BASIC Text
AC1E: A4 7B     LDY $7B       ; Pointer: Current Byte of BASIC Text
AC20: 85 4B     STA $4B       ; Temporary storage for TXTPTR
AC22: 84 4C     STY $4C       ; Temporary storage for TXTPTR
AC24: A6 43     LDX $43       ; Pointer: Temporary storage during INPUT
AC26: A4 44     LDY $44       ; Pointer: Temporary storage during INPUT
AC28: 86 7A     STX $7A       ; Pointer: Current Byte of BASIC Text
AC2A: 84 7B     STY $7B       ; Pointer: Current Byte of BASIC Text
AC2C: 20 79 00  JSR $0079     ; CHRGOT: Get same Byte again
AC2F: D0 20     BNE $AC51     ; General Purpose Read Routine
AC31: 24 11     BIT $11       ; Input Flag
AC33: 50 0C     BVC $AC41     ; General Purpose Read Routine



 $AC35/44085:   General Purpose Read Routine

AC35: 20 24 E1  JSR $E124     ; Get One Character
AC38: 8D 00 02  STA $0200     ; BASIC Input Buffer (Input Line from Screen)
AC3B: A2 FF     LDX #$FF
AC3D: A0 01     LDY #$01
AC3F: D0 0C     BNE $AC4D

Jump from $AC33:

AC41: 30 75     BMI $ACB8
AC43: A5 13     LDA $13       ; File number of current Input Device
AC45: D0 03     BNE $AC4A
AC47: 20 45 AB  JSR $AB45     ; Output Format Character

Jump from $AC45:

AC4A: 20 F9 AB  JSR $ABF9     ; Do Input Prompt

Jump from $AC3F:

AC4D: 86 7A     STX $7A       ; Pointer: Current Byte of BASIC Text
AC4F: 84 7B     STY $7B       ; Pointer: Current Byte of BASIC Text

Jump from $ACDC, $AC2F:

AC51: 20 73 00  JSR $0073     ; CHRGET: Get next Byte of BASIC Text
AC54: 24 0D     BIT $0D       ; Data type Flag
AC56: 10 31     BPL $AC89
AC58: 24 11     BIT $11       ; Input Flag
AC5A: 50 09     BVC $AC65
AC5C: E8        INX
AC5D: 86 7A     STX $7A       ; Pointer: Current Byte of BASIC Text
AC5F: A9 00     LDA #$00
AC61: 85 07     STA $07       ; Temporary Integer during OR/AND
AC63: F0 0C     BEQ $AC71

Jump from $AC5A:

AC65: 85 07     STA $07       ; Temporary Integer during OR/AND
AC67: C9 22     CMP #$22
AC69: F0 07     BEQ $AC72
AC6B: A9 3A     LDA #$3A
AC6D: 85 07     STA $07       ; Temporary Integer during OR/AND
AC6F: A9 2C     LDA #$2C

Jump from $AC63:

AC71: 18        CLC

Jump from $AC69:

AC72: 85 08     STA $08       ; Flag: Scan for Quote at end of String
AC74: A5 7A     LDA $7A       ; Pointer: Current Byte of BASIC Text
AC76: A4 7B     LDY $7B       ; Pointer: Current Byte of BASIC Text
AC78: 69 00     ADC #$00
AC7A: 90 01     BCC $AC7D
AC7C: C8        INY

Jump from $AC7A:

AC7D: 20 8D B4  JSR $B48D     ; Set Up String
AC80: 20 E2 B7  JSR $B7E2     ; Convert ASCII String to Flpt
AC83: 20 DA A9  JSR $A9DA     ; Assign String
AC86: 4C 91 AC  JMP $AC91

Jump from $AC56:

AC89: 20 F3 BC  JSR $BCF3     ; Convert ASCII String to a Number in FAC
AC8C: A5 0E     LDA $0E       ; Data type Flag
AC8E: 20 C2 A9  JSR $A9C2     ; Perform [let]

Jump from $AC86:

AC91: 20 79 00  JSR $0079     ; CHRGOT: Get same Byte again
AC94: F0 07     BEQ $AC9D
AC96: C9 2C     CMP #$2C
AC98: F0 03     BEQ $AC9D
AC9A: 4C 4D AB  JMP $AB4D     ; Handle Bad Data

Jump from $AC94, $AC98:

AC9D: A5 7A     LDA $7A       ; Pointer: Current Byte of BASIC Text
AC9F: A4 7B     LDY $7B       ; Pointer: Current Byte of BASIC Text
ACA1: 85 43     STA $43       ; Pointer: Temporary storage during INPUT
ACA3: 84 44     STY $44       ; Pointer: Temporary storage during INPUT
ACA5: A5 4B     LDA $4B       ; Temporary storage for TXTPTR
ACA7: A4 4C     LDY $4C       ; Temporary storage for TXTPTR
ACA9: 85 7A     STA $7A       ; Pointer: Current Byte of BASIC Text
ACAB: 84 7B     STY $7B       ; Pointer: Current Byte of BASIC Text
ACAD: 20 79 00  JSR $0079     ; CHRGOT: Get same Byte again
ACB0: F0 2D     BEQ $ACDF
ACB2: 20 FD AE  JSR $AEFD     ; Test ','
ACB5: 4C 15 AC  JMP $AC15     ; Perform [read]

Jump from $AC41, $ACDA:

ACB8: 20 06 A9  JSR $A906     ; Search for Next Statement / Line
ACBB: C8        INY
ACBC: AA        TAX
ACBD: D0 12     BNE $ACD1
ACBF: A2 0D     LDX #$0D
ACC1: C8        INY
ACC2: B1 7A     LDA ($7A),Y   ; Pointer: Current Byte of BASIC Text
ACC4: F0 6C     BEQ $AD32     ; Perform [next]
ACC6: C8        INY
ACC7: B1 7A     LDA ($7A),Y   ; Pointer: Current Byte of BASIC Text
ACC9: 85 3F     STA $3F       ; Current DATA Line number
ACCB: C8        INY
ACCC: B1 7A     LDA ($7A),Y   ; Pointer: Current Byte of BASIC Text
ACCE: C8        INY
ACCF: 85 40     STA $40       ; Current DATA Line number

Jump from $ACBD:

ACD1: 20 FB A8  JSR $A8FB     ; Perform [data]
ACD4: 20 79 00  JSR $0079     ; CHRGOT: Get same Byte again
ACD7: AA        TAX
ACD8: E0 83     CPX #$83
ACDA: D0 DC     BNE $ACB8
ACDC: 4C 51 AC  JMP $AC51

Jump from $ACB0:

ACDF: A5 43     LDA $43       ; Pointer: Temporary storage during INPUT
ACE1: A4 44     LDY $44       ; Pointer: Temporary storage during INPUT
ACE3: A6 11     LDX $11       ; Input Flag
ACE5: 10 03     BPL $ACEA
ACE7: 4C 27 A8  JMP $A827     ; Perform [restore]

Jump from $ACE5:

ACEA: A0 00     LDY #$00
ACEC: B1 43     LDA ($43),Y   ; Pointer: Temporary storage during INPUT
ACEE: F0 0B     BEQ $ACFB
ACF0: A5 13     LDA $13       ; File number of current Input Device
ACF2: D0 07     BNE $ACFB
ACF4: A9 FC     LDA #$FC
ACF6: A0 AC     LDY #$AC
ACF8: 4C 1E AB  JMP $AB1E     ; Output String

Jump from $ACEE, $ACF2:

ACFB: 60        RTS



 $ACFC/44284:   Input Error Messages

ACFC: 3F 45 58 54 52 41 20 49
AD04: 47 4E 4F 52 45 44 0D 00
AD0C: 3F 52 45 44 4F 20 46 52
AD14: 4F 4D 20 53 54 41 52 54
AD1C: 0D 00



 $AD1E/44318:   Perform [next]

AD1E: D0 04     BNE $AD24
AD20: A0 00     LDY #$00
AD22: F0 03     BEQ $AD27

Jump from $AD1E, $AD87:

AD24: 20 8B B0  JSR $B08B     ; Identify Variable

Jump from $AD22:

AD27: 85 49     STA $49       ; Pointer: Index Variable for FOR/NEXT loop
AD29: 84 4A     STY $4A       ; Pointer: Index Variable for FOR/NEXT loop
AD2B: 20 8A A3  JSR $A38A     ; Find FOR/GOSUB Entry on Stack
AD2E: F0 05     BEQ $AD35
AD30: A2 0A     LDX #$0A

Jump from $ACC4:

AD32: 4C 37 A4  JMP $A437     ; Error Routine

Jump from $AD2E:

AD35: 9A        TXS
AD36: 8A        TXA
AD37: 18        CLC
AD38: 69 04     ADC #$04
AD3A: 48        PHA
AD3B: 69 06     ADC #$06
AD3D: 85 24     STA $24       ; Second Utility Pointer
AD3F: 68        PLA
AD40: A0 01     LDY #$01
AD42: 20 A2 BB  JSR $BBA2     ; Load FAC#1 From Memory
AD45: BA        TSX
AD46: BD 09 01  LDA $0109,X   ; 6510 Hardware Stack Area
AD49: 85 66     STA $66       ; FAC Sign
AD4B: A5 49     LDA $49       ; Pointer: Index Variable for FOR/NEXT loop
AD4D: A4 4A     LDY $4A       ; Pointer: Index Variable for FOR/NEXT loop
AD4F: 20 67 B8  JSR $B867     ; Perform Addition
AD52: 20 D0 BB  JSR $BBD0     ; Store FAC#1 in Memory
AD55: A0 01     LDY #$01
AD57: 20 5D BC  JSR $BC5D     ; Compare FAC#1 With Memory
AD5A: BA        TSX
AD5B: 38        SEC
AD5C: FD 09 01  SBC $0109,X   ; 6510 Hardware Stack Area
AD5F: F0 17     BEQ $AD78     ; Check Valid Loop



 $AD61/44385:   Check Valid Loop

AD61: BD 0F 01  LDA $010F,X   ; 6510 Hardware Stack Area
AD64: 85 39     STA $39       ; Current BASIC Line number
AD66: BD 10 01  LDA $0110,X   ; 6510 Hardware Stack Area
AD69: 85 3A     STA $3A       ; Current BASIC Line number
AD6B: BD 12 01  LDA $0112,X   ; 6510 Hardware Stack Area
AD6E: 85 7A     STA $7A       ; Pointer: Current Byte of BASIC Text
AD70: BD 11 01  LDA $0111,X   ; 6510 Hardware Stack Area
AD73: 85 7B     STA $7B       ; Pointer: Current Byte of BASIC Text

Jump from $AD82:

AD75: 4C AE A7  JMP $A7AE     ; BASIC Warm Start

Jump from $AD5F:

AD78: 8A        TXA
AD79: 69 11     ADC #$11
AD7B: AA        TAX
AD7C: 9A        TXS
AD7D: 20 79 00  JSR $0079     ; CHRGOT: Get same Byte again
AD80: C9 2C     CMP #$2C
AD82: D0 F1     BNE $AD75
AD84: 20 73 00  JSR $0073     ; CHRGET: Get next Byte of BASIC Text
AD87: 20 24 AD  JSR $AD24     ; Perform [next]



 $AD8A/44426:   Confirm Result

Jump from $A775, $A79C, $B438, $B79E, $B7EB, $E12A:

AD8A: 20 9E AD  JSR $AD9E     ; Evaluate Expression in Text

Jump from $A772, $ADF6, $AE61, $AFE3, $B1B8, $B3C3, $B3F1, $B400, $B465:

AD8D: 18        CLC
AD8E: 24        .BYTE $24

Jump from $AFBA, $B646, $B6A3:

AD8F: 38        SEC

Jump from $A9BC, $B016:

AD90: 24 0D     BIT $0D       ; Data type Flag
AD92: 30 03     BMI $AD97
AD94: B0 03     BCS $AD99

Jump from $AD97:

AD96: 60        RTS

Jump from $AD92:

AD97: B0 FD     BCS $AD96

Jump from $AD94:

AD99: A2 16     LDX #$16
AD9B: 4C 37 A4  JMP $A437     ; Error Routine



 $AD9E/44446:   Evaluate Expression in Text

Jump from $A928, $A9B7, $AAB5, $AD8A, $AEF4, $AFB4, $B1B5, $E257:

AD9E: A6 7A     LDX $7A       ; Pointer: Current Byte of BASIC Text
ADA0: D0 02     BNE $ADA4
ADA2: C6 7B     DEC $7B       ; Pointer: Current Byte of BASIC Text

Jump from $ADA0:

ADA4: C6 7A     DEC $7A       ; Pointer: Current Byte of BASIC Text
ADA6: A2 00     LDX #$00
ADA8: 24        .BYTE $24

Jump from $AE2D:

ADA9: 48        PHA
ADAA: 8A        TXA
ADAB: 48        PHA
ADAC: A9 01     LDA #$01
ADAE: 20 FB A3  JSR $A3FB     ; Check Stack Depth
ADB1: 20 83 AE  JSR $AE83     ; Evaluate Single Term
ADB4: A9 00     LDA #$00
ADB6: 85 4D     STA $4D       ; Mask used during FRMEVL

Jump from $B677:

ADB8: 20 79 00  JSR $0079     ; CHRGOT: Get same Byte again

Jump from $ADD4:

ADBB: 38        SEC
ADBC: E9 B1     SBC #$B1
ADBE: 90 17     BCC $ADD7
ADC0: C9 03     CMP #$03
ADC2: B0 13     BCS $ADD7
ADC4: C9 01     CMP #$01
ADC6: 2A        ROL
ADC7: 49 01     EOR #$01
ADC9: 45 4D     EOR $4D       ; Mask used during FRMEVL
ADCB: C5 4D     CMP $4D       ; Mask used during FRMEVL
ADCD: 90 61     BCC $AE30
ADCF: 85 4D     STA $4D       ; Mask used during FRMEVL
ADD1: 20 73 00  JSR $0073     ; CHRGET: Get next Byte of BASIC Text
ADD4: 4C BB AD  JMP $ADBB

Jump from $ADBE, $ADC2:

ADD7: A6 4D     LDX $4D       ; Mask used during FRMEVL
ADD9: D0 2C     BNE $AE07
ADDB: B0 7B     BCS $AE58
ADDD: 69 07     ADC #$07
ADDF: 90 77     BCC $AE58
ADE1: 65 0D     ADC $0D       ; Data type Flag
ADE3: D0 03     BNE $ADE8
ADE5: 4C 3D B6  JMP $B63D     ; Concatenate Two Strings

Jump from $ADE3:

ADE8: 69 FF     ADC #$FF
ADEA: 85 22     STA $22       ; Second Utility Pointer
ADEC: 0A        ASL
ADED: 65 22     ADC $22       ; Second Utility Pointer
ADEF: A8        TAY

Jump from $AE17:

ADF0: 68        PLA
ADF1: D9 80 A0  CMP $A080,Y   ; BASIC Operator Vectors
ADF4: B0 67     BCS $AE5D
ADF6: 20 8D AD  JSR $AD8D     ; Confirm Result

Jump from $AE1E:

ADF9: 48        PHA

Jump from $AF11:

ADFA: 20 20 AE  JSR $AE20
ADFD: 68        PLA
ADFE: A4 4B     LDY $4B       ; Temporary storage for TXTPTR
AE00: 10 17     BPL $AE19
AE02: AA        TAX
AE03: F0 56     BEQ $AE5B
AE05: D0 5F     BNE $AE66

Jump from $ADD9:

AE07: 46 0D     LSR $0D       ; Data type Flag
AE09: 8A        TXA
AE0A: 2A        ROL
AE0B: A6 7A     LDX $7A       ; Pointer: Current Byte of BASIC Text
AE0D: D0 02     BNE $AE11
AE0F: C6 7B     DEC $7B       ; Pointer: Current Byte of BASIC Text

Jump from $AE0D:

AE11: C6 7A     DEC $7A       ; Pointer: Current Byte of BASIC Text
AE13: A0 1B     LDY #$1B
AE15: 85 4D     STA $4D       ; Mask used during FRMEVL
AE17: D0 D7     BNE $ADF0

Jump from $AE00:

AE19: D9 80 A0  CMP $A080,Y   ; BASIC Operator Vectors
AE1C: B0 48     BCS $AE66
AE1E: 90 D9     BCC $ADF9

Jump from $ADFA:

AE20: B9 82 A0  LDA $A082,Y   ; BASIC Operator Vectors
AE23: 48        PHA
AE24: B9 81 A0  LDA $A081,Y   ; BASIC Operator Vectors
AE27: 48        PHA
AE28: 20 33 AE  JSR $AE33
AE2B: A5 4D     LDA $4D       ; Mask used during FRMEVL
AE2D: 4C A9 AD  JMP $ADA9

Jump from $ADCD:

AE30: 4C 08 AF  JMP $AF08     ; Output ?SYNTAX Error

Jump from $AE28:

AE33: A5 66     LDA $66       ; FAC Sign
AE35: BE 80 A0  LDX $A080,Y   ; BASIC Operator Vectors

Jump from $A7A2:

AE38: A8        TAY
AE39: 68        PLA
AE3A: 85 22     STA $22       ; Second Utility Pointer
AE3C: E6 22     INC $22       ; Second Utility Pointer
AE3E: 68        PLA
AE3F: 85 23     STA $23       ; Second Utility Pointer
AE41: 98        TYA
AE42: 48        PHA

Jump from $A788:

AE43: 20 1B BC  JSR $BC1B     ; Round FAC#1
AE46: A5 65     LDA $65       ; FAC Mantissa
AE48: 48        PHA
AE49: A5 64     LDA $64       ; FAC Mantissa
AE4B: 48        PHA
AE4C: A5 63     LDA $63       ; FAC Mantissa
AE4E: 48        PHA
AE4F: A5 62     LDA $62       ; FAC Mantissa
AE51: 48        PHA
AE52: A5 61     LDA $61       ; FAC Exponent
AE54: 48        PHA
AE55: 6C 22 00  JMP ($0022)   ; Second Utility Pointer

Jump from $ADDB, $ADDF:

AE58: A0 FF     LDY #$FF
AE5A: 68        PLA

Jump from $AE03:

AE5B: F0 23     BEQ $AE80

Jump from $ADF4:

AE5D: C9 64     CMP #$64
AE5F: F0 03     BEQ $AE64
AE61: 20 8D AD  JSR $AD8D     ; Confirm Result

Jump from $AE5F:

AE64: 84 4B     STY $4B       ; Temporary storage for TXTPTR

Jump from $AE05, $AE1C:

AE66: 68        PLA
AE67: 4A        LSR
AE68: 85 12     STA $12       ; Flag: TAN sign/Comparative result
AE6A: 68        PLA
AE6B: 85 69     STA $69       ; AFAC Exponent
AE6D: 68        PLA
AE6E: 85 6A     STA $6A       ; AFAC Mantissa
AE70: 68        PLA
AE71: 85 6B     STA $6B       ; AFAC Mantissa
AE73: 68        PLA
AE74: 85 6C     STA $6C       ; AFAC Mantissa
AE76: 68        PLA
AE77: 85 6D     STA $6D       ; AFAC Mantissa
AE79: 68        PLA
AE7A: 85 6E     STA $6E       ; AFAC Sign
AE7C: 45 66     EOR $66       ; FAC Sign
AE7E: 85 6F     STA $6F       ; Sign of result of Arithmetic Evaluation

Jump from $AE5B:

AE80: A5 61     LDA $61       ; FAC Exponent
AE82: 60        RTS



 $AE83/44675:   Evaluate Single Term

Jump from $ADB1, $B643:

AE83: 6C 0A 03  JMP ($030A)   ; Vector: BASIC Token evaluation
AE86: A9 00     LDA #$00
AE88: 85 0D     STA $0D       ; Data type Flag

Jump from $AEB7:

AE8A: 20 73 00  JSR $0073     ; CHRGET: Get next Byte of BASIC Text
AE8D: B0 03     BCS $AE92

Jump from $AEAF:

AE8F: 4C F3 BC  JMP $BCF3     ; Convert ASCII String to a Number in FAC

Jump from $AE8D:

AE92: 20 13 B1  JSR $B113     ; Does A hold an alphabetic character?
AE95: 90 03     BCC $AE9A
AE97: 4C 28 AF  JMP $AF28     ; Search for Variable

Jump from $AE95:

AE9A: C9 FF     CMP #$FF
AE9C: D0 0F     BNE $AEAD     ; Continue Expression
AE9E: A9 A8     LDA #$A8
AEA0: A0 AE     LDY #$AE
AEA2: 20 A2 BB  JSR $BBA2     ; Load FAC#1 From Memory
AEA5: 4C 73 00  JMP $0073     ; CHRGET: Get next Byte of BASIC Text


Kernal-Reference:

 BIT $AE91   : $F51B


 $AEA8/44712:   Constant - pi

AEA8: 82 49 0F DA A1



 $AEAD/44717:   Continue Expression

Jump from $AE9C:

AEAD: C9 2E     CMP #$2E
AEAF: F0 DE     BEQ $AE8F     ; Evaluate Single Term
AEB1: C9 AB     CMP #$AB
AEB3: F0 58     BEQ $AF0D     ; Set up NOT Function
AEB5: C9 AA     CMP #$AA
AEB7: F0 D1     BEQ $AE8A     ; Evaluate Single Term
AEB9: C9 22     CMP #$22
AEBB: D0 0F     BNE $AECC

Jump from $ABC3:

AEBD: A5 7A     LDA $7A       ; Pointer: Current Byte of BASIC Text
AEBF: A4 7B     LDY $7B       ; Pointer: Current Byte of BASIC Text
AEC1: 69 00     ADC #$00
AEC3: 90 01     BCC $AEC6
AEC5: C8        INY

Jump from $AEC3:

AEC6: 20 87 B4  JSR $B487     ; Set Up String
AEC9: 4C E2 B7  JMP $B7E2     ; Convert ASCII String to Flpt

Jump from $AEBB:

AECC: C9 A8     CMP #$A8
AECE: D0 13     BNE $AEE3
AED0: A0 18     LDY #$18
AED2: D0 3B     BNE $AF0F     ; Set up NOT Function
AED4: 20 BF B1  JSR $B1BF     ; FAC#1 to Positive Integer
AED7: A5 65     LDA $65       ; FAC Mantissa
AED9: 49 FF     EOR #$FF
AEDB: A8        TAY
AEDC: A5 64     LDA $64       ; FAC Mantissa
AEDE: 49 FF     EOR #$FF
AEE0: 4C 91 B3  JMP $B391     ; Convert Integer in (AC/YR) to Flpt

Jump from $AECE:

AEE3: C9 A5     CMP #$A5
AEE5: D0 03     BNE $AEEA
AEE7: 4C F4 B3  JMP $B3F4     ; Perform [fn]

Jump from $AEE5:

AEEA: C9 B4     CMP #$B4
AEEC: 90 03     BCC $AEF1     ; Expression in Brackets
AEEE: 4C A7 AF  JMP $AFA7     ; Identify Function Type



 $AEF1/44785:   Expression in Brackets

Jump from $AEEC, $AFD1, $B3FD:

AEF1: 20 FA AE  JSR $AEFA     ; Test '('
AEF4: 20 9E AD  JSR $AD9E     ; Evaluate Expression in Text



 $AEF7/44791:   Test ')'

Jump from $B20B, $B3C6, $B761:

AEF7: A9 29     LDA #$29
AEF9: 2C        .BYTE $2C



 $AEFA/44794:   Test '('

Jump from $AEF1, $AFB1, $B3B9:

AEFA: A9 28     LDA #$28
AEFC: 2C        .BYTE $2C



 $AEFD/44797:   Test ','

Jump from $ACB2, $AFB7, $B07E, $B742, $B7F1, $E20E:

AEFD: A9 2C     LDA #$2C

Jump from $A76F, $A817, $A934, $A9AE, $AA8D, $AB8A, $ABAA, $ABC8, $B3CB, $B3E3:

AEFF: A0 00     LDY #$00
AF01: D1 7A     CMP ($7A),Y   ; Pointer: Current Byte of BASIC Text
AF03: D0 03     BNE $AF08     ; Output ?SYNTAX Error
AF05: 4C 73 00  JMP $0073     ; CHRGET: Get next Byte of BASIC Text



 $AF08/44808:   Output ?SYNTAX Error

Jump from $A80B, $A8E8, $AB5F, $AE30, $AF03, $B09C, $B138, $B446, $E216:

AF08: A2 0B     LDX #$0B
AF0A: 4C 37 A4  JMP $A437     ; Error Routine



 $AF0D/44813:   Set up NOT Function

Jump from $AEB3:

AF0D: A0 15     LDY #$15

Jump from $AED2:

AF0F: 68        PLA
AF10: 68        PLA
AF11: 4C FA AD  JMP $ADFA     ; Evaluate Expression in Text



 $AF14/44820:   Identify Reserved Variable

Jump from $AF3B, $AF6E:

AF14: 38        SEC
AF15: A5 64     LDA $64       ; FAC Mantissa
AF17: E9 00     SBC #$00
AF19: A5 65     LDA $65       ; FAC Mantissa
AF1B: E9 A0     SBC #$A0
AF1D: 90 08     BCC $AF27
AF1F: A9 A2     LDA #$A2
AF21: E5 64     SBC $64       ; FAC Mantissa
AF23: A9 E3     LDA #$E3
AF25: E5 65     SBC $65       ; FAC Mantissa

Jump from $AF1D:

AF27: 60        RTS



 $AF28/44840:   Search for Variable

Jump from $AE97:

AF28: 20 8B B0  JSR $B08B     ; Identify Variable
AF2B: 85 64     STA $64       ; FAC Mantissa
AF2D: 84 65     STY $65       ; FAC Mantissa
AF2F: A6 45     LDX $45       ; Name of Variable being sought in Variable Table
AF31: A4 46     LDY $46       ; Name of Variable being sought in Variable Table
AF33: A5 0D     LDA $0D       ; Data type Flag
AF35: F0 26     BEQ $AF5D     ; Convert TI to ASCII String
AF37: A9 00     LDA #$00
AF39: 85 70     STA $70       ; FAC low-order rounding
AF3B: 20 14 AF  JSR $AF14     ; Identify Reserved Variable
AF3E: 90 1C     BCC $AF5C     ; Convert TI to ASCII String
AF40: E0 54     CPX #$54
AF42: D0 18     BNE $AF5C     ; Convert TI to ASCII String
AF44: C0 C9     CPY #$C9
AF46: D0 14     BNE $AF5C     ; Convert TI to ASCII String



 $AF48/44872:   Convert TI to ASCII String

AF48: 20 84 AF  JSR $AF84
AF4B: 84 5E     STY $5E       ; Temporary storage for FLPT value
AF4D: 88        DEY
AF4E: 84 71     STY $71       ; Pointer: Used during CRUNCH/ASCII conversion
AF50: A0 06     LDY #$06
AF52: 84 5D     STY $5D       ; Temporary storage for FLPT value
AF54: A0 24     LDY #$24
AF56: 20 68 BE  JSR $BE68     ; Convert TI to String
AF59: 4C 6F B4  JMP $B46F     ; Evaluate <str$>

Jump from $AF3E, $AF42, $AF46:

AF5C: 60        RTS

Jump from $AF35:

AF5D: 24 0E     BIT $0E       ; Data type Flag
AF5F: 10 0D     BPL $AF6E
AF61: A0 00     LDY #$00
AF63: B1 64     LDA ($64),Y   ; FAC Mantissa
AF65: AA        TAX
AF66: C8        INY
AF67: B1 64     LDA ($64),Y   ; FAC Mantissa
AF69: A8        TAY
AF6A: 8A        TXA
AF6B: 4C 91 B3  JMP $B391     ; Convert Integer in (AC/YR) to Flpt

Jump from $AF5F:

AF6E: 20 14 AF  JSR $AF14     ; Identify Reserved Variable
AF71: 90 2D     BCC $AFA0
AF73: E0 54     CPX #$54
AF75: D0 1B     BNE $AF92
AF77: C0 49     CPY #$49
AF79: D0 25     BNE $AFA0
AF7B: 20 84 AF  JSR $AF84
AF7E: 98        TYA
AF7F: A2 A0     LDX #$A0
AF81: 4C 4F BC  JMP $BC4F     ; Evaluate <sgn>

Jump from $AF48, $AF7B:

AF84: 20 DE FF  JSR $FFDE     ; Read Real-Time Clock
AF87: 86 64     STX $64       ; FAC Mantissa
AF89: 84 63     STY $63       ; FAC Mantissa
AF8B: 85 65     STA $65       ; FAC Mantissa
AF8D: A0 00     LDY #$00
AF8F: 84 62     STY $62       ; FAC Mantissa
AF91: 60        RTS

Jump from $AF75:

AF92: E0 53     CPX #$53
AF94: D0 0A     BNE $AFA0
AF96: C0 54     CPY #$54
AF98: D0 06     BNE $AFA0
AF9A: 20 B7 FF  JSR $FFB7     ; Read I/O Status Word
AF9D: 4C 3C BC  JMP $BC3C     ; Evaluate <sgn>

Jump from $AF71, $AF79, $AF94, $AF98:

AFA0: A5 64     LDA $64       ; FAC Mantissa
AFA2: A4 65     LDY $65       ; FAC Mantissa
AFA4: 4C A2 BB  JMP $BBA2     ; Load FAC#1 From Memory



 $AFA7/44967:   Identify Function Type

Jump from $AEEE:

AFA7: 0A        ASL
AFA8: 48        PHA
AFA9: AA        TAX
AFAA: 20 73 00  JSR $0073     ; CHRGET: Get next Byte of BASIC Text
AFAD: E0 8F     CPX #$8F
AFAF: 90 20     BCC $AFD1     ; Evaluate Numeric Function



 $AFB1/44977:   Evaluate String Function

AFB1: 20 FA AE  JSR $AEFA     ; Test '('
AFB4: 20 9E AD  JSR $AD9E     ; Evaluate Expression in Text
AFB7: 20 FD AE  JSR $AEFD     ; Test ','
AFBA: 20 8F AD  JSR $AD8F     ; Confirm Result
AFBD: 68        PLA
AFBE: AA        TAX
AFBF: A5 65     LDA $65       ; FAC Mantissa
AFC1: 48        PHA
AFC2: A5 64     LDA $64       ; FAC Mantissa
AFC4: 48        PHA
AFC5: 8A        TXA
AFC6: 48        PHA
AFC7: 20 9E B7  JSR $B79E     ; Evaluate Text to 1 Byte in XR
AFCA: 68        PLA
AFCB: A8        TAY
AFCC: 8A        TXA
AFCD: 48        PHA
AFCE: 4C D6 AF  JMP $AFD6     ; Evaluate Numeric Function



 $AFD1/45009:   Evaluate Numeric Function

Jump from $AFAF:

AFD1: 20 F1 AE  JSR $AEF1     ; Expression in Brackets
AFD4: 68        PLA
AFD5: A8        TAY

Jump from $AFCE:

AFD6: B9 EA 9F  LDA $9FEA,Y
AFD9: 85 55     STA $55       ; Jump Vector used in Function Evaluation
AFDB: B9 EB 9F  LDA $9FEB,Y
AFDE: 85 56     STA $56       ; Jump Vector used in Function Evaluation
AFE0: 20 54 00  JSR $0054     ; Jump Vector used in Function Evaluation
AFE3: 4C 8D AD  JMP $AD8D     ; Confirm Result



 $AFE6/45030:   Perform [or], [and]

AFE6: A0 FF     LDY #$FF
AFE8: 2C        .BYTE $2C
AFE9: A0 00     LDY #$00
AFEB: 84 0B     STY $0B       ; Input Buffer Pointer/Number of Subscripts
AFED: 20 BF B1  JSR $B1BF     ; FAC#1 to Positive Integer
AFF0: A5 64     LDA $64       ; FAC Mantissa
AFF2: 45 0B     EOR $0B       ; Input Buffer Pointer/Number of Subscripts
AFF4: 85 07     STA $07       ; Temporary Integer during OR/AND
AFF6: A5 65     LDA $65       ; FAC Mantissa
AFF8: 45 0B     EOR $0B       ; Input Buffer Pointer/Number of Subscripts
AFFA: 85 08     STA $08       ; Flag: Scan for Quote at end of String
AFFC: 20 FC BB  JSR $BBFC     ; Copy FAC#2 into FAC#1
AFFF: 20 BF B1  JSR $B1BF     ; FAC#1 to Positive Integer
B002: A5 65     LDA $65       ; FAC Mantissa
B004: 45 0B     EOR $0B       ; Input Buffer Pointer/Number of Subscripts
B006: 25 08     AND $08       ; Flag: Scan for Quote at end of String
B008: 45 0B     EOR $0B       ; Input Buffer Pointer/Number of Subscripts
B00A: A8        TAY
B00B: A5 64     LDA $64       ; FAC Mantissa
B00D: 45 0B     EOR $0B       ; Input Buffer Pointer/Number of Subscripts
B00F: 25 07     AND $07       ; Temporary Integer during OR/AND
B011: 45 0B     EOR $0B       ; Input Buffer Pointer/Number of Subscripts
B013: 4C 91 B3  JMP $B391     ; Convert Integer in (AC/YR) to Flpt



 $B016/45078:   Perform <, =, >

B016: 20 90 AD  JSR $AD90     ; Confirm Result
B019: B0 13     BCS $B02E     ; String Comparison



 $B01B/45083:   Numeric Comparison

B01B: A5 6E     LDA $6E       ; AFAC Sign
B01D: 09 7F     ORA #$7F
B01F: 25 6A     AND $6A       ; AFAC Mantissa
B021: 85 6A     STA $6A       ; AFAC Mantissa
B023: A9 69     LDA #$69
B025: A0 00     LDY #$00
B027: 20 5B BC  JSR $BC5B     ; Compare FAC#1 With Memory
B02A: AA        TAX
B02B: 4C 61 B0  JMP $B061     ; String Comparison



 $B02E/45102:   String Comparison

Jump from $B019:

B02E: A9 00     LDA #$00
B030: 85 0D     STA $0D       ; Data type Flag
B032: C6 4D     DEC $4D       ; Mask used during FRMEVL
B034: 20 A6 B6  JSR $B6A6     ; Perform String Housekeeping
B037: 85 61     STA $61       ; FAC Exponent
B039: 86 62     STX $62       ; FAC Mantissa
B03B: 84 63     STY $63       ; FAC Mantissa
B03D: A5 6C     LDA $6C       ; AFAC Mantissa
B03F: A4 6D     LDY $6D       ; AFAC Mantissa
B041: 20 AA B6  JSR $B6AA     ; Perform String Housekeeping
B044: 86 6C     STX $6C       ; AFAC Mantissa
B046: 84 6D     STY $6D       ; AFAC Mantissa
B048: AA        TAX
B049: 38        SEC
B04A: E5 61     SBC $61       ; FAC Exponent
B04C: F0 08     BEQ $B056
B04E: A9 01     LDA #$01
B050: 90 04     BCC $B056
B052: A6 61     LDX $61       ; FAC Exponent
B054: A9 FF     LDA #$FF

Jump from $B04C, $B050:

B056: 85 66     STA $66       ; FAC Sign
B058: A0 FF     LDY #$FF
B05A: E8        INX

Jump from $B06A:

B05B: C8        INY
B05C: CA        DEX
B05D: D0 07     BNE $B066
B05F: A6 66     LDX $66       ; FAC Sign

Jump from $B02B:

B061: 30 0F     BMI $B072
B063: 18        CLC
B064: 90 0C     BCC $B072

Jump from $B05D:

B066: B1 6C     LDA ($6C),Y   ; AFAC Mantissa
B068: D1 62     CMP ($62),Y   ; FAC Mantissa
B06A: F0 EF     BEQ $B05B
B06C: A2 FF     LDX #$FF
B06E: B0 02     BCS $B072
B070: A2 01     LDX #$01

Jump from $B061, $B064, $B06E:

B072: E8        INX
B073: 8A        TXA
B074: 2A        ROL
B075: 25 12     AND $12       ; Flag: TAN sign/Comparative result
B077: F0 02     BEQ $B07B
B079: A9 FF     LDA #$FF

Jump from $B077:

B07B: 4C 3C BC  JMP $BC3C     ; Evaluate <sgn>



 $B07E/45182:   Perform [dim]

Jump from $B088:

B07E: 20 FD AE  JSR $AEFD     ; Test ','
B081: AA        TAX
B082: 20 90 B0  JSR $B090     ; Identify Variable
B085: 20 79 00  JSR $0079     ; CHRGOT: Get same Byte again
B088: D0 F4     BNE $B07E
B08A: 60        RTS



 $B08B/45195:   Identify Variable

Jump from $A9A5, $AC15, $AD24, $AF28, $B3C0:

B08B: A2 00     LDX #$00
B08D: 20 79 00  JSR $0079     ; CHRGOT: Get same Byte again

Jump from $B082:

B090: 86 0C     STX $0C       ; Flag: Default Array dimension

Jump from $B3EA:

B092: 85 45     STA $45       ; Name of Variable being sought in Variable Table
B094: 20 79 00  JSR $0079     ; CHRGOT: Get same Byte again
B097: 20 13 B1  JSR $B113     ; Does A hold an alphabetic character?
B09A: B0 03     BCS $B09F

Jump from $B0CA:

B09C: 4C 08 AF  JMP $AF08     ; Output ?SYNTAX Error

Jump from $B09A:

B09F: A2 00     LDX #$00
B0A1: 86 0D     STX $0D       ; Data type Flag
B0A3: 86 0E     STX $0E       ; Data type Flag
B0A5: 20 73 00  JSR $0073     ; CHRGET: Get next Byte of BASIC Text
B0A8: 90 05     BCC $B0AF
B0AA: 20 13 B1  JSR $B113     ; Does A hold an alphabetic character?
B0AD: 90 0B     BCC $B0BA

Jump from $B0A8:

B0AF: AA        TAX

Jump from $B0B3, $B0B8:

B0B0: 20 73 00  JSR $0073     ; CHRGET: Get next Byte of BASIC Text
B0B3: 90 FB     BCC $B0B0
B0B5: 20 13 B1  JSR $B113     ; Does A hold an alphabetic character?
B0B8: B0 F6     BCS $B0B0

Jump from $B0AD:

B0BA: C9 24     CMP #$24
B0BC: D0 06     BNE $B0C4
B0BE: A9 FF     LDA #$FF
B0C0: 85 0D     STA $0D       ; Data type Flag
B0C2: D0 10     BNE $B0D4

Jump from $B0BC:

B0C4: C9 25     CMP #$25
B0C6: D0 13     BNE $B0DB
B0C8: A5 10     LDA $10       ; Flag: Subscript reference/User Function call
B0CA: D0 D0     BNE $B09C
B0CC: A9 80     LDA #$80
B0CE: 85 0E     STA $0E       ; Data type Flag
B0D0: 05 45     ORA $45       ; Name of Variable being sought in Variable Table
B0D2: 85 45     STA $45       ; Name of Variable being sought in Variable Table

Jump from $B0C2:

B0D4: 8A        TXA
B0D5: 09 80     ORA #$80
B0D7: AA        TAX
B0D8: 20 73 00  JSR $0073     ; CHRGET: Get next Byte of BASIC Text

Jump from $B0C6:

B0DB: 86 46     STX $46       ; Name of Variable being sought in Variable Table
B0DD: 38        SEC
B0DE: 05 10     ORA $10       ; Flag: Subscript reference/User Function call
B0E0: E9 28     SBC #$28
B0E2: D0 03     BNE $B0E7     ; Locate Ordinary Variable
B0E4: 4C D1 B1  JMP $B1D1     ; Get Array Parameters


Kernal-Reference:

 BIT $B0E6   : $F9DD


 $B0E7/45287:   Locate Ordinary Variable

Jump from $B0E2:

B0E7: A0 00     LDY #$00
B0E9: 84 10     STY $10       ; Flag: Subscript reference/User Function call
B0EB: A5 2D     LDA $2D       ; Pointer: Start of BASIC Variables
B0ED: A6 2E     LDX $2E       ; Pointer: Start of BASIC Variables

Jump from $B111:

B0EF: 86 60     STX $60       ; Temporary storage for FLPT value

Jump from $B10E:

B0F1: 85 5F     STA $5F       ; Temporary storage for FLPT value
B0F3: E4 30     CPX $30       ; Pointer: Start of BASIC Arrays
B0F5: D0 04     BNE $B0FB
B0F7: C5 2F     CMP $2F       ; Pointer: Start of BASIC Arrays
B0F9: F0 22     BEQ $B11D     ; Create New Variable

Jump from $B0F5:

B0FB: A5 45     LDA $45       ; Name of Variable being sought in Variable Table
B0FD: D1 5F     CMP ($5F),Y   ; Temporary storage for FLPT value
B0FF: D0 08     BNE $B109
B101: A5 46     LDA $46       ; Name of Variable being sought in Variable Table
B103: C8        INY
B104: D1 5F     CMP ($5F),Y   ; Temporary storage for FLPT value
B106: F0 7D     BEQ $B185     ; Create Variable
B108: 88        DEY

Jump from $B0FF:

B109: 18        CLC
B10A: A5 5F     LDA $5F       ; Temporary storage for FLPT value
B10C: 69 07     ADC #$07
B10E: 90 E1     BCC $B0F1
B110: E8        INX
B111: D0 DC     BNE $B0EF



 $B113/45331:   Does A hold an alphabetic character?

Jump from $AE92, $B097, $B0AA, $B0B5:

B113: C9 41     CMP #$41
B115: 90 05     BCC $B11C
B117: E9 5B     SBC #$5B
B119: 38        SEC
B11A: E9 A5     SBC #$A5

Jump from $B115:

B11C: 60        RTS



 $B11D/45341:   Create New Variable

Jump from $B0F9:

B11D: 68        PLA
B11E: 48        PHA
B11F: C9 2A     CMP #$2A
B121: D0 05     BNE $B128     ; Create Variable

Jump from $B132:

B123: A9 13     LDA #$13
B125: A0 BF     LDY #$BF
B127: 60        RTS



 $B128/45352:   Create Variable

Jump from $B121:

B128: A5 45     LDA $45       ; Name of Variable being sought in Variable Table
B12A: A4 46     LDY $46       ; Name of Variable being sought in Variable Table
B12C: C9 54     CMP #$54
B12E: D0 0B     BNE $B13B
B130: C0 C9     CPY #$C9
B132: F0 EF     BEQ $B123     ; Create New Variable
B134: C0 49     CPY #$49
B136: D0 03     BNE $B13B

Jump from $B141:

B138: 4C 08 AF  JMP $AF08     ; Output ?SYNTAX Error

Jump from $B12E, $B136:

B13B: C9 53     CMP #$53
B13D: D0 04     BNE $B143
B13F: C0 54     CPY #$54
B141: F0 F5     BEQ $B138

Jump from $B13D:

B143: A5 2F     LDA $2F       ; Pointer: Start of BASIC Arrays
B145: A4 30     LDY $30       ; Pointer: Start of BASIC Arrays
B147: 85 5F     STA $5F       ; Temporary storage for FLPT value
B149: 84 60     STY $60       ; Temporary storage for FLPT value
B14B: A5 31     LDA $31       ; Pointer: End of BASIC Arrays + 1
B14D: A4 32     LDY $32       ; Pointer: End of BASIC Arrays + 1
B14F: 85 5A     STA $5A       ; Temporary storage for FLPT value
B151: 84 5B     STY $5B       ; Temporary storage for FLPT value
B153: 18        CLC
B154: 69 07     ADC #$07
B156: 90 01     BCC $B159
B158: C8        INY

Jump from $B156:

B159: 85 58     STA $58       ; Temporary storage for FLPT value
B15B: 84 59     STY $59       ; Temporary storage for FLPT value
B15D: 20 B8 A3  JSR $A3B8     ; Open Space in Memory
B160: A5 58     LDA $58       ; Temporary storage for FLPT value
B162: A4 59     LDY $59       ; Temporary storage for FLPT value
B164: C8        INY
B165: 85 2F     STA $2F       ; Pointer: Start of BASIC Arrays
B167: 84 30     STY $30       ; Pointer: Start of BASIC Arrays
B169: A0 00     LDY #$00
B16B: A5 45     LDA $45       ; Name of Variable being sought in Variable Table
B16D: 91 5F     STA ($5F),Y   ; Temporary storage for FLPT value
B16F: C8        INY
B170: A5 46     LDA $46       ; Name of Variable being sought in Variable Table
B172: 91 5F     STA ($5F),Y   ; Temporary storage for FLPT value
B174: A9 00     LDA #$00
B176: C8        INY
B177: 91 5F     STA ($5F),Y   ; Temporary storage for FLPT value
B179: C8        INY
B17A: 91 5F     STA ($5F),Y   ; Temporary storage for FLPT value
B17C: C8        INY
B17D: 91 5F     STA ($5F),Y   ; Temporary storage for FLPT value
B17F: C8        INY
B180: 91 5F     STA ($5F),Y   ; Temporary storage for FLPT value
B182: C8        INY
B183: 91 5F     STA ($5F),Y   ; Temporary storage for FLPT value

Jump from $B106:

B185: A5 5F     LDA $5F       ; Temporary storage for FLPT value
B187: 18        CLC
B188: 69 02     ADC #$02
B18A: A4 60     LDY $60       ; Temporary storage for FLPT value
B18C: 90 01     BCC $B18F
B18E: C8        INY

Jump from $B18C:

B18F: 85 47     STA $47       ; Value/Descriptor-Pointer
B191: 84 48     STY $48       ; Value/Descriptor-Pointer
B193: 60        RTS



 $B194/45460:   Allocate Array Pointer Space

Jump from $B253, $B261:

B194: A5 0B     LDA $0B       ; Input Buffer Pointer/Number of Subscripts
B196: 0A        ASL
B197: 69 05     ADC #$05
B199: 65 5F     ADC $5F       ; Temporary storage for FLPT value
B19B: A4 60     LDY $60       ; Temporary storage for FLPT value
B19D: 90 01     BCC $B1A0
B19F: C8        INY

Jump from $B19D:

B1A0: 85 58     STA $58       ; Temporary storage for FLPT value
B1A2: 84 59     STY $59       ; Temporary storage for FLPT value
B1A4: 60        RTS



 $B1A5/45477:   Constant 32768 in Flpt

B1A5: 90 80 00 00 00



 $B1AA/45482:   FAC#1 to Integer in A/Y

B1AA: 20 BF B1  JSR $B1BF     ; FAC#1 to Positive Integer
B1AD: A5 64     LDA $64       ; FAC Mantissa
B1AF: A4 65     LDY $65       ; FAC Mantissa
B1B1: 60        RTS



 $B1B2/45490:   Evaluate Text for Integer

Jump from $B1E3:

B1B2: 20 73 00  JSR $0073     ; CHRGET: Get next Byte of BASIC Text
B1B5: 20 9E AD  JSR $AD9E     ; Evaluate Expression in Text

Jump from $B7A1:

B1B8: 20 8D AD  JSR $AD8D     ; Confirm Result
B1BB: A5 66     LDA $66       ; FAC Sign
B1BD: 30 0D     BMI $B1CC     ; FAC#1 to Positive Integer



 $B1BF/45503:   FAC#1 to Positive Integer

Jump from $A9C7, $AED4, $AFED, $AFFF, $B1AA:

B1BF: A5 61     LDA $61       ; FAC Exponent
B1C1: C9 90     CMP #$90
B1C3: 90 09     BCC $B1CE
B1C5: A9 A5     LDA #$A5
B1C7: A0 B1     LDY #$B1
B1C9: 20 5B BC  JSR $BC5B     ; Compare FAC#1 With Memory

Jump from $B1BD:

B1CC: D0 7A     BNE $B248     ; ?ILLEGAL QUANTITY

Jump from $B1C3:

B1CE: 4C 9B BC  JMP $BC9B     ; Convert FAC#1 to Integer



 $B1D1/45521:   Get Array Parameters

Jump from $B0E4:

B1D1: A5 0C     LDA $0C       ; Flag: Default Array dimension
B1D3: 05 0E     ORA $0E       ; Data type Flag
B1D5: 48        PHA
B1D6: A5 0D     LDA $0D       ; Data type Flag
B1D8: 48        PHA
B1D9: A0 00     LDY #$00

Jump from $B207:

B1DB: 98        TYA
B1DC: 48        PHA
B1DD: A5 46     LDA $46       ; Name of Variable being sought in Variable Table
B1DF: 48        PHA
B1E0: A5 45     LDA $45       ; Name of Variable being sought in Variable Table
B1E2: 48        PHA
B1E3: 20 B2 B1  JSR $B1B2     ; Evaluate Text for Integer
B1E6: 68        PLA
B1E7: 85 45     STA $45       ; Name of Variable being sought in Variable Table
B1E9: 68        PLA
B1EA: 85 46     STA $46       ; Name of Variable being sought in Variable Table
B1EC: 68        PLA
B1ED: A8        TAY
B1EE: BA        TSX
B1EF: BD 02 01  LDA $0102,X   ; 6510 Hardware Stack Area
B1F2: 48        PHA
B1F3: BD 01 01  LDA $0101,X   ; 6510 Hardware Stack Area
B1F6: 48        PHA
B1F7: A5 64     LDA $64       ; FAC Mantissa
B1F9: 9D 02 01  STA $0102,X   ; 6510 Hardware Stack Area
B1FC: A5 65     LDA $65       ; FAC Mantissa
B1FE: 9D 01 01  STA $0101,X   ; 6510 Hardware Stack Area
B201: C8        INY
B202: 20 79 00  JSR $0079     ; CHRGOT: Get same Byte again
B205: C9 2C     CMP #$2C
B207: F0 D2     BEQ $B1DB
B209: 84 0B     STY $0B       ; Input Buffer Pointer/Number of Subscripts
B20B: 20 F7 AE  JSR $AEF7     ; Test ')'
B20E: 68        PLA
B20F: 85 0D     STA $0D       ; Data type Flag
B211: 68        PLA
B212: 85 0E     STA $0E       ; Data type Flag
B214: 29 7F     AND #$7F
B216: 85 0C     STA $0C       ; Flag: Default Array dimension



 $B218/45592:   Find Array

B218: A6 2F     LDX $2F       ; Pointer: Start of BASIC Arrays
B21A: A5 30     LDA $30       ; Pointer: Start of BASIC Arrays

Jump from $B243:

B21C: 86 5F     STX $5F       ; Temporary storage for FLPT value
B21E: 85 60     STA $60       ; Temporary storage for FLPT value
B220: C5 32     CMP $32       ; Pointer: End of BASIC Arrays + 1
B222: D0 04     BNE $B228
B224: E4 31     CPX $31       ; Pointer: End of BASIC Arrays + 1
B226: F0 39     BEQ $B261     ; Create Array

Jump from $B222:

B228: A0 00     LDY #$00
B22A: B1 5F     LDA ($5F),Y   ; Temporary storage for FLPT value
B22C: C8        INY
B22D: C5 45     CMP $45       ; Name of Variable being sought in Variable Table
B22F: D0 06     BNE $B237
B231: A5 46     LDA $46       ; Name of Variable being sought in Variable Table
B233: D1 5F     CMP ($5F),Y   ; Temporary storage for FLPT value
B235: F0 16     BEQ $B24D     ; ?REDIM'D ARRAY

Jump from $B22F:

B237: C8        INY
B238: B1 5F     LDA ($5F),Y   ; Temporary storage for FLPT value
B23A: 18        CLC
B23B: 65 5F     ADC $5F       ; Temporary storage for FLPT value
B23D: AA        TAX
B23E: C8        INY
B23F: B1 5F     LDA ($5F),Y   ; Temporary storage for FLPT value
B241: 65 60     ADC $60       ; Temporary storage for FLPT value
B243: 90 D7     BCC $B21C



 $B245/45637:   ?BAD SUBSCRIPT

Jump from $B25C, $B308:

B245: A2 12     LDX #$12
B247: 2C        .BYTE $2C



 $B248/45640:   ?ILLEGAL QUANTITY

Jump from $AA24, $B1CC, $B798, $B9F1:

B248: A2 0E     LDX #$0E

Jump from $B251:

B24A: 4C 37 A4  JMP $A437     ; Error Routine



 $B24D/45645:   ?REDIM'D ARRAY

Jump from $B235:

B24D: A2 13     LDX #$13
B24F: A5 0C     LDA $0C       ; Flag: Default Array dimension
B251: D0 F7     BNE $B24A     ; ?ILLEGAL QUANTITY
B253: 20 94 B1  JSR $B194     ; Allocate Array Pointer Space
B256: A5 0B     LDA $0B       ; Input Buffer Pointer/Number of Subscripts
B258: A0 04     LDY #$04
B25A: D1 5F     CMP ($5F),Y   ; Temporary storage for FLPT value
B25C: D0 E7     BNE $B245     ; ?BAD SUBSCRIPT
B25E: 4C EA B2  JMP $B2EA     ; Create Array



 $B261/45665:   Create Array

Jump from $B226:

B261: 20 94 B1  JSR $B194     ; Allocate Array Pointer Space
B264: 20 08 A4  JSR $A408     ; Check Memory Overlap
B267: A0 00     LDY #$00
B269: 84 72     STY $72       ; Pointer: Used during CRUNCH/ASCII conversion
B26B: A2 05     LDX #$05
B26D: A5 45     LDA $45       ; Name of Variable being sought in Variable Table
B26F: 91 5F     STA ($5F),Y   ; Temporary storage for FLPT value
B271: 10 01     BPL $B274
B273: CA        DEX

Jump from $B271:

B274: C8        INY
B275: A5 46     LDA $46       ; Name of Variable being sought in Variable Table
B277: 91 5F     STA ($5F),Y   ; Temporary storage for FLPT value
B279: 10 02     BPL $B27D
B27B: CA        DEX
B27C: CA        DEX

Jump from $B279:

B27D: 86 71     STX $71       ; Pointer: Used during CRUNCH/ASCII conversion
B27F: A5 0B     LDA $0B       ; Input Buffer Pointer/Number of Subscripts
B281: C8        INY
B282: C8        INY
B283: C8        INY
B284: 91 5F     STA ($5F),Y   ; Temporary storage for FLPT value

Jump from $B2A8:

B286: A2 0B     LDX #$0B
B288: A9 00     LDA #$00
B28A: 24 0C     BIT $0C       ; Flag: Default Array dimension
B28C: 50 08     BVC $B296
B28E: 68        PLA
B28F: 18        CLC
B290: 69 01     ADC #$01
B292: AA        TAX
B293: 68        PLA
B294: 69 00     ADC #$00

Jump from $B28C:

B296: C8        INY
B297: 91 5F     STA ($5F),Y   ; Temporary storage for FLPT value
B299: C8        INY
B29A: 8A        TXA
B29B: 91 5F     STA ($5F),Y   ; Temporary storage for FLPT value
B29D: 20 4C B3  JSR $B34C     ; Number of Bytes in Subscript
B2A0: 86 71     STX $71       ; Pointer: Used during CRUNCH/ASCII conversion
B2A2: 85 72     STA $72       ; Pointer: Used during CRUNCH/ASCII conversion
B2A4: A4 22     LDY $22       ; Second Utility Pointer
B2A6: C6 0B     DEC $0B       ; Input Buffer Pointer/Number of Subscripts
B2A8: D0 DC     BNE $B286
B2AA: 65 59     ADC $59       ; Temporary storage for FLPT value
B2AC: B0 5D     BCS $B30B
B2AE: 85 59     STA $59       ; Temporary storage for FLPT value
B2B0: A8        TAY
B2B1: 8A        TXA
B2B2: 65 58     ADC $58       ; Temporary storage for FLPT value
B2B4: 90 03     BCC $B2B9
B2B6: C8        INY
B2B7: F0 52     BEQ $B30B

Jump from $B2B4:

B2B9: 20 08 A4  JSR $A408     ; Check Memory Overlap
B2BC: 85 31     STA $31       ; Pointer: End of BASIC Arrays + 1
B2BE: 84 32     STY $32       ; Pointer: End of BASIC Arrays + 1
B2C0: A9 00     LDA #$00
B2C2: E6 72     INC $72       ; Pointer: Used during CRUNCH/ASCII conversion
B2C4: A4 71     LDY $71       ; Pointer: Used during CRUNCH/ASCII conversion
B2C6: F0 05     BEQ $B2CD

Jump from $B2CB, $B2D1:

B2C8: 88        DEY
B2C9: 91 58     STA ($58),Y   ; Temporary storage for FLPT value
B2CB: D0 FB     BNE $B2C8

Jump from $B2C6:

B2CD: C6 59     DEC $59       ; Temporary storage for FLPT value
B2CF: C6 72     DEC $72       ; Pointer: Used during CRUNCH/ASCII conversion
B2D1: D0 F5     BNE $B2C8
B2D3: E6 59     INC $59       ; Temporary storage for FLPT value
B2D5: 38        SEC
B2D6: A5 31     LDA $31       ; Pointer: End of BASIC Arrays + 1
B2D8: E5 5F     SBC $5F       ; Temporary storage for FLPT value
B2DA: A0 02     LDY #$02
B2DC: 91 5F     STA ($5F),Y   ; Temporary storage for FLPT value
B2DE: A5 32     LDA $32       ; Pointer: End of BASIC Arrays + 1
B2E0: C8        INY
B2E1: E5 60     SBC $60       ; Temporary storage for FLPT value
B2E3: 91 5F     STA ($5F),Y   ; Temporary storage for FLPT value
B2E5: A5 0C     LDA $0C       ; Flag: Default Array dimension
B2E7: D0 62     BNE $B34B     ; Locate Element in Array
B2E9: C8        INY

Jump from $B25E:

B2EA: B1 5F     LDA ($5F),Y   ; Temporary storage for FLPT value
B2EC: 85 0B     STA $0B       ; Input Buffer Pointer/Number of Subscripts
B2EE: A9 00     LDA #$00
B2F0: 85 71     STA $71       ; Pointer: Used during CRUNCH/ASCII conversion

Jump from $B326:

B2F2: 85 72     STA $72       ; Pointer: Used during CRUNCH/ASCII conversion
B2F4: C8        INY
B2F5: 68        PLA
B2F6: AA        TAX
B2F7: 85 64     STA $64       ; FAC Mantissa
B2F9: 68        PLA
B2FA: 85 65     STA $65       ; FAC Mantissa
B2FC: D1 5F     CMP ($5F),Y   ; Temporary storage for FLPT value
B2FE: 90 0E     BCC $B30E     ; Locate Element in Array
B300: D0 06     BNE $B308
B302: C8        INY
B303: 8A        TXA
B304: D1 5F     CMP ($5F),Y   ; Temporary storage for FLPT value
B306: 90 07     BCC $B30F     ; Locate Element in Array

Jump from $B300:

B308: 4C 45 B2  JMP $B245     ; ?BAD SUBSCRIPT

Jump from $B2AC, $B2B7, $B365, $B376:

B30B: 4C 35 A4  JMP $A435     ; Output ?OUT OF MEMORY Error



 $B30E/45838:   Locate Element in Array

Jump from $B2FE:

B30E: C8        INY

Jump from $B306:

B30F: A5 72     LDA $72       ; Pointer: Used during CRUNCH/ASCII conversion
B311: 05 71     ORA $71       ; Pointer: Used during CRUNCH/ASCII conversion
B313: 18        CLC
B314: F0 0A     BEQ $B320
B316: 20 4C B3  JSR $B34C     ; Number of Bytes in Subscript
B319: 8A        TXA
B31A: 65 64     ADC $64       ; FAC Mantissa
B31C: AA        TAX
B31D: 98        TYA
B31E: A4 22     LDY $22       ; Second Utility Pointer

Jump from $B314:

B320: 65 65     ADC $65       ; FAC Mantissa
B322: 86 71     STX $71       ; Pointer: Used during CRUNCH/ASCII conversion
B324: C6 0B     DEC $0B       ; Input Buffer Pointer/Number of Subscripts
B326: D0 CA     BNE $B2F2     ; Create Array
B328: 85 72     STA $72       ; Pointer: Used during CRUNCH/ASCII conversion
B32A: A2 05     LDX #$05
B32C: A5 45     LDA $45       ; Name of Variable being sought in Variable Table
B32E: 10 01     BPL $B331
B330: CA        DEX

Jump from $B32E:

B331: A5 46     LDA $46       ; Name of Variable being sought in Variable Table
B333: 10 02     BPL $B337
B335: CA        DEX
B336: CA        DEX

Jump from $B333:

B337: 86 28     STX $28       ; Floating point product of Multiply and Divide
B339: A9 00     LDA #$00
B33B: 20 55 B3  JSR $B355     ; Number of Bytes in Subscript
B33E: 8A        TXA
B33F: 65 58     ADC $58       ; Temporary storage for FLPT value
B341: 85 47     STA $47       ; Value/Descriptor-Pointer
B343: 98        TYA
B344: 65 59     ADC $59       ; Temporary storage for FLPT value
B346: 85 48     STA $48       ; Value/Descriptor-Pointer
B348: A8        TAY
B349: A5 47     LDA $47       ; Value/Descriptor-Pointer

Jump from $B2E7, $B3A9:

B34B: 60        RTS



 $B34C/45900:   Number of Bytes in Subscript

Jump from $B29D, $B316:

B34C: 84 22     STY $22       ; Second Utility Pointer
B34E: B1 5F     LDA ($5F),Y   ; Temporary storage for FLPT value
B350: 85 28     STA $28       ; Floating point product of Multiply and Divide
B352: 88        DEY
B353: B1 5F     LDA ($5F),Y   ; Temporary storage for FLPT value

Jump from $B33B:

B355: 85 29     STA $29       ; Floating point product of Multiply and Divide
B357: A9 10     LDA #$10
B359: 85 5D     STA $5D       ; Temporary storage for FLPT value
B35B: A2 00     LDX #$00
B35D: A0 00     LDY #$00

Jump from $B37A:

B35F: 8A        TXA
B360: 0A        ASL
B361: AA        TAX
B362: 98        TYA
B363: 2A        ROL
B364: A8        TAY
B365: B0 A4     BCS $B30B     ; Create Array
B367: 06 71     ASL $71       ; Pointer: Used during CRUNCH/ASCII conversion
B369: 26 72     ROL $72       ; Pointer: Used during CRUNCH/ASCII conversion
B36B: 90 0B     BCC $B378
B36D: 18        CLC
B36E: 8A        TXA
B36F: 65 28     ADC $28       ; Floating point product of Multiply and Divide
B371: AA        TAX
B372: 98        TYA
B373: 65 29     ADC $29       ; Floating point product of Multiply and Divide
B375: A8        TAY
B376: B0 93     BCS $B30B     ; Create Array

Jump from $B36B:

B378: C6 5D     DEC $5D       ; Temporary storage for FLPT value
B37A: D0 E3     BNE $B35F
B37C: 60        RTS



 $B37D/45949:   Evaluate <fre>

B37D: A5 0D     LDA $0D       ; Data type Flag
B37F: F0 03     BEQ $B384
B381: 20 A6 B6  JSR $B6A6     ; Perform String Housekeeping

Jump from $B37F:

B384: 20 26 B5  JSR $B526     ; Garbage Collection
B387: 38        SEC
B388: A5 33     LDA $33       ; Pointer: Bottom of String space
B38A: E5 31     SBC $31       ; Pointer: End of BASIC Arrays + 1
B38C: A8        TAY
B38D: A5 34     LDA $34       ; Pointer: Bottom of String space
B38F: E5 32     SBC $32       ; Pointer: End of BASIC Arrays + 1



 $B391/45969:   Convert Integer in (AC/YR) to Flpt

Jump from $AEE0, $AF6B, $B013, $B3A4:

B391: A2 00     LDX #$00
B393: 86 0D     STX $0D       ; Data type Flag
B395: 85 62     STA $62       ; FAC Mantissa
B397: 84 63     STY $63       ; FAC Mantissa
B399: A2 90     LDX #$90
B39B: 4C 44 BC  JMP $BC44     ; Evaluate <sgn>



 $B39E/45982:   Evaluate <pos>

B39E: 38        SEC
B39F: 20 F0 FF  JSR $FFF0     ; Read / Set Cursor X/Y Position

Jump from $B77F, $B795, $B821:

B3A2: A9 00     LDA #$00
B3A4: F0 EB     BEQ $B391     ; Convert Integer in (AC/YR) to Flpt



 $B3A6/45990:   Confirm Program Mode

Jump from $AB7B, $ABCE, $B3B6:

B3A6: A6 3A     LDX $3A       ; Current BASIC Line number
B3A8: E8        INX
B3A9: D0 A0     BNE $B34B     ; Locate Element in Array
B3AB: A2 15     LDX #$15
B3AD: 2C        .BYTE $2C



 $B3AE/45998:   ?UNDEF'D FUNCTION

Jump from $B413:

B3AE: A2 1B     LDX #$1B
B3B0: 4C 37 A4  JMP $A437     ; Error Routine



 $B3B3/46003:   Perform [def fn]

B3B3: 20 E1 B3  JSR $B3E1     ; Check Syntax of FN
B3B6: 20 A6 B3  JSR $B3A6     ; Confirm Program Mode
B3B9: 20 FA AE  JSR $AEFA     ; Test '('
B3BC: A9 80     LDA #$80
B3BE: 85 10     STA $10       ; Flag: Subscript reference/User Function call
B3C0: 20 8B B0  JSR $B08B     ; Identify Variable
B3C3: 20 8D AD  JSR $AD8D     ; Confirm Result
B3C6: 20 F7 AE  JSR $AEF7     ; Test ')'
B3C9: A9 B2     LDA #$B2
B3CB: 20 FF AE  JSR $AEFF     ; Test ','
B3CE: 48        PHA
B3CF: A5 48     LDA $48       ; Value/Descriptor-Pointer
B3D1: 48        PHA
B3D2: A5 47     LDA $47       ; Value/Descriptor-Pointer
B3D4: 48        PHA
B3D5: A5 7B     LDA $7B       ; Pointer: Current Byte of BASIC Text
B3D7: 48        PHA
B3D8: A5 7A     LDA $7A       ; Pointer: Current Byte of BASIC Text
B3DA: 48        PHA
B3DB: 20 F8 A8  JSR $A8F8     ; Perform [data]
B3DE: 4C 4F B4  JMP $B44F     ; Perform [fn]



 $B3E1/46049:   Check Syntax of FN

Jump from $B3B3, $B3F4:

B3E1: A9 A5     LDA #$A5
B3E3: 20 FF AE  JSR $AEFF     ; Test ','
B3E6: 09 80     ORA #$80
B3E8: 85 10     STA $10       ; Flag: Subscript reference/User Function call
B3EA: 20 92 B0  JSR $B092     ; Identify Variable
B3ED: 85 4E     STA $4E       ; Temporary storage for FLPT value
B3EF: 84 4F     STY $4F       ; Temporary storage for FLPT value
B3F1: 4C 8D AD  JMP $AD8D     ; Confirm Result



 $B3F4/46068:   Perform [fn]

Jump from $AEE7:

B3F4: 20 E1 B3  JSR $B3E1     ; Check Syntax of FN
B3F7: A5 4F     LDA $4F       ; Temporary storage for FLPT value
B3F9: 48        PHA
B3FA: A5 4E     LDA $4E       ; Temporary storage for FLPT value
B3FC: 48        PHA
B3FD: 20 F1 AE  JSR $AEF1     ; Expression in Brackets
B400: 20 8D AD  JSR $AD8D     ; Confirm Result
B403: 68        PLA
B404: 85 4E     STA $4E       ; Temporary storage for FLPT value
B406: 68        PLA
B407: 85 4F     STA $4F       ; Temporary storage for FLPT value
B409: A0 02     LDY #$02
B40B: B1 4E     LDA ($4E),Y   ; Temporary storage for FLPT value
B40D: 85 47     STA $47       ; Value/Descriptor-Pointer
B40F: AA        TAX
B410: C8        INY
B411: B1 4E     LDA ($4E),Y   ; Temporary storage for FLPT value
B413: F0 99     BEQ $B3AE     ; ?UNDEF'D FUNCTION
B415: 85 48     STA $48       ; Value/Descriptor-Pointer
B417: C8        INY

Jump from $B41C:

B418: B1 47     LDA ($47),Y   ; Value/Descriptor-Pointer
B41A: 48        PHA
B41B: 88        DEY
B41C: 10 FA     BPL $B418
B41E: A4 48     LDY $48       ; Value/Descriptor-Pointer
B420: 20 D4 BB  JSR $BBD4     ; Store FAC#1 in Memory
B423: A5 7B     LDA $7B       ; Pointer: Current Byte of BASIC Text
B425: 48        PHA
B426: A5 7A     LDA $7A       ; Pointer: Current Byte of BASIC Text
B428: 48        PHA
B429: B1 4E     LDA ($4E),Y   ; Temporary storage for FLPT value
B42B: 85 7A     STA $7A       ; Pointer: Current Byte of BASIC Text
B42D: C8        INY
B42E: B1 4E     LDA ($4E),Y   ; Temporary storage for FLPT value
B430: 85 7B     STA $7B       ; Pointer: Current Byte of BASIC Text
B432: A5 48     LDA $48       ; Value/Descriptor-Pointer
B434: 48        PHA
B435: A5 47     LDA $47       ; Value/Descriptor-Pointer
B437: 48        PHA
B438: 20 8A AD  JSR $AD8A     ; Confirm Result
B43B: 68        PLA
B43C: 85 4E     STA $4E       ; Temporary storage for FLPT value
B43E: 68        PLA
B43F: 85 4F     STA $4F       ; Temporary storage for FLPT value
B441: 20 79 00  JSR $0079     ; CHRGOT: Get same Byte again
B444: F0 03     BEQ $B449
B446: 4C 08 AF  JMP $AF08     ; Output ?SYNTAX Error

Jump from $B444:

B449: 68        PLA
B44A: 85 7A     STA $7A       ; Pointer: Current Byte of BASIC Text
B44C: 68        PLA
B44D: 85 7B     STA $7B       ; Pointer: Current Byte of BASIC Text

Jump from $B3DE:

B44F: A0 00     LDY #$00
B451: 68        PLA
B452: 91 4E     STA ($4E),Y   ; Temporary storage for FLPT value
B454: 68        PLA
B455: C8        INY
B456: 91 4E     STA ($4E),Y   ; Temporary storage for FLPT value
B458: 68        PLA
B459: C8        INY
B45A: 91 4E     STA ($4E),Y   ; Temporary storage for FLPT value
B45C: 68        PLA
B45D: C8        INY
B45E: 91 4E     STA ($4E),Y   ; Temporary storage for FLPT value
B460: 68        PLA
B461: C8        INY
B462: 91 4E     STA ($4E),Y   ; Temporary storage for FLPT value
B464: 60        RTS



 $B465/46181:   Evaluate <str$>

B465: 20 8D AD  JSR $AD8D     ; Confirm Result
B468: A0 00     LDY #$00
B46A: 20 DF BD  JSR $BDDF     ; Convert FAC#1 to ASCII String
B46D: 68        PLA
B46E: 68        PLA

Jump from $AF59:

B46F: A9 FF     LDA #$FF
B471: A0 00     LDY #$00
B473: F0 12     BEQ $B487     ; Set Up String

Jump from $AA56, $B4C0, $B65D:

B475: A6 64     LDX $64       ; FAC Mantissa
B477: A4 65     LDY $65       ; FAC Mantissa
B479: 86 50     STX $50       ; Temporary storage for FLPT value
B47B: 84 51     STY $51       ; Temporary storage for FLPT value

Jump from $B6F3, $B70F:

B47D: 20 F4 B4  JSR $B4F4     ; Allocate Space for String
B480: 86 62     STX $62       ; FAC Mantissa
B482: 84 63     STY $63       ; FAC Mantissa
B484: 85 61     STA $61       ; FAC Exponent
B486: 60        RTS



 $B487/46215:   Set Up String

Jump from $AABF, $AB1E, $AEC6, $B473:

B487: A2 22     LDX #$22
B489: 86 07     STX $07       ; Temporary Integer during OR/AND
B48B: 86 08     STX $08       ; Flag: Scan for Quote at end of String

Jump from $AC7D:

B48D: 85 6F     STA $6F       ; Sign of result of Arithmetic Evaluation
B48F: 84 70     STY $70       ; FAC low-order rounding
B491: 85 62     STA $62       ; FAC Mantissa
B493: 84 63     STY $63       ; FAC Mantissa
B495: A0 FF     LDY #$FF

Jump from $B4A2:

B497: C8        INY
B498: B1 6F     LDA ($6F),Y   ; Sign of result of Arithmetic Evaluation
B49A: F0 0C     BEQ $B4A8
B49C: C5 07     CMP $07       ; Temporary Integer during OR/AND
B49E: F0 04     BEQ $B4A4
B4A0: C5 08     CMP $08       ; Flag: Scan for Quote at end of String
B4A2: D0 F3     BNE $B497

Jump from $B49E:

B4A4: C9 22     CMP #$22
B4A6: F0 01     BEQ $B4A9

Jump from $B49A:

B4A8: 18        CLC

Jump from $B4A6:

B4A9: 84 61     STY $61       ; FAC Exponent
B4AB: 98        TYA
B4AC: 65 6F     ADC $6F       ; Sign of result of Arithmetic Evaluation
B4AE: 85 71     STA $71       ; Pointer: Used during CRUNCH/ASCII conversion
B4B0: A6 70     LDX $70       ; FAC low-order rounding
B4B2: 90 01     BCC $B4B5
B4B4: E8        INX

Jump from $B4B2:

B4B5: 86 72     STX $72       ; Pointer: Used during CRUNCH/ASCII conversion
B4B7: A5 70     LDA $70       ; FAC low-order rounding
B4B9: F0 04     BEQ $B4BF
B4BB: C9 02     CMP #$02
B4BD: D0 0B     BNE $B4CA

Jump from $B4B9:

B4BF: 98        TYA
B4C0: 20 75 B4  JSR $B475     ; Evaluate <str$>
B4C3: A6 6F     LDX $6F       ; Sign of result of Arithmetic Evaluation
B4C5: A4 70     LDY $70       ; FAC low-order rounding
B4C7: 20 88 B6  JSR $B688     ; Store String in High RAM

Jump from $B4BD, $B674, $B6FD, $B729:

B4CA: A6 16     LDX $16       ; Pointer: Temporary String Stack
B4CC: E0 22     CPX #$22
B4CE: D0 05     BNE $B4D5     ; Save String Descriptor
B4D0: A2 19     LDX #$19

Jump from $B51A:

B4D2: 4C 37 A4  JMP $A437     ; Error Routine



 $B4D5/46293:   Save String Descriptor

Jump from $B4CE:

B4D5: A5 61     LDA $61       ; FAC Exponent
B4D7: 95 00     STA $00,X     ; 6510 On-chip Data Direction Register
B4D9: A5 62     LDA $62       ; FAC Mantissa
B4DB: 95 01     STA $01,X     ; 6510 On-chip 8-bit Input/Output Register
B4DD: A5 63     LDA $63       ; FAC Mantissa
B4DF: 95 02     STA $02,X     ; Unused
B4E1: A0 00     LDY #$00
B4E3: 86 64     STX $64       ; FAC Mantissa
B4E5: 84 65     STY $65       ; FAC Mantissa
B4E7: 84 70     STY $70       ; FAC low-order rounding
B4E9: 88        DEY
B4EA: 84 0D     STY $0D       ; Data type Flag
B4EC: 86 17     STX $17       ; Last temporary String Address
B4EE: E8        INX
B4EF: E8        INX
B4F0: E8        INX
B4F1: 86 16     STX $16       ; Pointer: Temporary String Stack
B4F3: 60        RTS



 $B4F4/46324:   Allocate Space for String

Jump from $B47D:

B4F4: 46 0F     LSR $0F       ; Flag: DATA scan/List Quote/Garbage collection

Jump from $B524:

B4F6: 48        PHA
B4F7: 49 FF     EOR #$FF
B4F9: 38        SEC
B4FA: 65 33     ADC $33       ; Pointer: Bottom of String space
B4FC: A4 34     LDY $34       ; Pointer: Bottom of String space
B4FE: B0 01     BCS $B501
B500: 88        DEY

Jump from $B4FE:

B501: C4 32     CPY $32       ; Pointer: End of BASIC Arrays + 1
B503: 90 11     BCC $B516
B505: D0 04     BNE $B50B
B507: C5 31     CMP $31       ; Pointer: End of BASIC Arrays + 1
B509: 90 0B     BCC $B516

Jump from $B505:

B50B: 85 33     STA $33       ; Pointer: Bottom of String space
B50D: 84 34     STY $34       ; Pointer: Bottom of String space
B50F: 85 35     STA $35       ; Utility String Pointer
B511: 84 36     STY $36       ; Utility String Pointer
B513: AA        TAX
B514: 68        PLA
B515: 60        RTS

Jump from $B503, $B509:

B516: A2 10     LDX #$10
B518: A5 0F     LDA $0F       ; Flag: DATA scan/List Quote/Garbage collection
B51A: 30 B6     BMI $B4D2     ; Set Up String
B51C: 20 26 B5  JSR $B526     ; Garbage Collection
B51F: A9 80     LDA #$80
B521: 85 0F     STA $0F       ; Flag: DATA scan/List Quote/Garbage collection
B523: 68        PLA
B524: D0 D0     BNE $B4F6



 $B526/46374:   Garbage Collection

Jump from $A41C, $B384, $B51C:

B526: A6 37     LDX $37       ; Pointer: Highest Address available to BASIC
B528: A5 38     LDA $38       ; Pointer: Highest Address available to BASIC

Jump from $B63A:

B52A: 86 33     STX $33       ; Pointer: Bottom of String space
B52C: 85 34     STA $34       ; Pointer: Bottom of String space
B52E: A0 00     LDY #$00
B530: 84 4F     STY $4F       ; Temporary storage for FLPT value
B532: 84 4E     STY $4E       ; Temporary storage for FLPT value
B534: A5 31     LDA $31       ; Pointer: End of BASIC Arrays + 1
B536: A6 32     LDX $32       ; Pointer: End of BASIC Arrays + 1
B538: 85 5F     STA $5F       ; Temporary storage for FLPT value
B53A: 86 60     STX $60       ; Temporary storage for FLPT value
B53C: A9 19     LDA #$19
B53E: A2 00     LDX #$00
B540: 85 22     STA $22       ; Second Utility Pointer
B542: 86 23     STX $23       ; Second Utility Pointer

Jump from $B54B:

B544: C5 16     CMP $16       ; Pointer: Temporary String Stack
B546: F0 05     BEQ $B54D
B548: 20 C7 B5  JSR $B5C7     ; Search for Next String
B54B: F0 F7     BEQ $B544

Jump from $B546:

B54D: A9 07     LDA #$07
B54F: 85 53     STA $53       ; Length of String during Garbage collection
B551: A5 2D     LDA $2D       ; Pointer: Start of BASIC Variables
B553: A6 2E     LDX $2E       ; Pointer: Start of BASIC Variables
B555: 85 22     STA $22       ; Second Utility Pointer
B557: 86 23     STX $23       ; Second Utility Pointer

Jump from $B564:

B559: E4 30     CPX $30       ; Pointer: Start of BASIC Arrays
B55B: D0 04     BNE $B561
B55D: C5 2F     CMP $2F       ; Pointer: Start of BASIC Arrays
B55F: F0 05     BEQ $B566

Jump from $B55B:

B561: 20 BD B5  JSR $B5BD     ; Search for Next String
B564: F0 F3     BEQ $B559

Jump from $B55F:

B566: 85 58     STA $58       ; Temporary storage for FLPT value
B568: 86 59     STX $59       ; Temporary storage for FLPT value
B56A: A9 03     LDA #$03
B56C: 85 53     STA $53       ; Length of String during Garbage collection

Jump from $B599, $B59C:

B56E: A5 58     LDA $58       ; Temporary storage for FLPT value
B570: A6 59     LDX $59       ; Temporary storage for FLPT value

Jump from $B5B6:

B572: E4 32     CPX $32       ; Pointer: End of BASIC Arrays + 1
B574: D0 07     BNE $B57D
B576: C5 31     CMP $31       ; Pointer: End of BASIC Arrays + 1
B578: D0 03     BNE $B57D
B57A: 4C 06 B6  JMP $B606     ; Collect a String

Jump from $B574, $B578:

B57D: 85 22     STA $22       ; Second Utility Pointer
B57F: 86 23     STX $23       ; Second Utility Pointer
B581: A0 00     LDY #$00
B583: B1 22     LDA ($22),Y   ; Second Utility Pointer
B585: AA        TAX
B586: C8        INY
B587: B1 22     LDA ($22),Y   ; Second Utility Pointer
B589: 08        PHP
B58A: C8        INY
B58B: B1 22     LDA ($22),Y   ; Second Utility Pointer
B58D: 65 58     ADC $58       ; Temporary storage for FLPT value
B58F: 85 58     STA $58       ; Temporary storage for FLPT value
B591: C8        INY
B592: B1 22     LDA ($22),Y   ; Second Utility Pointer
B594: 65 59     ADC $59       ; Temporary storage for FLPT value
B596: 85 59     STA $59       ; Temporary storage for FLPT value
B598: 28        PLP
B599: 10 D3     BPL $B56E
B59B: 8A        TXA
B59C: 30 D0     BMI $B56E
B59E: C8        INY
B59F: B1 22     LDA ($22),Y   ; Second Utility Pointer
B5A1: A0 00     LDY #$00
B5A3: 0A        ASL
B5A4: 69 05     ADC #$05
B5A6: 65 22     ADC $22       ; Second Utility Pointer
B5A8: 85 22     STA $22       ; Second Utility Pointer
B5AA: 90 02     BCC $B5AE
B5AC: E6 23     INC $23       ; Second Utility Pointer

Jump from $B5AA:

B5AE: A6 23     LDX $23       ; Second Utility Pointer

Jump from $B5BB:

B5B0: E4 59     CPX $59       ; Temporary storage for FLPT value
B5B2: D0 04     BNE $B5B8
B5B4: C5 58     CMP $58       ; Temporary storage for FLPT value
B5B6: F0 BA     BEQ $B572

Jump from $B5B2:

B5B8: 20 C7 B5  JSR $B5C7     ; Search for Next String
B5BB: F0 F3     BEQ $B5B0



 $B5BD/46525:   Search for Next String

Jump from $B561:

B5BD: B1 22     LDA ($22),Y   ; Second Utility Pointer
B5BF: 30 35     BMI $B5F6
B5C1: C8        INY
B5C2: B1 22     LDA ($22),Y   ; Second Utility Pointer
B5C4: 10 30     BPL $B5F6
B5C6: C8        INY

Jump from $B548, $B5B8:

B5C7: B1 22     LDA ($22),Y   ; Second Utility Pointer
B5C9: F0 2B     BEQ $B5F6
B5CB: C8        INY
B5CC: B1 22     LDA ($22),Y   ; Second Utility Pointer
B5CE: AA        TAX
B5CF: C8        INY
B5D0: B1 22     LDA ($22),Y   ; Second Utility Pointer
B5D2: C5 34     CMP $34       ; Pointer: Bottom of String space
B5D4: 90 06     BCC $B5DC
B5D6: D0 1E     BNE $B5F6
B5D8: E4 33     CPX $33       ; Pointer: Bottom of String space
B5DA: B0 1A     BCS $B5F6

Jump from $B5D4:

B5DC: C5 60     CMP $60       ; Temporary storage for FLPT value
B5DE: 90 16     BCC $B5F6
B5E0: D0 04     BNE $B5E6
B5E2: E4 5F     CPX $5F       ; Temporary storage for FLPT value
B5E4: 90 10     BCC $B5F6

Jump from $B5E0:

B5E6: 86 5F     STX $5F       ; Temporary storage for FLPT value
B5E8: 85 60     STA $60       ; Temporary storage for FLPT value
B5EA: A5 22     LDA $22       ; Second Utility Pointer
B5EC: A6 23     LDX $23       ; Second Utility Pointer
B5EE: 85 4E     STA $4E       ; Temporary storage for FLPT value
B5F0: 86 4F     STX $4F       ; Temporary storage for FLPT value
B5F2: A5 53     LDA $53       ; Length of String during Garbage collection
B5F4: 85 55     STA $55       ; Jump Vector used in Function Evaluation

Jump from $B5BF, $B5C4, $B5C9, $B5D6, $B5DA, $B5DE, $B5E4:

B5F6: A5 53     LDA $53       ; Length of String during Garbage collection
B5F8: 18        CLC
B5F9: 65 22     ADC $22       ; Second Utility Pointer
B5FB: 85 22     STA $22       ; Second Utility Pointer
B5FD: 90 02     BCC $B601
B5FF: E6 23     INC $23       ; Second Utility Pointer

Jump from $B5FD, $B60A:

B601: A6 23     LDX $23       ; Second Utility Pointer
B603: A0 00     LDY #$00
B605: 60        RTS



 $B606/46598:   Collect a String

Jump from $B57A:

B606: A5 4F     LDA $4F       ; Temporary storage for FLPT value
B608: 05 4E     ORA $4E       ; Temporary storage for FLPT value
B60A: F0 F5     BEQ $B601     ; Search for Next String
B60C: A5 55     LDA $55       ; Jump Vector used in Function Evaluation
B60E: 29 04     AND #$04
B610: 4A        LSR
B611: A8        TAY
B612: 85 55     STA $55       ; Jump Vector used in Function Evaluation
B614: B1 4E     LDA ($4E),Y   ; Temporary storage for FLPT value
B616: 65 5F     ADC $5F       ; Temporary storage for FLPT value
B618: 85 5A     STA $5A       ; Temporary storage for FLPT value
B61A: A5 60     LDA $60       ; Temporary storage for FLPT value
B61C: 69 00     ADC #$00
B61E: 85 5B     STA $5B       ; Temporary storage for FLPT value
B620: A5 33     LDA $33       ; Pointer: Bottom of String space
B622: A6 34     LDX $34       ; Pointer: Bottom of String space
B624: 85 58     STA $58       ; Temporary storage for FLPT value
B626: 86 59     STX $59       ; Temporary storage for FLPT value
B628: 20 BF A3  JSR $A3BF     ; Open Space in Memory
B62B: A4 55     LDY $55       ; Jump Vector used in Function Evaluation
B62D: C8        INY
B62E: A5 58     LDA $58       ; Temporary storage for FLPT value
B630: 91 4E     STA ($4E),Y   ; Temporary storage for FLPT value
B632: AA        TAX
B633: E6 59     INC $59       ; Temporary storage for FLPT value
B635: A5 59     LDA $59       ; Temporary storage for FLPT value
B637: C8        INY
B638: 91 4E     STA ($4E),Y   ; Temporary storage for FLPT value
B63A: 4C 2A B5  JMP $B52A     ; Garbage Collection



 $B63D/46653:   Concatenate Two Strings

Jump from $ADE5:

B63D: A5 65     LDA $65       ; FAC Mantissa
B63F: 48        PHA
B640: A5 64     LDA $64       ; FAC Mantissa
B642: 48        PHA
B643: 20 83 AE  JSR $AE83     ; Evaluate Single Term
B646: 20 8F AD  JSR $AD8F     ; Confirm Result
B649: 68        PLA
B64A: 85 6F     STA $6F       ; Sign of result of Arithmetic Evaluation
B64C: 68        PLA
B64D: 85 70     STA $70       ; FAC low-order rounding
B64F: A0 00     LDY #$00
B651: B1 6F     LDA ($6F),Y   ; Sign of result of Arithmetic Evaluation
B653: 18        CLC
B654: 71 64     ADC ($64),Y   ; FAC Mantissa
B656: 90 05     BCC $B65D
B658: A2 17     LDX #$17
B65A: 4C 37 A4  JMP $A437     ; Error Routine

Jump from $B656:

B65D: 20 75 B4  JSR $B475     ; Evaluate <str$>
B660: 20 7A B6  JSR $B67A     ; Store String in High RAM
B663: A5 50     LDA $50       ; Temporary storage for FLPT value
B665: A4 51     LDY $51       ; Temporary storage for FLPT value
B667: 20 AA B6  JSR $B6AA     ; Perform String Housekeeping
B66A: 20 8C B6  JSR $B68C     ; Store String in High RAM
B66D: A5 6F     LDA $6F       ; Sign of result of Arithmetic Evaluation
B66F: A4 70     LDY $70       ; FAC low-order rounding
B671: 20 AA B6  JSR $B6AA     ; Perform String Housekeeping
B674: 20 CA B4  JSR $B4CA     ; Set Up String
B677: 4C B8 AD  JMP $ADB8     ; Evaluate Expression in Text



 $B67A/46714:   Store String in High RAM

Jump from $AA61, $B660:

B67A: A0 00     LDY #$00
B67C: B1 6F     LDA ($6F),Y   ; Sign of result of Arithmetic Evaluation
B67E: 48        PHA
B67F: C8        INY
B680: B1 6F     LDA ($6F),Y   ; Sign of result of Arithmetic Evaluation
B682: AA        TAX
B683: C8        INY
B684: B1 6F     LDA ($6F),Y   ; Sign of result of Arithmetic Evaluation
B686: A8        TAY
B687: 68        PLA

Jump from $B4C7:

B688: 86 22     STX $22       ; Second Utility Pointer
B68A: 84 23     STY $23       ; Second Utility Pointer

Jump from $B66A, $B726:

B68C: A8        TAY
B68D: F0 0A     BEQ $B699
B68F: 48        PHA

Jump from $B696:

B690: 88        DEY
B691: B1 22     LDA ($22),Y   ; Second Utility Pointer
B693: 91 35     STA ($35),Y   ; Utility String Pointer
B695: 98        TYA
B696: D0 F8     BNE $B690
B698: 68        PLA

Jump from $B68D:

B699: 18        CLC
B69A: 65 35     ADC $35       ; Utility String Pointer
B69C: 85 35     STA $35       ; Utility String Pointer
B69E: 90 02     BCC $B6A2
B6A0: E6 36     INC $36       ; Utility String Pointer

Jump from $B69E:

B6A2: 60        RTS



 $B6A3/46755:   Perform String Housekeeping

Jump from $B782, $E25A:

B6A3: 20 8F AD  JSR $AD8F     ; Confirm Result

Jump from $A9E0, $AB21, $B034, $B381:

B6A6: A5 64     LDA $64       ; FAC Mantissa
B6A8: A4 65     LDY $65       ; FAC Mantissa

Jump from $B041, $B667, $B671, $B716:

B6AA: 85 22     STA $22       ; Second Utility Pointer
B6AC: 84 23     STY $23       ; Second Utility Pointer
B6AE: 20 DB B6  JSR $B6DB     ; Clean Descriptor Stack
B6B1: 08        PHP
B6B2: A0 00     LDY #$00
B6B4: B1 22     LDA ($22),Y   ; Second Utility Pointer
B6B6: 48        PHA
B6B7: C8        INY
B6B8: B1 22     LDA ($22),Y   ; Second Utility Pointer
B6BA: AA        TAX
B6BB: C8        INY
B6BC: B1 22     LDA ($22),Y   ; Second Utility Pointer
B6BE: A8        TAY
B6BF: 68        PLA
B6C0: 28        PLP
B6C1: D0 13     BNE $B6D6
B6C3: C4 34     CPY $34       ; Pointer: Bottom of String space
B6C5: D0 0F     BNE $B6D6
B6C7: E4 33     CPX $33       ; Pointer: Bottom of String space
B6C9: D0 0B     BNE $B6D6
B6CB: 48        PHA
B6CC: 18        CLC
B6CD: 65 33     ADC $33       ; Pointer: Bottom of String space
B6CF: 85 33     STA $33       ; Pointer: Bottom of String space
B6D1: 90 02     BCC $B6D5
B6D3: E6 34     INC $34       ; Pointer: Bottom of String space

Jump from $B6D1:

B6D5: 68        PLA

Jump from $B6C1, $B6C5, $B6C9:

B6D6: 86 22     STX $22       ; Second Utility Pointer
B6D8: 84 23     STY $23       ; Second Utility Pointer
B6DA: 60        RTS



 $B6DB/46811:   Clean Descriptor Stack

Jump from $AA6C, $B6AE:

B6DB: C4 18     CPY $18       ; Last temporary String Address
B6DD: D0 0C     BNE $B6EB
B6DF: C5 17     CMP $17       ; Last temporary String Address
B6E1: D0 08     BNE $B6EB
B6E3: 85 16     STA $16       ; Pointer: Temporary String Stack
B6E5: E9 03     SBC #$03
B6E7: 85 17     STA $17       ; Last temporary String Address
B6E9: A0 00     LDY #$00

Jump from $B6DD, $B6E1:

B6EB: 60        RTS



 $B6EC/46828:   Evaluate <chr$>

B6EC: 20 A1 B7  JSR $B7A1     ; Evaluate Text to 1 Byte in XR
B6EF: 8A        TXA
B6F0: 48        PHA
B6F1: A9 01     LDA #$01
B6F3: 20 7D B4  JSR $B47D     ; Evaluate <str$>
B6F6: 68        PLA
B6F7: A0 00     LDY #$00
B6F9: 91 62     STA ($62),Y   ; FAC Mantissa
B6FB: 68        PLA
B6FC: 68        PLA
B6FD: 4C CA B4  JMP $B4CA     ; Set Up String



 $B700/46848:   Evaluate <left$>

B700: 20 61 B7  JSR $B761     ; Pull String Parameters
B703: D1 50     CMP ($50),Y   ; Temporary storage for FLPT value
B705: 98        TYA

Jump from $B734:

B706: 90 04     BCC $B70C
B708: B1 50     LDA ($50),Y   ; Temporary storage for FLPT value
B70A: AA        TAX
B70B: 98        TYA

Jump from $B706:

B70C: 48        PHA

Jump from $B755:

B70D: 8A        TXA

Jump from $B75B, $B75F:

B70E: 48        PHA
B70F: 20 7D B4  JSR $B47D     ; Evaluate <str$>
B712: A5 50     LDA $50       ; Temporary storage for FLPT value
B714: A4 51     LDY $51       ; Temporary storage for FLPT value
B716: 20 AA B6  JSR $B6AA     ; Perform String Housekeeping
B719: 68        PLA
B71A: A8        TAY
B71B: 68        PLA
B71C: 18        CLC
B71D: 65 22     ADC $22       ; Second Utility Pointer
B71F: 85 22     STA $22       ; Second Utility Pointer
B721: 90 02     BCC $B725
B723: E6 23     INC $23       ; Second Utility Pointer

Jump from $B721:

B725: 98        TYA
B726: 20 8C B6  JSR $B68C     ; Store String in High RAM
B729: 4C CA B4  JMP $B4CA     ; Set Up String



 $B72C/46892:   Evaluate <right$>

B72C: 20 61 B7  JSR $B761     ; Pull String Parameters
B72F: 18        CLC
B730: F1 50     SBC ($50),Y   ; Temporary storage for FLPT value
B732: 49 FF     EOR #$FF
B734: 4C 06 B7  JMP $B706     ; Evaluate <left$>



 $B737/46903:   Evaluate <mid$>

B737: A9 FF     LDA #$FF
B739: 85 65     STA $65       ; FAC Mantissa
B73B: 20 79 00  JSR $0079     ; CHRGOT: Get same Byte again
B73E: C9 29     CMP #$29
B740: F0 06     BEQ $B748
B742: 20 FD AE  JSR $AEFD     ; Test ','
B745: 20 9E B7  JSR $B79E     ; Evaluate Text to 1 Byte in XR

Jump from $B740:

B748: 20 61 B7  JSR $B761     ; Pull String Parameters
B74B: F0 4B     BEQ $B798     ; Evaluate <asc>
B74D: CA        DEX
B74E: 8A        TXA
B74F: 48        PHA
B750: 18        CLC
B751: A2 00     LDX #$00
B753: F1 50     SBC ($50),Y   ; Temporary storage for FLPT value
B755: B0 B6     BCS $B70D     ; Evaluate <left$>
B757: 49 FF     EOR #$FF
B759: C5 65     CMP $65       ; FAC Mantissa
B75B: 90 B1     BCC $B70E     ; Evaluate <left$>
B75D: A5 65     LDA $65       ; FAC Mantissa
B75F: B0 AD     BCS $B70E     ; Evaluate <left$>



 $B761/46945:   Pull String Parameters

Jump from $B700, $B72C, $B748:

B761: 20 F7 AE  JSR $AEF7     ; Test ')'
B764: 68        PLA
B765: A8        TAY
B766: 68        PLA
B767: 85 55     STA $55       ; Jump Vector used in Function Evaluation
B769: 68        PLA
B76A: 68        PLA
B76B: 68        PLA
B76C: AA        TAX
B76D: 68        PLA
B76E: 85 50     STA $50       ; Temporary storage for FLPT value
B770: 68        PLA
B771: 85 51     STA $51       ; Temporary storage for FLPT value
B773: A5 55     LDA $55       ; Jump Vector used in Function Evaluation
B775: 48        PHA
B776: 98        TYA
B777: 48        PHA
B778: A0 00     LDY #$00
B77A: 8A        TXA
B77B: 60        RTS



 $B77C/46972:   Evaluate <len>

B77C: 20 82 B7  JSR $B782     ; Exit String Mode
B77F: 4C A2 B3  JMP $B3A2     ; Evaluate <pos>



 $B782/46978:   Exit String Mode

Jump from $B77C, $B78B, $B7AD:

B782: 20 A3 B6  JSR $B6A3     ; Perform String Housekeeping
B785: A2 00     LDX #$00
B787: 86 0D     STX $0D       ; Data type Flag
B789: A8        TAY
B78A: 60        RTS



 $B78B/46987:   Evaluate <asc>

B78B: 20 82 B7  JSR $B782     ; Exit String Mode
B78E: F0 08     BEQ $B798
B790: A0 00     LDY #$00
B792: B1 22     LDA ($22),Y   ; Second Utility Pointer
B794: A8        TAY
B795: 4C A2 B3  JMP $B3A2     ; Evaluate <pos>

Jump from $B78E, $B74B, $B7A6, $B7F9, $B7FF:

B798: 4C 48 B2  JMP $B248     ; ?ILLEGAL QUANTITY



 $B79B/47003:   Evaluate Text to 1 Byte in XR

Jump from $AAFF:

B79B: 20 73 00  JSR $0073     ; CHRGET: Get next Byte of BASIC Text

Jump from $A94B, $AA86, $AB85, $ABA5, $AFC7, $B745, $B7F4, $E203, $E221:

B79E: 20 8A AD  JSR $AD8A     ; Confirm Result

Jump from $B6EC:

B7A1: 20 B8 B1  JSR $B1B8     ; Evaluate Text for Integer
B7A4: A6 64     LDX $64       ; FAC Mantissa
B7A6: D0 F0     BNE $B798     ; Evaluate <asc>
B7A8: A6 65     LDX $65       ; FAC Mantissa
B7AA: 4C 79 00  JMP $0079     ; CHRGET: Get next Byte of BASIC Text



 $B7AD/47021:   Evaluate <val>

B7AD: 20 82 B7  JSR $B782     ; Exit String Mode
B7B0: D0 03     BNE $B7B5     ; Convert ASCII String to Flpt
B7B2: 4C F7 B8  JMP $B8F7     ; Perform Addition



 $B7B5/47029:   Convert ASCII String to Flpt

Jump from $B7B0:

B7B5: A6 7A     LDX $7A       ; Pointer: Current Byte of BASIC Text
B7B7: A4 7B     LDY $7B       ; Pointer: Current Byte of BASIC Text
B7B9: 86 71     STX $71       ; Pointer: Used during CRUNCH/ASCII conversion
B7BB: 84 72     STY $72       ; Pointer: Used during CRUNCH/ASCII conversion
B7BD: A6 22     LDX $22       ; Second Utility Pointer
B7BF: 86 7A     STX $7A       ; Pointer: Current Byte of BASIC Text
B7C1: 18        CLC
B7C2: 65 22     ADC $22       ; Second Utility Pointer
B7C4: 85 24     STA $24       ; Second Utility Pointer
B7C6: A6 23     LDX $23       ; Second Utility Pointer
B7C8: 86 7B     STX $7B       ; Pointer: Current Byte of BASIC Text
B7CA: 90 01     BCC $B7CD
B7CC: E8        INX

Jump from $B7CA:

B7CD: 86 25     STX $25       ; Second Utility Pointer
B7CF: A0 00     LDY #$00
B7D1: B1 24     LDA ($24),Y   ; Second Utility Pointer
B7D3: 48        PHA
B7D4: 98        TYA
B7D5: 91 24     STA ($24),Y   ; Second Utility Pointer
B7D7: 20 79 00  JSR $0079     ; CHRGOT: Get same Byte again
B7DA: 20 F3 BC  JSR $BCF3     ; Convert ASCII String to a Number in FAC
B7DD: 68        PLA
B7DE: A0 00     LDY #$00
B7E0: 91 24     STA ($24),Y   ; Second Utility Pointer

Jump from $AC80, $AEC9:

B7E2: A6 71     LDX $71       ; Pointer: Used during CRUNCH/ASCII conversion
B7E4: A4 72     LDY $72       ; Pointer: Used during CRUNCH/ASCII conversion
B7E6: 86 7A     STX $7A       ; Pointer: Current Byte of BASIC Text
B7E8: 84 7B     STY $7B       ; Pointer: Current Byte of BASIC Text
B7EA: 60        RTS



 $B7EB/47083:   Get parameters for POKE/WAIT

Jump from $B824, $B82D:

B7EB: 20 8A AD  JSR $AD8A     ; Confirm Result
B7EE: 20 F7 B7  JSR $B7F7     ; Convert FAC#1 to Integer in LINNUM

Jump from $B839:

B7F1: 20 FD AE  JSR $AEFD     ; Test ','
B7F4: 4C 9E B7  JMP $B79E     ; Evaluate Text to 1 Byte in XR



 $B7F7/47095:   Convert FAC#1 to Integer in LINNUM

Jump from $B7EE, $B813, $E12D:

B7F7: A5 66     LDA $66       ; FAC Sign
B7F9: 30 9D     BMI $B798     ; Evaluate <asc>
B7FB: A5 61     LDA $61       ; FAC Exponent
B7FD: C9 91     CMP #$91
B7FF: B0 97     BCS $B798     ; Evaluate <asc>
B801: 20 9B BC  JSR $BC9B     ; Convert FAC#1 to Integer
B804: A5 64     LDA $64       ; FAC Mantissa
B806: A4 65     LDY $65       ; FAC Mantissa
B808: 84 14     STY $14       ; Temporary: Integer value
B80A: 85 15     STA $15       ; Temporary: Integer value
B80C: 60        RTS



 $B80D/47117:   Evaluate <peek>

B80D: A5 15     LDA $15       ; Temporary: Integer value
B80F: 48        PHA
B810: A5 14     LDA $14       ; Temporary: Integer value
B812: 48        PHA
B813: 20 F7 B7  JSR $B7F7     ; Convert FAC#1 to Integer in LINNUM
B816: A0 00     LDY #$00
B818: B1 14     LDA ($14),Y   ; Temporary: Integer value
B81A: A8        TAY
B81B: 68        PLA
B81C: 85 14     STA $14       ; Temporary: Integer value
B81E: 68        PLA
B81F: 85 15     STA $15       ; Temporary: Integer value
B821: 4C A2 B3  JMP $B3A2     ; Evaluate <pos>



 $B824/47140:   Perform [poke]

B824: 20 EB B7  JSR $B7EB     ; Get parameters for POKE/WAIT
B827: 8A        TXA
B828: A0 00     LDY #$00
B82A: 91 14     STA ($14),Y   ; Temporary: Integer value
B82C: 60        RTS



 $B82D/47149:   Perform [wait]

B82D: 20 EB B7  JSR $B7EB     ; Get parameters for POKE/WAIT
B830: 86 49     STX $49       ; Pointer: Index Variable for FOR/NEXT loop
B832: A2 00     LDX #$00
B834: 20 79 00  JSR $0079     ; CHRGOT: Get same Byte again
B837: F0 03     BEQ $B83C
B839: 20 F1 B7  JSR $B7F1     ; Get parameters for POKE/WAIT

Jump from $B837:

B83C: 86 4A     STX $4A       ; Pointer: Index Variable for FOR/NEXT loop
B83E: A0 00     LDY #$00

Jump from $B846:

B840: B1 14     LDA ($14),Y   ; Temporary: Integer value
B842: 45 4A     EOR $4A       ; Pointer: Index Variable for FOR/NEXT loop
B844: 25 49     AND $49       ; Pointer: Index Variable for FOR/NEXT loop
B846: F0 F8     BEQ $B840

Jump from $B878:

B848: 60        RTS



 $B849/47177:   Add 0.5 to FAC#1

Jump from $BE2F, $E290:

B849: A9 11     LDA #$11
B84B: A0 BF     LDY #$BF
B84D: 4C 67 B8  JMP $B867     ; Perform Addition



 $B850/47184:   Perform Subtraction

Jump from $BA0F, $E288, $E334:

B850: 20 8C BA  JSR $BA8C     ; Load FAC#2 From Memory

Jump from $E02D, $E281:

B853: A5 66     LDA $66       ; FAC Sign
B855: 49 FF     EOR #$FF
B857: 85 66     STA $66       ; FAC Sign
B859: 45 6E     EOR $6E       ; AFAC Sign
B85B: 85 6F     STA $6F       ; Sign of result of Arithmetic Evaluation
B85D: A5 61     LDA $61       ; FAC Exponent
B85F: 4C 6A B8  JMP $B86A     ; Perform Addition



 $B862/47202:   Normalise Addition

Jump from $B899:

B862: 20 99 B9  JSR $B999     ; Multiply by Zero Byte
B865: 90 3C     BCC $B8A3     ; Perform Addition



 $B867/47207:   Perform Addition

Jump from $AD4F, $B84D, $BA01, $BA1D, $E081, $E0D0, $E268, $E2A4:

B867: 20 8C BA  JSR $BA8C     ; Load FAC#2 From Memory

Jump from $B85F, $BD8E:

B86A: D0 03     BNE $B86F
B86C: 4C FC BB  JMP $BBFC     ; Copy FAC#2 into FAC#1

Jump from $B86A:

B86F: A6 70     LDX $70       ; FAC low-order rounding
B871: 86 56     STX $56       ; Jump Vector used in Function Evaluation
B873: A2 69     LDX #$69
B875: A5 69     LDA $69       ; AFAC Exponent

Jump from $BAF1:

B877: A8        TAY
B878: F0 CE     BEQ $B848     ; Perform [wait]
B87A: 38        SEC
B87B: E5 61     SBC $61       ; FAC Exponent
B87D: F0 24     BEQ $B8A3
B87F: 90 12     BCC $B893
B881: 84 61     STY $61       ; FAC Exponent
B883: A4 6E     LDY $6E       ; AFAC Sign
B885: 84 66     STY $66       ; FAC Sign
B887: 49 FF     EOR #$FF
B889: 69 00     ADC #$00
B88B: A0 00     LDY #$00
B88D: 84 56     STY $56       ; Jump Vector used in Function Evaluation
B88F: A2 61     LDX #$61
B891: D0 04     BNE $B897

Jump from $B87F:

B893: A0 00     LDY #$00
B895: 84 70     STY $70       ; FAC low-order rounding

Jump from $B891:

B897: C9 F9     CMP #$F9
B899: 30 C7     BMI $B862     ; Normalise Addition
B89B: A8        TAY
B89C: A5 70     LDA $70       ; FAC low-order rounding
B89E: 56 01     LSR $01,X     ; 6510 On-chip 8-bit Input/Output Register
B8A0: 20 B0 B9  JSR $B9B0     ; Multiply by Zero Byte

Jump from $B87D, $B865:

B8A3: 24 6F     BIT $6F       ; Sign of result of Arithmetic Evaluation
B8A5: 10 57     BPL $B8FE
B8A7: A0 61     LDY #$61
B8A9: E0 69     CPX #$69
B8AB: F0 02     BEQ $B8AF
B8AD: A0 69     LDY #$69

Jump from $B8AB:

B8AF: 38        SEC
B8B0: 49 FF     EOR #$FF
B8B2: 65 56     ADC $56       ; Jump Vector used in Function Evaluation
B8B4: 85 70     STA $70       ; FAC low-order rounding
B8B6: B9 04 00  LDA $0004,Y   ; Jump Vector: Convert FAC to Integer
B8B9: F5 04     SBC $04,X     ; Jump Vector: Convert FAC to Integer
B8BB: 85 65     STA $65       ; FAC Mantissa
B8BD: B9 03 00  LDA $0003,Y   ; Jump Vector: Convert FAC to Integer
B8C0: F5 03     SBC $03,X     ; Jump Vector: Convert FAC to Integer
B8C2: 85 64     STA $64       ; FAC Mantissa
B8C4: B9 02 00  LDA $0002,Y   ; Unused
B8C7: F5 02     SBC $02,X     ; Unused
B8C9: 85 63     STA $63       ; FAC Mantissa
B8CB: B9 01 00  LDA $0001,Y   ; 6510 On-chip 8-bit Input/Output Register
B8CE: F5 01     SBC $01,X     ; 6510 On-chip 8-bit Input/Output Register
B8D0: 85 62     STA $62       ; FAC Mantissa

Jump from $BC55, $BCE6:

B8D2: B0 03     BCS $B8D7
B8D4: 20 47 B9  JSR $B947     ; 2's Complement FAC#1

Jump from $B8D2, $BB9F, $E0EF:

B8D7: A0 00     LDY #$00
B8D9: 98        TYA
B8DA: 18        CLC

Jump from $B8F5:

B8DB: A6 62     LDX $62       ; FAC Mantissa
B8DD: D0 4A     BNE $B929
B8DF: A6 63     LDX $63       ; FAC Mantissa
B8E1: 86 62     STX $62       ; FAC Mantissa
B8E3: A6 64     LDX $64       ; FAC Mantissa
B8E5: 86 63     STX $63       ; FAC Mantissa
B8E7: A6 65     LDX $65       ; FAC Mantissa
B8E9: 86 64     STX $64       ; FAC Mantissa
B8EB: A6 70     LDX $70       ; FAC low-order rounding
B8ED: 86 65     STX $65       ; FAC Mantissa
B8EF: 84 70     STY $70       ; FAC low-order rounding
B8F1: 69 08     ADC #$08
B8F3: C9 20     CMP #$20
B8F5: D0 E4     BNE $B8DB

Jump from $B92E, $B7B2, $BADC:

B8F7: A9 00     LDA #$00

Jump from $BF81:

B8F9: 85 61     STA $61       ; FAC Exponent

Jump from $BACC:

B8FB: 85 66     STA $66       ; FAC Sign
B8FD: 60        RTS

Jump from $B8A5:

B8FE: 65 56     ADC $56       ; Jump Vector used in Function Evaluation
B900: 85 70     STA $70       ; FAC low-order rounding
B902: A5 65     LDA $65       ; FAC Mantissa
B904: 65 6D     ADC $6D       ; AFAC Mantissa
B906: 85 65     STA $65       ; FAC Mantissa
B908: A5 64     LDA $64       ; FAC Mantissa
B90A: 65 6C     ADC $6C       ; AFAC Mantissa
B90C: 85 64     STA $64       ; FAC Mantissa
B90E: A5 63     LDA $63       ; FAC Mantissa
B910: 65 6B     ADC $6B       ; AFAC Mantissa
B912: 85 63     STA $63       ; FAC Mantissa
B914: A5 62     LDA $62       ; FAC Mantissa
B916: 65 6A     ADC $6A       ; AFAC Mantissa
B918: 85 62     STA $62       ; FAC Mantissa
B91A: 4C 36 B9  JMP $B936

Jump from $B929:

B91D: 69 01     ADC #$01
B91F: 06 70     ASL $70       ; FAC low-order rounding
B921: 26 65     ROL $65       ; FAC Mantissa
B923: 26 64     ROL $64       ; FAC Mantissa
B925: 26 63     ROL $63       ; FAC Mantissa
B927: 26 62     ROL $62       ; FAC Mantissa

Jump from $B8DD:

B929: 10 F2     BPL $B91D
B92B: 38        SEC
B92C: E5 61     SBC $61       ; FAC Exponent
B92E: B0 C7     BCS $B8F7
B930: 49 FF     EOR #$FF
B932: 69 01     ADC #$01
B934: 85 61     STA $61       ; FAC Exponent

Jump from $B91A:

B936: 90 0E     BCC $B946

Jump from $BC28:

B938: E6 61     INC $61       ; FAC Exponent
B93A: F0 42     BEQ $B97E     ; Output ?OVERFLOW Error
B93C: 66 62     ROR $62       ; FAC Mantissa
B93E: 66 63     ROR $63       ; FAC Mantissa
B940: 66 64     ROR $64       ; FAC Mantissa
B942: 66 65     ROR $65       ; FAC Mantissa
B944: 66 70     ROR $70       ; FAC low-order rounding

Jump from $B936:

B946: 60        RTS



 $B947/47431:   2's Complement FAC#1

Jump from $B8D4:

B947: A5 66     LDA $66       ; FAC Sign
B949: 49 FF     EOR #$FF
B94B: 85 66     STA $66       ; FAC Sign

Jump from $BCAB:

B94D: A5 62     LDA $62       ; FAC Mantissa
B94F: 49 FF     EOR #$FF
B951: 85 62     STA $62       ; FAC Mantissa
B953: A5 63     LDA $63       ; FAC Mantissa
B955: 49 FF     EOR #$FF
B957: 85 63     STA $63       ; FAC Mantissa
B959: A5 64     LDA $64       ; FAC Mantissa
B95B: 49 FF     EOR #$FF
B95D: 85 64     STA $64       ; FAC Mantissa
B95F: A5 65     LDA $65       ; FAC Mantissa
B961: 49 FF     EOR #$FF
B963: 85 65     STA $65       ; FAC Mantissa
B965: A5 70     LDA $70       ; FAC low-order rounding
B967: 49 FF     EOR #$FF
B969: 85 70     STA $70       ; FAC low-order rounding
B96B: E6 70     INC $70       ; FAC low-order rounding
B96D: D0 0E     BNE $B97D

Jump from $BC23:

B96F: E6 65     INC $65       ; FAC Mantissa
B971: D0 0A     BNE $B97D
B973: E6 64     INC $64       ; FAC Mantissa
B975: D0 06     BNE $B97D
B977: E6 63     INC $63       ; FAC Mantissa
B979: D0 02     BNE $B97D
B97B: E6 62     INC $62       ; FAC Mantissa

Jump from $B96D, $B971, $B975, $B979:

B97D: 60        RTS



 $B97E/47486:   Output ?OVERFLOW Error

Jump from $B93A, $BADF, $BD9D:

B97E: A2 0F     LDX #$0F
B980: 4C 37 A4  JMP $A437     ; Error Routine



 $B983/47491:   Multiply by Zero Byte

Jump from $BA5B:

B983: A2 25     LDX #$25

Jump from $B99B, $B99D:

B985: B4 04     LDY $04,X     ; Jump Vector: Convert FAC to Integer
B987: 84 70     STY $70       ; FAC low-order rounding
B989: B4 03     LDY $03,X     ; Jump Vector: Convert FAC to Integer
B98B: 94 04     STY $04,X     ; Jump Vector: Convert FAC to Integer
B98D: B4 02     LDY $02,X     ; Unused
B98F: 94 03     STY $03,X     ; Jump Vector: Convert FAC to Integer
B991: B4 01     LDY $01,X     ; 6510 On-chip 8-bit Input/Output Register
B993: 94 02     STY $02,X     ; Unused
B995: A4 68     LDY $68       ; Bit Overflow Area during normalisation Routine
B997: 94 01     STY $01,X     ; 6510 On-chip 8-bit Input/Output Register

Jump from $B862, $BCB5:

B999: 69 08     ADC #$08
B99B: 30 E8     BMI $B985
B99D: F0 E6     BEQ $B985
B99F: E9 08     SBC #$08
B9A1: A8        TAY
B9A2: A5 70     LDA $70       ; FAC low-order rounding
B9A4: B0 14     BCS $B9BA

Jump from $B9B8:

B9A6: 16 01     ASL $01,X     ; 6510 On-chip 8-bit Input/Output Register
B9A8: 90 02     BCC $B9AC
B9AA: F6 01     INC $01,X     ; 6510 On-chip 8-bit Input/Output Register

Jump from $B9A8:

B9AC: 76 01     ROR $01,X     ; 6510 On-chip 8-bit Input/Output Register
B9AE: 76 01     ROR $01,X     ; 6510 On-chip 8-bit Input/Output Register

Jump from $B8A0, $BCC6:

B9B0: 76 02     ROR $02,X     ; Unused
B9B2: 76 03     ROR $03,X     ; Jump Vector: Convert FAC to Integer
B9B4: 76 04     ROR $04,X     ; Jump Vector: Convert FAC to Integer
B9B6: 6A        ROR
B9B7: C8        INY
B9B8: D0 EC     BNE $B9A6

Jump from $B9A4:

B9BA: 18        CLC
B9BB: 60        RTS



 $B9BC/47548:   Table of Flpt Constants  1.00

B9BC: 81 00 00 00 00



 $B9C1/47553:   Table of Flpt Constants  #03

B9C1: 03



 $B9C2/47554:   Table of Flpt Constants  0.434255942

B9C2: 7F 5E 56 CB 79



 $B9C7/47559:   Table of Flpt Constants  0.57658454

B9C7: 80 13 9B 0B 64



 $B9CC/47564:   Table of Flpt Constants  0.961800759

B9CC: 80 76 38 93 16



 $B9D1/47569:   Table of Flpt Constants  2.885390073

B9D1: 82 38 AA 3B 20



 $B9D6/47574:   Table of Flpt Constants  0.707106781

B9D6: 80 35 04 F3 34



 $B9DB/47579:   Table of Flpt Constants  1.41421356

B9DB: 81 35 04 F3 34



 $B9E0/47584:   Table of Flpt Constants  -0.5

B9E0: 80 80 00 00 00



 $B9E5/47589:   Table of Flpt Constants  0.693147181

B9E5: 80 31 72 17 F8



 $B9EA/47594:   Evaluate <log>

Jump from $BFA3:

B9EA: 20 2B BC  JSR $BC2B     ; Check Sign of FAC#1
B9ED: F0 02     BEQ $B9F1
B9EF: 10 03     BPL $B9F4

Jump from $B9ED:

B9F1: 4C 48 B2  JMP $B248     ; ?ILLEGAL QUANTITY

Jump from $B9EF:

B9F4: A5 61     LDA $61       ; FAC Exponent
B9F6: E9 7F     SBC #$7F
B9F8: 48        PHA
B9F9: A9 80     LDA #$80
B9FB: 85 61     STA $61       ; FAC Exponent
B9FD: A9 D6     LDA #$D6
B9FF: A0 B9     LDY #$B9
BA01: 20 67 B8  JSR $B867     ; Perform Addition
BA04: A9 DB     LDA #$DB
BA06: A0 B9     LDY #$B9
BA08: 20 0F BB  JSR $BB0F     ; Divide FAC#2 by FAC#1
BA0B: A9 BC     LDA #$BC
BA0D: A0 B9     LDY #$B9
BA0F: 20 50 B8  JSR $B850     ; Perform Subtraction
BA12: A9 C1     LDA #$C1
BA14: A0 B9     LDY #$B9
BA16: 20 43 E0  JSR $E043     ; Series Evaluation
BA19: A9 E0     LDA #$E0
BA1B: A0 B9     LDY #$B9
BA1D: 20 67 B8  JSR $B867     ; Perform Addition
BA20: 68        PLA
BA21: 20 7E BD  JSR $BD7E     ; Convert ASCII String to a Number in FAC
BA24: A9 E5     LDA #$E5
BA26: A0 B9     LDY #$B9



 $BA28/47656:   Perform Multiply

Jump from $BE04, $BFAA, $BFF1, $E04C, $E056, $E070, $E0C9:

BA28: 20 8C BA  JSR $BA8C     ; Load FAC#2 From Memory
BA2B: D0 03     BNE $BA30
BA2D: 4C 8B BA  JMP $BA8B     ; Multiply by a Byte

Jump from $BA2B:

BA30: 20 B7 BA  JSR $BAB7     ; Test Both Accumulators
BA33: A9 00     LDA #$00
BA35: 85 26     STA $26       ; Floating point product of Multiply and Divide
BA37: 85 27     STA $27       ; Floating point product of Multiply and Divide
BA39: 85 28     STA $28       ; Floating point product of Multiply and Divide
BA3B: 85 29     STA $29       ; Floating point product of Multiply and Divide
BA3D: A5 70     LDA $70       ; FAC low-order rounding
BA3F: 20 59 BA  JSR $BA59     ; Multiply by a Byte
BA42: A5 65     LDA $65       ; FAC Mantissa
BA44: 20 59 BA  JSR $BA59     ; Multiply by a Byte
BA47: A5 64     LDA $64       ; FAC Mantissa
BA49: 20 59 BA  JSR $BA59     ; Multiply by a Byte
BA4C: A5 63     LDA $63       ; FAC Mantissa
BA4E: 20 59 BA  JSR $BA59     ; Multiply by a Byte
BA51: A5 62     LDA $62       ; FAC Mantissa
BA53: 20 5E BA  JSR $BA5E     ; Multiply by a Byte
BA56: 4C 8F BB  JMP $BB8F     ; Divide FAC#2 by FAC#1



 $BA59/47705:   Multiply by a Byte

Jump from $BA3F, $BA44, $BA49, $BA4E:

BA59: D0 03     BNE $BA5E
BA5B: 4C 83 B9  JMP $B983     ; Multiply by Zero Byte

Jump from $BA59, $BA53:

BA5E: 4A        LSR
BA5F: 09 80     ORA #$80

Jump from $BA89:

BA61: A8        TAY
BA62: 90 19     BCC $BA7D
BA64: 18        CLC
BA65: A5 29     LDA $29       ; Floating point product of Multiply and Divide
BA67: 65 6D     ADC $6D       ; AFAC Mantissa
BA69: 85 29     STA $29       ; Floating point product of Multiply and Divide
BA6B: A5 28     LDA $28       ; Floating point product of Multiply and Divide
BA6D: 65 6C     ADC $6C       ; AFAC Mantissa
BA6F: 85 28     STA $28       ; Floating point product of Multiply and Divide
BA71: A5 27     LDA $27       ; Floating point product of Multiply and Divide
BA73: 65 6B     ADC $6B       ; AFAC Mantissa
BA75: 85 27     STA $27       ; Floating point product of Multiply and Divide
BA77: A5 26     LDA $26       ; Floating point product of Multiply and Divide
BA79: 65 6A     ADC $6A       ; AFAC Mantissa
BA7B: 85 26     STA $26       ; Floating point product of Multiply and Divide

Jump from $BA62:

BA7D: 66 26     ROR $26       ; Floating point product of Multiply and Divide
BA7F: 66 27     ROR $27       ; Floating point product of Multiply and Divide
BA81: 66 28     ROR $28       ; Floating point product of Multiply and Divide
BA83: 66 29     ROR $29       ; Floating point product of Multiply and Divide
BA85: 66 70     ROR $70       ; FAC low-order rounding
BA87: 98        TYA
BA88: 4A        LSR
BA89: D0 D6     BNE $BA61

Jump from $BA2D:

BA8B: 60        RTS



 $BA8C/47756:   Load FAC#2 From Memory

Jump from $B850, $B867, $BA28, $BB0F:

BA8C: 85 22     STA $22       ; Second Utility Pointer
BA8E: 84 23     STY $23       ; Second Utility Pointer
BA90: A0 04     LDY #$04
BA92: B1 22     LDA ($22),Y   ; Second Utility Pointer
BA94: 85 6D     STA $6D       ; AFAC Mantissa
BA96: 88        DEY
BA97: B1 22     LDA ($22),Y   ; Second Utility Pointer
BA99: 85 6C     STA $6C       ; AFAC Mantissa
BA9B: 88        DEY
BA9C: B1 22     LDA ($22),Y   ; Second Utility Pointer
BA9E: 85 6B     STA $6B       ; AFAC Mantissa
BAA0: 88        DEY
BAA1: B1 22     LDA ($22),Y   ; Second Utility Pointer
BAA3: 85 6E     STA $6E       ; AFAC Sign
BAA5: 45 66     EOR $66       ; FAC Sign
BAA7: 85 6F     STA $6F       ; Sign of result of Arithmetic Evaluation
BAA9: A5 6E     LDA $6E       ; AFAC Sign
BAAB: 09 80     ORA #$80
BAAD: 85 6A     STA $6A       ; AFAC Mantissa
BAAF: 88        DEY
BAB0: B1 22     LDA ($22),Y   ; Second Utility Pointer
BAB2: 85 69     STA $69       ; AFAC Exponent
BAB4: A5 61     LDA $61       ; FAC Exponent
BAB6: 60        RTS



 $BAB7/47799:   Test Both Accumulators

Jump from $BA30, $BB1E:

BAB7: A5 69     LDA $69       ; AFAC Exponent

Jump from $E03F:

BAB9: F0 1F     BEQ $BADA     ; Overflow / Underflow
BABB: 18        CLC
BABC: 65 61     ADC $61       ; FAC Exponent
BABE: 90 04     BCC $BAC4
BAC0: 30 1D     BMI $BADF     ; Overflow / Underflow
BAC2: 18        CLC
BAC3: 2C        .BYTE $2C

Jump from $BABE:

BAC4: 10 14     BPL $BADA     ; Overflow / Underflow
BAC6: 69 80     ADC #$80
BAC8: 85 61     STA $61       ; FAC Exponent
BACA: D0 03     BNE $BACF
BACC: 4C FB B8  JMP $B8FB     ; Perform Addition

Jump from $BACA:

BACF: A5 6F     LDA $6F       ; Sign of result of Arithmetic Evaluation
BAD1: 85 66     STA $66       ; FAC Sign
BAD3: 60        RTS



 $BAD4/47828:   Overflow / Underflow

Jump from $E00B:

BAD4: A5 66     LDA $66       ; FAC Sign
BAD6: 49 FF     EOR #$FF
BAD8: 30 05     BMI $BADF

Jump from $BAB9, $BAC4:

BADA: 68        PLA
BADB: 68        PLA
BADC: 4C F7 B8  JMP $B8F7     ; Perform Addition

Jump from $BAD8, $BAC0, $BAEB, $BAF6, $BB23:

BADF: 4C 7E B9  JMP $B97E     ; Output ?OVERFLOW Error



 $BAE2/47842:   Multiply FAC#1 by 10

Jump from $A9F2, $AA0E, $BD5B, $BD71, $BE21:

BAE2: 20 0C BC  JSR $BC0C     ; Copy FAC#1 into FAC#2
BAE5: AA        TAX
BAE6: F0 10     BEQ $BAF8
BAE8: 18        CLC
BAE9: 69 02     ADC #$02
BAEB: B0 F2     BCS $BADF     ; Overflow / Underflow

Jump from $AA04:

BAED: A2 00     LDX #$00
BAEF: 86 6F     STX $6F       ; Sign of result of Arithmetic Evaluation
BAF1: 20 77 B8  JSR $B877     ; Perform Addition
BAF4: E6 61     INC $61       ; FAC Exponent
BAF6: F0 E7     BEQ $BADF     ; Overflow / Underflow

Jump from $BAE6:

BAF8: 60        RTS



 $BAF9/47865:   Constant 10 in Flpt

BAF9: 84 20 00 00 00



 $BAFE/47870:   Divide FAC#1 by 10

Jump from $BD52, $BE28:

BAFE: 20 0C BC  JSR $BC0C     ; Copy FAC#1 into FAC#2
BB01: A9 F9     LDA #$F9
BB03: A0 BA     LDY #$BA
BB05: A2 00     LDX #$00



 $BB07/47879:   Divide FAC#2 by Flpt at (AC/YR)

Jump from $E274:

BB07: 86 6F     STX $6F       ; Sign of result of Arithmetic Evaluation
BB09: 20 A2 BB  JSR $BBA2     ; Load FAC#1 From Memory
BB0C: 4C 12 BB  JMP $BB12     ; Divide FAC#2 by FAC#1



 $BB0F/47887:   Divide FAC#2 by FAC#1

Jump from $BA08, $E2D9, $E321:

BB0F: 20 8C BA  JSR $BA8C     ; Load FAC#2 From Memory

Jump from $BB0C:

BB12: F0 76     BEQ $BB8A
BB14: 20 1B BC  JSR $BC1B     ; Round FAC#1
BB17: A9 00     LDA #$00
BB19: 38        SEC
BB1A: E5 61     SBC $61       ; FAC Exponent
BB1C: 85 61     STA $61       ; FAC Exponent
BB1E: 20 B7 BA  JSR $BAB7     ; Test Both Accumulators
BB21: E6 61     INC $61       ; FAC Exponent
BB23: F0 BA     BEQ $BADF     ; Overflow / Underflow
BB25: A2 FC     LDX #$FC
BB27: A9 01     LDA #$01

Jump from $BB59:

BB29: A4 6A     LDY $6A       ; AFAC Mantissa
BB2B: C4 62     CPY $62       ; FAC Mantissa
BB2D: D0 10     BNE $BB3F
BB2F: A4 6B     LDY $6B       ; AFAC Mantissa
BB31: C4 63     CPY $63       ; FAC Mantissa
BB33: D0 0A     BNE $BB3F
BB35: A4 6C     LDY $6C       ; AFAC Mantissa
BB37: C4 64     CPY $64       ; FAC Mantissa
BB39: D0 04     BNE $BB3F
BB3B: A4 6D     LDY $6D       ; AFAC Mantissa
BB3D: C4 65     CPY $65       ; FAC Mantissa

Jump from $BB2D, $BB33, $BB39, $BB57, $BB5B:

BB3F: 08        PHP
BB40: 2A        ROL
BB41: 90 09     BCC $BB4C
BB43: E8        INX
BB44: 95 29     STA $29,X     ; Floating point product of Multiply and Divide
BB46: F0 32     BEQ $BB7A
BB48: 10 34     BPL $BB7E
BB4A: A9 01     LDA #$01

Jump from $BB41, $BB7C:

BB4C: 28        PLP
BB4D: B0 0E     BCS $BB5D

Jump from $BB77:

BB4F: 06 6D     ASL $6D       ; AFAC Mantissa
BB51: 26 6C     ROL $6C       ; AFAC Mantissa
BB53: 26 6B     ROL $6B       ; AFAC Mantissa
BB55: 26 6A     ROL $6A       ; AFAC Mantissa
BB57: B0 E6     BCS $BB3F
BB59: 30 CE     BMI $BB29
BB5B: 10 E2     BPL $BB3F

Jump from $BB4D:

BB5D: A8        TAY
BB5E: A5 6D     LDA $6D       ; AFAC Mantissa
BB60: E5 65     SBC $65       ; FAC Mantissa
BB62: 85 6D     STA $6D       ; AFAC Mantissa
BB64: A5 6C     LDA $6C       ; AFAC Mantissa
BB66: E5 64     SBC $64       ; FAC Mantissa
BB68: 85 6C     STA $6C       ; AFAC Mantissa
BB6A: A5 6B     LDA $6B       ; AFAC Mantissa
BB6C: E5 63     SBC $63       ; FAC Mantissa
BB6E: 85 6B     STA $6B       ; AFAC Mantissa
BB70: A5 6A     LDA $6A       ; AFAC Mantissa
BB72: E5 62     SBC $62       ; FAC Mantissa
BB74: 85 6A     STA $6A       ; AFAC Mantissa
BB76: 98        TYA
BB77: 4C 4F BB  JMP $BB4F

Jump from $BB46:

BB7A: A9 40     LDA #$40
BB7C: D0 CE     BNE $BB4C

Jump from $BB48:

BB7E: 0A        ASL
BB7F: 0A        ASL
BB80: 0A        ASL
BB81: 0A        ASL
BB82: 0A        ASL
BB83: 0A        ASL
BB84: 85 70     STA $70       ; FAC low-order rounding
BB86: 28        PLP
BB87: 4C 8F BB  JMP $BB8F

Jump from $BB12:

BB8A: A2 14     LDX #$14
BB8C: 4C 37 A4  JMP $A437     ; Error Routine

Jump from $BB87, $BA56:

BB8F: A5 26     LDA $26       ; Floating point product of Multiply and Divide
BB91: 85 62     STA $62       ; FAC Mantissa
BB93: A5 27     LDA $27       ; Floating point product of Multiply and Divide
BB95: 85 63     STA $63       ; FAC Mantissa
BB97: A5 28     LDA $28       ; Floating point product of Multiply and Divide
BB99: 85 64     STA $64       ; FAC Mantissa
BB9B: A5 29     LDA $29       ; Floating point product of Multiply and Divide
BB9D: 85 65     STA $65       ; FAC Mantissa
BB9F: 4C D7 B8  JMP $B8D7     ; Perform Addition



 $BBA2/48034:   Load FAC#1 From Memory

Jump from $A78F, $AD42, $AEA2, $AFA4, $BB09, $BF78, $E0C2, $E2C9:

BBA2: 85 22     STA $22       ; Second Utility Pointer
BBA4: 84 23     STY $23       ; Second Utility Pointer
BBA6: A0 04     LDY #$04
BBA8: B1 22     LDA ($22),Y   ; Second Utility Pointer
BBAA: 85 65     STA $65       ; FAC Mantissa
BBAC: 88        DEY
BBAD: B1 22     LDA ($22),Y   ; Second Utility Pointer
BBAF: 85 64     STA $64       ; FAC Mantissa
BBB1: 88        DEY
BBB2: B1 22     LDA ($22),Y   ; Second Utility Pointer
BBB4: 85 63     STA $63       ; FAC Mantissa
BBB6: 88        DEY
BBB7: B1 22     LDA ($22),Y   ; Second Utility Pointer
BBB9: 85 66     STA $66       ; FAC Sign
BBBB: 09 80     ORA #$80
BBBD: 85 62     STA $62       ; FAC Mantissa
BBBF: 88        DEY
BBC0: B1 22     LDA ($22),Y   ; Second Utility Pointer
BBC2: 85 61     STA $61       ; FAC Exponent
BBC4: 84 70     STY $70       ; FAC low-order rounding
BBC6: 60        RTS



 $BBC7/48071:   Store FAC#1 in Memory

Jump from $E05D:

BBC7: A2 5C     LDX #$5C
BBC9: 2C        .BYTE $2C

Jump from $E047, $E2B4:

BBCA: A2 57     LDX #$57
BBCC: A0 00     LDY #$00
BBCE: F0 04     BEQ $BBD4

Jump from $A9D6, $AD52:

BBD0: A6 49     LDX $49       ; Pointer: Index Variable for FOR/NEXT loop
BBD2: A4 4A     LDY $4A       ; Pointer: Index Variable for FOR/NEXT loop

Jump from $BBCE, $B420, $BF88, $E0F6:

BBD4: 20 1B BC  JSR $BC1B     ; Round FAC#1
BBD7: 86 22     STX $22       ; Second Utility Pointer
BBD9: 84 23     STY $23       ; Second Utility Pointer
BBDB: A0 04     LDY #$04
BBDD: A5 65     LDA $65       ; FAC Mantissa
BBDF: 91 22     STA ($22),Y   ; Second Utility Pointer
BBE1: 88        DEY
BBE2: A5 64     LDA $64       ; FAC Mantissa
BBE4: 91 22     STA ($22),Y   ; Second Utility Pointer
BBE6: 88        DEY
BBE7: A5 63     LDA $63       ; FAC Mantissa
BBE9: 91 22     STA ($22),Y   ; Second Utility Pointer
BBEB: 88        DEY
BBEC: A5 66     LDA $66       ; FAC Sign
BBEE: 09 7F     ORA #$7F
BBF0: 25 62     AND $62       ; FAC Mantissa
BBF2: 91 22     STA ($22),Y   ; Second Utility Pointer
BBF4: 88        DEY
BBF5: A5 61     LDA $61       ; FAC Exponent
BBF7: 91 22     STA ($22),Y   ; Second Utility Pointer
BBF9: 84 70     STY $70       ; FAC low-order rounding
BBFB: 60        RTS



 $BBFC/48124:   Copy FAC#2 into FAC#1

Jump from $AFFC, $B86C:

BBFC: A5 6E     LDA $6E       ; AFAC Sign

Jump from $BF9E:

BBFE: 85 66     STA $66       ; FAC Sign
BC00: A2 05     LDX #$05

Jump from $BC07:

BC02: B5 68     LDA $68,X     ; Bit Overflow Area during normalisation Routine
BC04: 95 60     STA $60,X     ; Temporary storage for FLPT value
BC06: CA        DEX
BC07: D0 F9     BNE $BC02
BC09: 86 70     STX $70       ; FAC low-order rounding
BC0B: 60        RTS



 $BC0C/48140:   Copy FAC#1 into FAC#2

Jump from $A9FC, $BAE2, $BAFE, $BD7F, $BF71, $E26B, $E277:

BC0C: 20 1B BC  JSR $BC1B     ; Round FAC#1

Jump from $E002:

BC0F: A2 06     LDX #$06

Jump from $BC16:

BC11: B5 60     LDA $60,X     ; Temporary storage for FLPT value
BC13: 95 68     STA $68,X     ; Bit Overflow Area during normalisation Routine
BC15: CA        DEX
BC16: D0 F9     BNE $BC11
BC18: 86 70     STX $70       ; FAC low-order rounding

Jump from $BC1D, $BC21, $BC26:

BC1A: 60        RTS



 $BC1B/48155:   Round FAC#1

Jump from $A9C4, $AE43, $BB14, $BBD4, $BC0C:

BC1B: A5 61     LDA $61       ; FAC Exponent
BC1D: F0 FB     BEQ $BC1A     ; Copy FAC#1 into FAC#2
BC1F: 06 70     ASL $70       ; FAC low-order rounding
BC21: 90 F7     BCC $BC1A     ; Copy FAC#1 into FAC#2

Jump from $BFFA:

BC23: 20 6F B9  JSR $B96F     ; 2's Complement FAC#1
BC26: D0 F2     BNE $BC1A     ; Copy FAC#1 into FAC#2
BC28: 4C 38 B9  JMP $B938     ; Perform Addition



 $BC2B/48171:   Check Sign of FAC#1

Jump from $A79F, $B9EA, $BC39, $BC65, $E097:

BC2B: A5 61     LDA $61       ; FAC Exponent
BC2D: F0 09     BEQ $BC38

Jump from $BC6B:

BC2F: A5 66     LDA $66       ; FAC Sign

Jump from $BC98:

BC31: 2A        ROL
BC32: A9 FF     LDA #$FF
BC34: B0 02     BCS $BC38
BC36: A9 01     LDA #$01

Jump from $BC2D, $BC34:

BC38: 60        RTS



 $BC39/48185:   Evaluate <sgn>

BC39: 20 2B BC  JSR $BC2B     ; Check Sign of FAC#1

Jump from $AF9D, $B07B, $BD83:

BC3C: 85 62     STA $62       ; FAC Mantissa
BC3E: A9 00     LDA #$00
BC40: 85 63     STA $63       ; FAC Mantissa
BC42: A2 88     LDX #$88

Jump from $B39B:

BC44: A5 62     LDA $62       ; FAC Mantissa
BC46: 49 FF     EOR #$FF
BC48: 2A        ROL

Jump from $BDD4:

BC49: A9 00     LDA #$00
BC4B: 85 65     STA $65       ; FAC Mantissa
BC4D: 85 64     STA $64       ; FAC Mantissa

Jump from $AF81:

BC4F: 86 61     STX $61       ; FAC Exponent
BC51: 85 70     STA $70       ; FAC low-order rounding
BC53: 85 66     STA $66       ; FAC Sign
BC55: 4C D2 B8  JMP $B8D2     ; Perform Addition



 $BC58/48216:   Evaluate <abs>

BC58: 46 66     LSR $66       ; FAC Sign
BC5A: 60        RTS



 $BC5B/48219:   Compare FAC#1 With Memory

Jump from $B027, $B1C9, $BE0F, $BE1A, $BF96:

BC5B: 85 24     STA $24       ; Second Utility Pointer

Jump from $AD57:

BC5D: 84 25     STY $25       ; Second Utility Pointer
BC5F: A0 00     LDY #$00
BC61: B1 24     LDA ($24),Y   ; Second Utility Pointer
BC63: C8        INY
BC64: AA        TAX
BC65: F0 C4     BEQ $BC2B     ; Check Sign of FAC#1
BC67: B1 24     LDA ($24),Y   ; Second Utility Pointer
BC69: 45 66     EOR $66       ; FAC Sign
BC6B: 30 C2     BMI $BC2F     ; Check Sign of FAC#1
BC6D: E4 61     CPX $61       ; FAC Exponent
BC6F: D0 21     BNE $BC92
BC71: B1 24     LDA ($24),Y   ; Second Utility Pointer
BC73: 09 80     ORA #$80
BC75: C5 62     CMP $62       ; FAC Mantissa
BC77: D0 19     BNE $BC92
BC79: C8        INY
BC7A: B1 24     LDA ($24),Y   ; Second Utility Pointer
BC7C: C5 63     CMP $63       ; FAC Mantissa
BC7E: D0 12     BNE $BC92
BC80: C8        INY
BC81: B1 24     LDA ($24),Y   ; Second Utility Pointer
BC83: C5 64     CMP $64       ; FAC Mantissa
BC85: D0 0B     BNE $BC92
BC87: C8        INY
BC88: A9 7F     LDA #$7F
BC8A: C5 70     CMP $70       ; FAC low-order rounding
BC8C: B1 24     LDA ($24),Y   ; Second Utility Pointer
BC8E: E5 65     SBC $65       ; FAC Mantissa
BC90: F0 28     BEQ $BCBA     ; Convert FAC#1 to Integer

Jump from $BC6F, $BC77, $BC7E, $BC85:

BC92: A5 66     LDA $66       ; FAC Sign
BC94: 90 02     BCC $BC98
BC96: 49 FF     EOR #$FF

Jump from $BC94:

BC98: 4C 31 BC  JMP $BC31     ; Check Sign of FAC#1



 $BC9B/48283:   Convert FAC#1 to Integer

Jump from $AA11, $B1CE, $B801, $BCD2, $BE32:

BC9B: A5 61     LDA $61       ; FAC Exponent
BC9D: F0 4A     BEQ $BCE9     ; Evaluate <int>
BC9F: 38        SEC
BCA0: E9 A0     SBC #$A0
BCA2: 24 66     BIT $66       ; FAC Sign
BCA4: 10 09     BPL $BCAF
BCA6: AA        TAX
BCA7: A9 FF     LDA #$FF
BCA9: 85 68     STA $68       ; Bit Overflow Area during normalisation Routine
BCAB: 20 4D B9  JSR $B94D     ; 2's Complement FAC#1
BCAE: 8A        TXA

Jump from $BCA4:

BCAF: A2 61     LDX #$61
BCB1: C9 F9     CMP #$F9
BCB3: 10 06     BPL $BCBB
BCB5: 20 99 B9  JSR $B999     ; Multiply by Zero Byte
BCB8: 84 68     STY $68       ; Bit Overflow Area during normalisation Routine

Jump from $BC90:

BCBA: 60        RTS

Jump from $BCB3:

BCBB: A8        TAY
BCBC: A5 66     LDA $66       ; FAC Sign
BCBE: 29 80     AND #$80
BCC0: 46 62     LSR $62       ; FAC Mantissa
BCC2: 05 62     ORA $62       ; FAC Mantissa
BCC4: 85 62     STA $62       ; FAC Mantissa
BCC6: 20 B0 B9  JSR $B9B0     ; Multiply by Zero Byte
BCC9: 84 68     STY $68       ; Bit Overflow Area during normalisation Routine
BCCB: 60        RTS



 $BCCC/48332:   Evaluate <int>

Jump from $BF8F, $E00E, $E27A:

BCCC: A5 61     LDA $61       ; FAC Exponent
BCCE: C9 A0     CMP #$A0
BCD0: B0 20     BCS $BCF2
BCD2: 20 9B BC  JSR $BC9B     ; Convert FAC#1 to Integer
BCD5: 84 70     STY $70       ; FAC low-order rounding
BCD7: A5 66     LDA $66       ; FAC Sign
BCD9: 84 66     STY $66       ; FAC Sign
BCDB: 49 80     EOR #$80
BCDD: 2A        ROL
BCDE: A9 A0     LDA #$A0
BCE0: 85 61     STA $61       ; FAC Exponent
BCE2: A5 65     LDA $65       ; FAC Mantissa
BCE4: 85 07     STA $07       ; Temporary Integer during OR/AND
BCE6: 4C D2 B8  JMP $B8D2     ; Perform Addition

Jump from $BC9D:

BCE9: 85 62     STA $62       ; FAC Mantissa
BCEB: 85 63     STA $63       ; FAC Mantissa
BCED: 85 64     STA $64       ; FAC Mantissa
BCEF: 85 65     STA $65       ; FAC Mantissa
BCF1: A8        TAY

Jump from $BCD0:

BCF2: 60        RTS



 $BCF3/48371:   Convert ASCII String to a Number in FAC

Jump from $AC89, $AE8F, $B7DA:

BCF3: A0 00     LDY #$00
BCF5: A2 0A     LDX #$0A

Jump from $BCFA:

BCF7: 94 5D     STY $5D,X     ; Temporary storage for FLPT value
BCF9: CA        DEX
BCFA: 10 FB     BPL $BCF7
BCFC: 90 0F     BCC $BD0D
BCFE: C9 2D     CMP #$2D
BD00: D0 04     BNE $BD06
BD02: 86 67     STX $67       ; Pointer: Series Evaluation Constant
BD04: F0 04     BEQ $BD0A

Jump from $BD00:

BD06: C9 2B     CMP #$2B
BD08: D0 05     BNE $BD0F

Jump from $BD04, $BD45, $BD7B:

BD0A: 20 73 00  JSR $0073     ; CHRGET: Get next Byte of BASIC Text

Jump from $BCFC:

BD0D: 90 5B     BCC $BD6A

Jump from $BD08:

BD0F: C9 2E     CMP #$2E
BD11: F0 2E     BEQ $BD41
BD13: C9 45     CMP #$45
BD15: D0 30     BNE $BD47
BD17: 20 73 00  JSR $0073     ; CHRGET: Get next Byte of BASIC Text
BD1A: 90 17     BCC $BD33
BD1C: C9 AB     CMP #$AB
BD1E: F0 0E     BEQ $BD2E
BD20: C9 2D     CMP #$2D
BD22: F0 0A     BEQ $BD2E
BD24: C9 AA     CMP #$AA
BD26: F0 08     BEQ $BD30
BD28: C9 2B     CMP #$2B
BD2A: F0 04     BEQ $BD30
BD2C: D0 07     BNE $BD35

Jump from $BD1E, $BD22:

BD2E: 66 60     ROR $60       ; Temporary storage for FLPT value

Jump from $BD26, $BD2A, $BDB0:

BD30: 20 73 00  JSR $0073     ; CHRGET: Get next Byte of BASIC Text

Jump from $BD1A:

BD33: 90 5C     BCC $BD91

Jump from $BD2C:

BD35: 24 60     BIT $60       ; Temporary storage for FLPT value
BD37: 10 0E     BPL $BD47
BD39: A9 00     LDA #$00
BD3B: 38        SEC
BD3C: E5 5E     SBC $5E       ; Temporary storage for FLPT value
BD3E: 4C 49 BD  JMP $BD49

Jump from $BD11:

BD41: 66 5F     ROR $5F       ; Temporary storage for FLPT value
BD43: 24 5F     BIT $5F       ; Temporary storage for FLPT value
BD45: 50 C3     BVC $BD0A

Jump from $BD15, $BD37:

BD47: A5 5E     LDA $5E       ; Temporary storage for FLPT value

Jump from $BD3E:

BD49: 38        SEC
BD4A: E5 5D     SBC $5D       ; Temporary storage for FLPT value
BD4C: 85 5E     STA $5E       ; Temporary storage for FLPT value
BD4E: F0 12     BEQ $BD62
BD50: 10 09     BPL $BD5B

Jump from $BD57:

BD52: 20 FE BA  JSR $BAFE     ; Divide FAC#1 by 10
BD55: E6 5E     INC $5E       ; Temporary storage for FLPT value
BD57: D0 F9     BNE $BD52
BD59: F0 07     BEQ $BD62

Jump from $BD50, $BD60:

BD5B: 20 E2 BA  JSR $BAE2     ; Multiply FAC#1 by 10
BD5E: C6 5E     DEC $5E       ; Temporary storage for FLPT value
BD60: D0 F9     BNE $BD5B

Jump from $BD4E, $BD59:

BD62: A5 67     LDA $67       ; Pointer: Series Evaluation Constant
BD64: 30 01     BMI $BD67
BD66: 60        RTS

Jump from $BD64:

BD67: 4C B4 BF  JMP $BFB4     ; Negate FAC#1

Jump from $BD0D:

BD6A: 48        PHA
BD6B: 24 5F     BIT $5F       ; Temporary storage for FLPT value
BD6D: 10 02     BPL $BD71
BD6F: E6 5D     INC $5D       ; Temporary storage for FLPT value

Jump from $BD6D:

BD71: 20 E2 BA  JSR $BAE2     ; Multiply FAC#1 by 10
BD74: 68        PLA
BD75: 38        SEC
BD76: E9 30     SBC #$30
BD78: 20 7E BD  JSR $BD7E
BD7B: 4C 0A BD  JMP $BD0A

Jump from $BD78, $AA29, $BA21:

BD7E: 48        PHA
BD7F: 20 0C BC  JSR $BC0C     ; Copy FAC#1 into FAC#2
BD82: 68        PLA
BD83: 20 3C BC  JSR $BC3C     ; Evaluate <sgn>
BD86: A5 6E     LDA $6E       ; AFAC Sign
BD88: 45 66     EOR $66       ; FAC Sign
BD8A: 85 6F     STA $6F       ; Sign of result of Arithmetic Evaluation
BD8C: A6 61     LDX $61       ; FAC Exponent
BD8E: 4C 6A B8  JMP $B86A     ; Perform Addition

Jump from $BD33:

BD91: A5 5E     LDA $5E       ; Temporary storage for FLPT value
BD93: C9 0A     CMP #$0A
BD95: 90 09     BCC $BDA0
BD97: A9 64     LDA #$64
BD99: 24 60     BIT $60       ; Temporary storage for FLPT value
BD9B: 30 11     BMI $BDAE
BD9D: 4C 7E B9  JMP $B97E     ; Output ?OVERFLOW Error

Jump from $BD95:

BDA0: 0A        ASL
BDA1: 0A        ASL
BDA2: 18        CLC
BDA3: 65 5E     ADC $5E       ; Temporary storage for FLPT value
BDA5: 0A        ASL
BDA6: 18        CLC
BDA7: A0 00     LDY #$00
BDA9: 71 7A     ADC ($7A),Y   ; Pointer: Current Byte of BASIC Text
BDAB: 38        SEC
BDAC: E9 30     SBC #$30

Jump from $BD9B:

BDAE: 85 5E     STA $5E       ; Temporary storage for FLPT value
BDB0: 4C 30 BD  JMP $BD30



 $BDB3/48563:   String Conversion Constants    99999999

BDB3: 9B 3E BC 1F FD



 $BDB8/48568:   String Conversion Constants   999999999

BDB8: 9E 6E 6B 27 FD



 $BDBD/48573:   String Conversion Constants  1000000000

BDBD: 9E 6E 6B 28 00



 $BDC2/48578:   Output 'IN' and Line Number

Jump from $A471:

BDC2: A9 71     LDA #$71
BDC4: A0 A3     LDY #$A3
BDC6: 20 DA BD  JSR $BDDA     ; Output Positive Integer in A/X
BDC9: A5 3A     LDA $3A       ; Current BASIC Line number
BDCB: A6 39     LDX $39       ; Current BASIC Line number



 $BDCD/48589:   Output Positive Integer in A/X

Jump from $A6EA, $E43A:

BDCD: 85 62     STA $62       ; FAC Mantissa
BDCF: 86 63     STX $63       ; FAC Mantissa
BDD1: A2 90     LDX #$90
BDD3: 38        SEC
BDD4: 20 49 BC  JSR $BC49     ; Evaluate <sgn>
BDD7: 20 DF BD  JSR $BDDF     ; Convert FAC#1 to ASCII String

Jump from $BDC6:

BDDA: 4C 1E AB  JMP $AB1E     ; Output String



 $BDDD/48605:   Convert FAC#1 to ASCII String

Jump from $AABC:

BDDD: A0 01     LDY #$01

Jump from $B46A, $BDD7:

BDDF: A9 20     LDA #$20
BDE1: 24 66     BIT $66       ; FAC Sign
BDE3: 10 02     BPL $BDE7
BDE5: A9 2D     LDA #$2D

Jump from $BDE3:

BDE7: 99 FF 00  STA $00FF,Y   ; Assembly Area for Floating point to ASCII
BDEA: 85 66     STA $66       ; FAC Sign
BDEC: 84 71     STY $71       ; Pointer: Used during CRUNCH/ASCII conversion
BDEE: C8        INY
BDEF: A9 30     LDA #$30
BDF1: A6 61     LDX $61       ; FAC Exponent
BDF3: D0 03     BNE $BDF8
BDF5: 4C 04 BF  JMP $BF04     ; Convert TI to String

Jump from $BDF3:

BDF8: A9 00     LDA #$00
BDFA: E0 80     CPX #$80
BDFC: F0 02     BEQ $BE00
BDFE: B0 09     BCS $BE09

Jump from $BDFC:

BE00: A9 BD     LDA #$BD
BE02: A0 BD     LDY #$BD
BE04: 20 28 BA  JSR $BA28     ; Perform Multiply
BE07: A9 F7     LDA #$F7

Jump from $BDFE:

BE09: 85 5D     STA $5D       ; Temporary storage for FLPT value

Jump from $BE2D:

BE0B: A9 B8     LDA #$B8
BE0D: A0 BD     LDY #$BD
BE0F: 20 5B BC  JSR $BC5B     ; Compare FAC#1 With Memory
BE12: F0 1E     BEQ $BE32
BE14: 10 12     BPL $BE28

Jump from $BE26:

BE16: A9 B3     LDA #$B3
BE18: A0 BD     LDY #$BD
BE1A: 20 5B BC  JSR $BC5B     ; Compare FAC#1 With Memory
BE1D: F0 02     BEQ $BE21
BE1F: 10 0E     BPL $BE2F

Jump from $BE1D:

BE21: 20 E2 BA  JSR $BAE2     ; Multiply FAC#1 by 10
BE24: C6 5D     DEC $5D       ; Temporary storage for FLPT value
BE26: D0 EE     BNE $BE16

Jump from $BE14:

BE28: 20 FE BA  JSR $BAFE     ; Divide FAC#1 by 10
BE2B: E6 5D     INC $5D       ; Temporary storage for FLPT value
BE2D: D0 DC     BNE $BE0B

Jump from $BE1F:

BE2F: 20 49 B8  JSR $B849     ; Add 0.5 to FAC#1

Jump from $BE12:

BE32: 20 9B BC  JSR $BC9B     ; Convert FAC#1 to Integer
BE35: A2 01     LDX #$01
BE37: A5 5D     LDA $5D       ; Temporary storage for FLPT value
BE39: 18        CLC
BE3A: 69 0A     ADC #$0A
BE3C: 30 09     BMI $BE47
BE3E: C9 0B     CMP #$0B
BE40: B0 06     BCS $BE48
BE42: 69 FF     ADC #$FF
BE44: AA        TAX
BE45: A9 02     LDA #$02

Jump from $BE3C:

BE47: 38        SEC

Jump from $BE40:

BE48: E9 02     SBC #$02
BE4A: 85 5E     STA $5E       ; Temporary storage for FLPT value
BE4C: 86 5D     STX $5D       ; Temporary storage for FLPT value
BE4E: 8A        TXA
BE4F: F0 02     BEQ $BE53
BE51: 10 13     BPL $BE66

Jump from $BE4F:

BE53: A4 71     LDY $71       ; Pointer: Used during CRUNCH/ASCII conversion
BE55: A9 2E     LDA #$2E
BE57: C8        INY
BE58: 99 FF 00  STA $00FF,Y   ; Assembly Area for Floating point to ASCII
BE5B: 8A        TXA
BE5C: F0 06     BEQ $BE64
BE5E: A9 30     LDA #$30
BE60: C8        INY
BE61: 99 FF 00  STA $00FF,Y   ; Assembly Area for Floating point to ASCII

Jump from $BE5C:

BE64: 84 71     STY $71       ; Pointer: Used during CRUNCH/ASCII conversion

Jump from $BE51:

BE66: A0 00     LDY #$00



 $BE68/48744:   Convert TI to String

Jump from $AF56:

BE68: A2 80     LDX #$80

Jump from $BE8A, $BE8E, $BEC2:

BE6A: A5 65     LDA $65       ; FAC Mantissa
BE6C: 18        CLC
BE6D: 79 19 BF  ADC $BF19,Y   ; Table of Constants  4-byte powers of 10
BE70: 85 65     STA $65       ; FAC Mantissa
BE72: A5 64     LDA $64       ; FAC Mantissa
BE74: 79 18 BF  ADC $BF18,Y   ; Table of Constants  4-byte powers of 10
BE77: 85 64     STA $64       ; FAC Mantissa
BE79: A5 63     LDA $63       ; FAC Mantissa
BE7B: 79 17 BF  ADC $BF17,Y   ; Table of Constants  4-byte powers of 10
BE7E: 85 63     STA $63       ; FAC Mantissa
BE80: A5 62     LDA $62       ; FAC Mantissa
BE82: 79 16 BF  ADC $BF16,Y   ; Table of Constants  4-byte powers of 10
BE85: 85 62     STA $62       ; FAC Mantissa
BE87: E8        INX
BE88: B0 04     BCS $BE8E
BE8A: 10 DE     BPL $BE6A
BE8C: 30 02     BMI $BE90

Jump from $BE88:

BE8E: 30 DA     BMI $BE6A

Jump from $BE8C:

BE90: 8A        TXA
BE91: 90 04     BCC $BE97
BE93: 49 FF     EOR #$FF
BE95: 69 0A     ADC #$0A

Jump from $BE91:

BE97: 69 2F     ADC #$2F
BE99: C8        INY
BE9A: C8        INY
BE9B: C8        INY
BE9C: C8        INY
BE9D: 84 47     STY $47       ; Value/Descriptor-Pointer
BE9F: A4 71     LDY $71       ; Pointer: Used during CRUNCH/ASCII conversion
BEA1: C8        INY
BEA2: AA        TAX
BEA3: 29 7F     AND #$7F
BEA5: 99 FF 00  STA $00FF,Y   ; Assembly Area for Floating point to ASCII
BEA8: C6 5D     DEC $5D       ; Temporary storage for FLPT value
BEAA: D0 06     BNE $BEB2
BEAC: A9 2E     LDA #$2E
BEAE: C8        INY
BEAF: 99 FF 00  STA $00FF,Y   ; Assembly Area for Floating point to ASCII

Jump from $BEAA:

BEB2: 84 71     STY $71       ; Pointer: Used during CRUNCH/ASCII conversion
BEB4: A4 47     LDY $47       ; Value/Descriptor-Pointer
BEB6: 8A        TXA
BEB7: 49 FF     EOR #$FF
BEB9: 29 80     AND #$80
BEBB: AA        TAX
BEBC: C0 24     CPY #$24
BEBE: F0 04     BEQ $BEC4
BEC0: C0 3C     CPY #$3C
BEC2: D0 A6     BNE $BE6A

Jump from $BEBE:

BEC4: A4 71     LDY $71       ; Pointer: Used during CRUNCH/ASCII conversion

Jump from $BECC:

BEC6: B9 FF 00  LDA $00FF,Y   ; Assembly Area for Floating point to ASCII
BEC9: 88        DEY
BECA: C9 30     CMP #$30
BECC: F0 F8     BEQ $BEC6
BECE: C9 2E     CMP #$2E
BED0: F0 01     BEQ $BED3
BED2: C8        INY

Jump from $BED0:

BED3: A9 2B     LDA #$2B
BED5: A6 5E     LDX $5E       ; Temporary storage for FLPT value
BED7: F0 2E     BEQ $BF07
BED9: 10 08     BPL $BEE3
BEDB: A9 00     LDA #$00
BEDD: 38        SEC
BEDE: E5 5E     SBC $5E       ; Temporary storage for FLPT value
BEE0: AA        TAX
BEE1: A9 2D     LDA #$2D

Jump from $BED9:

BEE3: 99 01 01  STA $0101,Y   ; 6510 Hardware Stack Area
BEE6: A9 45     LDA #$45
BEE8: 99 00 01  STA $0100,Y   ; 6510 Hardware Stack Area
BEEB: 8A        TXA
BEEC: A2 2F     LDX #$2F
BEEE: 38        SEC

Jump from $BEF2:

BEEF: E8        INX
BEF0: E9 0A     SBC #$0A
BEF2: B0 FB     BCS $BEEF
BEF4: 69 3A     ADC #$3A
BEF6: 99 03 01  STA $0103,Y   ; 6510 Hardware Stack Area
BEF9: 8A        TXA
BEFA: 99 02 01  STA $0102,Y   ; 6510 Hardware Stack Area
BEFD: A9 00     LDA #$00
BEFF: 99 04 01  STA $0104,Y   ; 6510 Hardware Stack Area
BF02: F0 08     BEQ $BF0C

Jump from $BDF5:

BF04: 99 FF 00  STA $00FF,Y   ; Assembly Area for Floating point to ASCII

Jump from $BED7:

BF07: A9 00     LDA #$00
BF09: 99 00 01  STA $0100,Y   ; 6510 Hardware Stack Area

Jump from $BF02:

BF0C: A9 00     LDA #$00
BF0E: A0 01     LDY #$01
BF10: 60        RTS



 $BF11/48913:   Table of Constants  0.5

BF11: 80 00 00 00 00



 $BF16/48918:   Table of Constants  4-byte powers of 10

BF16: FA 0A 1F 00 00 98 96 80
BF1E: FF F0 BD C0 00 01 86 A0
BF26: FF FF D8 F0 00 00 03 E8
BF2E: FF FF FF 9C 00 00 00 0A
BF36: FF FF FF FF


Kernal-Reference:

 ADC $BF16,Y : $BE82

 ADC $BF17,Y : $BE7B

 ADC $BF18,Y : $BE74

 ADC $BF19,Y : $BE6D


 $BF3A/48954:   Table of Constants  TI Constants

BF3A: FF DF 0A 80 00 03 4B C0
BF42: FF FF 73 60 00 00 0E 10
BF4A: FF FF FD A8 00 00 00 3C
BF52: EC AA AA AA AA AA AA AA
BF5A: AA AA AA AA AA AA AA AA
BF62: AA AA AA AA AA AA AA AA
BF6A: AA AA AA AA AA AA AA



 $BF71/49009:   Evaluate <sqr>

BF71: 20 0C BC  JSR $BC0C     ; Copy FAC#1 into FAC#2
BF74: A9 11     LDA #$11
BF76: A0 BF     LDY #$BF
BF78: 20 A2 BB  JSR $BBA2     ; Load FAC#1 From Memory



 $BF7B/49019:   Evaluate <power>

BF7B: F0 70     BEQ $BFED     ; Evaluate <exp>
BF7D: A5 69     LDA $69       ; AFAC Exponent
BF7F: D0 03     BNE $BF84
BF81: 4C F9 B8  JMP $B8F9     ; Perform Addition

Jump from $BF7F:

BF84: A2 4E     LDX #$4E
BF86: A0 00     LDY #$00
BF88: 20 D4 BB  JSR $BBD4     ; Store FAC#1 in Memory
BF8B: A5 6E     LDA $6E       ; AFAC Sign
BF8D: 10 0F     BPL $BF9E
BF8F: 20 CC BC  JSR $BCCC     ; Evaluate <int>
BF92: A9 4E     LDA #$4E
BF94: A0 00     LDY #$00
BF96: 20 5B BC  JSR $BC5B     ; Compare FAC#1 With Memory
BF99: D0 03     BNE $BF9E
BF9B: 98        TYA
BF9C: A4 07     LDY $07       ; Temporary Integer during OR/AND

Jump from $BF8D, $BF99:

BF9E: 20 FE BB  JSR $BBFE     ; Copy FAC#2 into FAC#1
BFA1: 98        TYA
BFA2: 48        PHA
BFA3: 20 EA B9  JSR $B9EA     ; Evaluate <log>
BFA6: A9 4E     LDA #$4E
BFA8: A0 00     LDY #$00
BFAA: 20 28 BA  JSR $BA28     ; Perform Multiply
BFAD: 20 ED BF  JSR $BFED     ; Evaluate <exp>
BFB0: 68        PLA
BFB1: 4A        LSR
BFB2: 90 0A     BCC $BFBE     ; Negate FAC#1



 $BFB4/49076:   Negate FAC#1

Jump from $BD67, $E030, $E29D, $E2AA, $E313, $E33A:

BFB4: A5 61     LDA $61       ; FAC Exponent
BFB6: F0 06     BEQ $BFBE
BFB8: A5 66     LDA $66       ; FAC Sign
BFBA: 49 FF     EOR #$FF
BFBC: 85 66     STA $66       ; FAC Sign

Jump from $BFB6, $BFB2:

BFBE: 60        RTS



 $BFBF/49087:   Table of Constants  1.44269504

BFBF: 81 38 AA 3B 29



 $BFC4/49092:   Table of Constants  #07

BFC4: 07



 $BFC5/49093:   Table of Constants  2.149875 E-5

BFC5: 71 34 58 3E 56



 $BFCA/49098:   Table of Constants  1.435231 E-4

BFCA: 74 16 7E B3 1B



 $BFCF/49103:   Table of Constants  1.342263 E-3

BFCF: 77 2F EE E3 85



 $BFD4/49108:   Table of Constants  9.6414017 E-3

BFD4: 7A 1D 84 1C 2A



 $BFD9/49113:   Table of Constants  5.550513 E-2

BFD9: 7C 63 59 58 0A



 $BFDE/49118:   Table of Constants  2.402263 E-4

BFDE: 7E 75 FD E7 C6



 $BFE3/49123:   Table of Constants  6.931471 E-1

BFE3: 80 31 72 18 10



 $BFE8/49128:   Table of Constants  1.00

BFE8: 81 00 00 00 00



 $BFED/49133:   Evaluate <exp>

Jump from $BF7B, $BFAD:

BFED: A9 BF     LDA #$BF
BFEF: A0 BF     LDY #$BF
BFF1: 20 28 BA  JSR $BA28     ; Perform Multiply
BFF4: A5 70     LDA $70       ; FAC low-order rounding
BFF6: 69 50     ADC #$50
BFF8: 90 03     BCC $BFFD
BFFA: 20 23 BC  JSR $BC23     ; Round FAC#1

Jump from $BFF8:

BFFD: 4C 00 E0  JMP $E000     ; EXP continued From BASIC ROM



 $E000/57344:   EXP continued From BASIC ROM

Jump from $BFFD:

E000: 85 56     STA $56       ; Jump Vector used in Function Evaluation
E002: 20 0F BC  JSR $BC0F     ; Copy FAC#1 into FAC#2
E005: A5 61     LDA $61       ; FAC Exponent
E007: C9 88     CMP #$88
E009: 90 03     BCC $E00E

Jump from $E016:

E00B: 20 D4 BA  JSR $BAD4     ; Overflow / Underflow

Jump from $E009:

E00E: 20 CC BC  JSR $BCCC     ; Evaluate <int>
E011: A5 07     LDA $07       ; Temporary Integer during OR/AND
E013: 18        CLC
E014: 69 81     ADC #$81
E016: F0 F3     BEQ $E00B
E018: 38        SEC
E019: E9 01     SBC #$01
E01B: 48        PHA
E01C: A2 05     LDX #$05

Jump from $E027:

E01E: B5 69     LDA $69,X     ; AFAC Exponent
E020: B4 61     LDY $61,X     ; FAC Exponent
E022: 95 61     STA $61,X     ; FAC Exponent
E024: 94 69     STY $69,X     ; AFAC Exponent
E026: CA        DEX
E027: 10 F5     BPL $E01E
E029: A5 56     LDA $56       ; Jump Vector used in Function Evaluation
E02B: 85 70     STA $70       ; FAC low-order rounding
E02D: 20 53 B8  JSR $B853     ; Perform Subtraction
E030: 20 B4 BF  JSR $BFB4     ; Negate FAC#1
E033: A9 C4     LDA #$C4
E035: A0 BF     LDY #$BF
E037: 20 59 E0  JSR $E059     ; Series Evaluation
E03A: A9 00     LDA #$00
E03C: 85 6F     STA $6F       ; Sign of result of Arithmetic Evaluation
E03E: 68        PLA
E03F: 20 B9 BA  JSR $BAB9     ; Test Both Accumulators
E042: 60        RTS



 $E043/57411:   Series Evaluation

Jump from $BA16, $E2B1, $E328:

E043: 85 71     STA $71       ; Pointer: Used during CRUNCH/ASCII conversion
E045: 84 72     STY $72       ; Pointer: Used during CRUNCH/ASCII conversion
E047: 20 CA BB  JSR $BBCA     ; Store FAC#1 in Memory
E04A: A9 57     LDA #$57
E04C: 20 28 BA  JSR $BA28     ; Perform Multiply
E04F: 20 5D E0  JSR $E05D
E052: A9 57     LDA #$57
E054: A0 00     LDY #$00
E056: 4C 28 BA  JMP $BA28     ; Perform Multiply

Jump from $E037:

E059: 85 71     STA $71       ; Pointer: Used during CRUNCH/ASCII conversion
E05B: 84 72     STY $72       ; Pointer: Used during CRUNCH/ASCII conversion

Jump from $E04F:

E05D: 20 C7 BB  JSR $BBC7     ; Store FAC#1 in Memory
E060: B1 71     LDA ($71),Y   ; Pointer: Used during CRUNCH/ASCII conversion
E062: 85 67     STA $67       ; Pointer: Series Evaluation Constant
E064: A4 71     LDY $71       ; Pointer: Used during CRUNCH/ASCII conversion
E066: C8        INY
E067: 98        TYA
E068: D0 02     BNE $E06C
E06A: E6 72     INC $72       ; Pointer: Used during CRUNCH/ASCII conversion

Jump from $E068:

E06C: 85 71     STA $71       ; Pointer: Used during CRUNCH/ASCII conversion
E06E: A4 72     LDY $72       ; Pointer: Used during CRUNCH/ASCII conversion

Jump from $E08A:

E070: 20 28 BA  JSR $BA28     ; Perform Multiply
E073: A5 71     LDA $71       ; Pointer: Used during CRUNCH/ASCII conversion
E075: A4 72     LDY $72       ; Pointer: Used during CRUNCH/ASCII conversion
E077: 18        CLC
E078: 69 05     ADC #$05
E07A: 90 01     BCC $E07D
E07C: C8        INY

Jump from $E07A:

E07D: 85 71     STA $71       ; Pointer: Used during CRUNCH/ASCII conversion
E07F: 84 72     STY $72       ; Pointer: Used during CRUNCH/ASCII conversion
E081: 20 67 B8  JSR $B867     ; Perform Addition
E084: A9 5C     LDA #$5C
E086: A0 00     LDY #$00
E088: C6 67     DEC $67       ; Pointer: Series Evaluation Constant
E08A: D0 E4     BNE $E070
E08C: 60        RTS



 $E08D/57485:   Constants for RND

E08D: 98 35 44 7A 00 68 28 B1
E095: 46 00



 $E097/57495:   Evaluate <rnd>

E097: 20 2B BC  JSR $BC2B     ; Check Sign of FAC#1
E09A: 30 37     BMI $E0D3
E09C: D0 20     BNE $E0BE
E09E: 20 F3 FF  JSR $FFF3     ; Return I/O Base Address
E0A1: 86 22     STX $22       ; Second Utility Pointer
E0A3: 84 23     STY $23       ; Second Utility Pointer
E0A5: A0 04     LDY #$04
E0A7: B1 22     LDA ($22),Y   ; Second Utility Pointer
E0A9: 85 62     STA $62       ; FAC Mantissa
E0AB: C8        INY
E0AC: B1 22     LDA ($22),Y   ; Second Utility Pointer
E0AE: 85 64     STA $64       ; FAC Mantissa
E0B0: A0 08     LDY #$08
E0B2: B1 22     LDA ($22),Y   ; Second Utility Pointer
E0B4: 85 63     STA $63       ; FAC Mantissa
E0B6: C8        INY
E0B7: B1 22     LDA ($22),Y   ; Second Utility Pointer
E0B9: 85 65     STA $65       ; FAC Mantissa
E0BB: 4C E3 E0  JMP $E0E3

Jump from $E09C:

E0BE: A9 8B     LDA #$8B
E0C0: A0 00     LDY #$00
E0C2: 20 A2 BB  JSR $BBA2     ; Load FAC#1 From Memory
E0C5: A9 8D     LDA #$8D
E0C7: A0 E0     LDY #$E0
E0C9: 20 28 BA  JSR $BA28     ; Perform Multiply
E0CC: A9 92     LDA #$92
E0CE: A0 E0     LDY #$E0
E0D0: 20 67 B8  JSR $B867     ; Perform Addition

Jump from $E09A:

E0D3: A6 65     LDX $65       ; FAC Mantissa
E0D5: A5 62     LDA $62       ; FAC Mantissa
E0D7: 85 65     STA $65       ; FAC Mantissa
E0D9: 86 62     STX $62       ; FAC Mantissa
E0DB: A6 63     LDX $63       ; FAC Mantissa
E0DD: A5 64     LDA $64       ; FAC Mantissa
E0DF: 85 63     STA $63       ; FAC Mantissa
E0E1: 86 64     STX $64       ; FAC Mantissa

Jump from $E0BB:

E0E3: A9 00     LDA #$00
E0E5: 85 66     STA $66       ; FAC Sign
E0E7: A5 61     LDA $61       ; FAC Exponent
E0E9: 85 70     STA $70       ; FAC low-order rounding
E0EB: A9 80     LDA #$80
E0ED: 85 61     STA $61       ; FAC Exponent
E0EF: 20 D7 B8  JSR $B8D7     ; Perform Addition
E0F2: A2 8B     LDX #$8B
E0F4: A0 00     LDY #$00

Jump from $E2C2:

E0F6: 4C D4 BB  JMP $BBD4     ; Store FAC#1 in Memory



 $E0F9/57593:   Handle I/O Error in BASIC

Jump from $E10F, $E115, $E11B, $E121, $E127, $E162, $E1D1:

E0F9: C9 F0     CMP #$F0
E0FB: D0 07     BNE $E104
E0FD: 84 38     STY $38       ; Pointer: Highest Address available to BASIC
E0FF: 86 37     STX $37       ; Pointer: Highest Address available to BASIC
E101: 4C 63 A6  JMP $A663     ; Perform [clr]

Jump from $E0FB:

E104: AA        TAX
E105: D0 02     BNE $E109
E107: A2 1E     LDX #$1E

Jump from $E105:

E109: 4C 37 A4  JMP $A437     ; Error Routine



 $E10C/57612:   Output Character

Jump from $AB47:

E10C: 20 D2 FF  JSR $FFD2     ; Output Vector, chrout
E10F: B0 E8     BCS $E0F9     ; Handle I/O Error in BASIC
E111: 60        RTS



 $E112/57618:   Input Character

Jump from $A562:

E112: 20 CF FF  JSR $FFCF     ; Input Vector, chrin
E115: B0 E2     BCS $E0F9     ; Handle I/O Error in BASIC
E117: 60        RTS



 $E118/57624:   Set Up For Output

Jump from $AA93:

E118: 20 AD E4  JSR $E4AD     ; Patch for BASIC Call to CHKOUT
E11B: B0 DC     BCS $E0F9     ; Handle I/O Error in BASIC
E11D: 60        RTS



 $E11E/57630:   Set Up For Input

Jump from $AB8F, $ABAF:

E11E: 20 C6 FF  JSR $FFC6     ; Set Input
E121: B0 D6     BCS $E0F9     ; Handle I/O Error in BASIC
E123: 60        RTS



 $E124/57636:   Get One Character

Jump from $AC35:

E124: 20 E4 FF  JSR $FFE4     ; Get From Keyboad
E127: B0 D0     BCS $E0F9     ; Handle I/O Error in BASIC
E129: 60        RTS



 $E12A/57642:   Perform [sys]

E12A: 20 8A AD  JSR $AD8A     ; Confirm Result
E12D: 20 F7 B7  JSR $B7F7     ; Convert FAC#1 to Integer in LINNUM
E130: A9 E1     LDA #$E1
E132: 48        PHA
E133: A9 46     LDA #$46
E135: 48        PHA
E136: AD 0F 03  LDA $030F     ; Storage for 6510 Status Register during SYS
E139: 48        PHA
E13A: AD 0C 03  LDA $030C     ; Storage for 6510 Accumulator during SYS
E13D: AE 0D 03  LDX $030D     ; Storage for 6510 X-Register during SYS
E140: AC 0E 03  LDY $030E     ; Storage for 6510 Y-Register during SYS
E143: 28        PLP
E144: 6C 14 00  JMP ($0014)   ; Temporary: Integer value
E147: 08        PHP
E148: 8D 0C 03  STA $030C     ; Storage for 6510 Accumulator during SYS
E14B: 8E 0D 03  STX $030D     ; Storage for 6510 X-Register during SYS
E14E: 8C 0E 03  STY $030E     ; Storage for 6510 Y-Register during SYS
E151: 68        PLA
E152: 8D 0F 03  STA $030F     ; Storage for 6510 Status Register during SYS
E155: 60        RTS



 $E156/57686:   Perform [save]

E156: 20 D4 E1  JSR $E1D4     ; Get Parameters For LOAD/SAVE
E159: A6 2D     LDX $2D       ; Pointer: Start of BASIC Variables
E15B: A4 2E     LDY $2E       ; Pointer: Start of BASIC Variables
E15D: A9 2B     LDA #$2B
E15F: 20 D8 FF  JSR $FFD8     ; Save RAM To Device
E162: B0 95     BCS $E0F9     ; Handle I/O Error in BASIC
E164: 60        RTS



 $E165/57701:   Perform [verify]

E165: A9 01     LDA #$01
E167: 2C        .BYTE $2C



 $E168/57704:   Perform [load]

E168: A9 00     LDA #$00
E16A: 85 0A     STA $0A       ; Load/Verify-Flag
E16C: 20 D4 E1  JSR $E1D4     ; Get Parameters For LOAD/SAVE
E16F: A5 0A     LDA $0A       ; Load/Verify-Flag
E171: A6 2B     LDX $2B       ; Pointer: Start of BASIC Text Area
E173: A4 2C     LDY $2C       ; Pointer: Start of BASIC Text Area
E175: 20 D5 FF  JSR $FFD5     ; Load RAM From Device
E178: B0 57     BCS $E1D1     ; Perform [close]
E17A: A5 0A     LDA $0A       ; Load/Verify-Flag
E17C: F0 17     BEQ $E195
E17E: A2 1C     LDX #$1C
E180: 20 B7 FF  JSR $FFB7     ; Read I/O Status Word
E183: 29 10     AND #$10
E185: D0 17     BNE $E19E
E187: A5 7A     LDA $7A       ; Pointer: Current Byte of BASIC Text
E189: C9 02     CMP #$02
E18B: F0 07     BEQ $E194
E18D: A9 64     LDA #$64
E18F: A0 A3     LDY #$A3
E191: 4C 1E AB  JMP $AB1E     ; Output String

Jump from $E18B, $E1CF:

E194: 60        RTS

Jump from $E17C:

E195: 20 B7 FF  JSR $FFB7     ; Read I/O Status Word
E198: 29 BF     AND #$BF
E19A: F0 05     BEQ $E1A1
E19C: A2 1D     LDX #$1D

Jump from $E185:

E19E: 4C 37 A4  JMP $A437     ; Error Routine

Jump from $E19A:

E1A1: A5 7B     LDA $7B       ; Pointer: Current Byte of BASIC Text
E1A3: C9 02     CMP #$02
E1A5: D0 0E     BNE $E1B5
E1A7: 86 2D     STX $2D       ; Pointer: Start of BASIC Variables
E1A9: 84 2E     STY $2E       ; Pointer: Start of BASIC Variables
E1AB: A9 76     LDA #$76
E1AD: A0 A3     LDY #$A3
E1AF: 20 1E AB  JSR $AB1E     ; Output String
E1B2: 4C 2A A5  JMP $A52A     ; Insert BASIC Text

Jump from $E1A5:

E1B5: 20 8E A6  JSR $A68E     ; Reset TXTPTR
E1B8: 20 33 A5  JSR $A533     ; Rechain Lines
E1BB: 4C 77 A6  JMP $A677     ; Perform [clr]



 $E1BE/57790:   Perform [open]

E1BE: 20 19 E2  JSR $E219     ; Get Parameters For OPEN/CLOSE
E1C1: 20 C0 FF  JSR $FFC0     ; Open Vector
E1C4: B0 0B     BCS $E1D1     ; Perform [close]
E1C6: 60        RTS



 $E1C7/57799:   Perform [close]

E1C7: 20 19 E2  JSR $E219     ; Get Parameters For OPEN/CLOSE
E1CA: A5 49     LDA $49       ; Pointer: Index Variable for FOR/NEXT loop
E1CC: 20 C3 FF  JSR $FFC3     ; Close Vector
E1CF: 90 C3     BCC $E194     ; Perform [load]

Jump from $E178, $E1C4:

E1D1: 4C F9 E0  JMP $E0F9     ; Handle I/O Error in BASIC



 $E1D4/57812:   Get Parameters For LOAD/SAVE

Jump from $E156, $E16C:

E1D4: A9 00     LDA #$00
E1D6: 20 BD FF  JSR $FFBD     ; Set Filename
E1D9: A2 08     LDX #$08
E1DB: A0 00     LDY #$00
E1DD: 20 BA FF  JSR $FFBA     ; Set Logical File Parameters
E1E0: 20 06 E2  JSR $E206     ; Check Default Parameters
E1E3: 20 57 E2  JSR $E257     ; Get Parameters For OPEN/CLOSE
E1E6: 20 06 E2  JSR $E206     ; Check Default Parameters
E1E9: 20 00 E2  JSR $E200     ; Get Next One Byte Parameter
E1EC: A0 00     LDY #$00
E1EE: 86 49     STX $49       ; Pointer: Index Variable for FOR/NEXT loop
E1F0: 20 BA FF  JSR $FFBA     ; Set Logical File Parameters
E1F3: 20 06 E2  JSR $E206     ; Check Default Parameters
E1F6: 20 00 E2  JSR $E200     ; Get Next One Byte Parameter
E1F9: 8A        TXA
E1FA: A8        TAY
E1FB: A6 49     LDX $49       ; Pointer: Index Variable for FOR/NEXT loop
E1FD: 4C BA FF  JMP $FFBA     ; Set Logical File Parameters



 $E200/57856:   Get Next One Byte Parameter

Jump from $E1E9, $E1F6, $E231, $E245:

E200: 20 0E E2  JSR $E20E     ; Check For Comma
E203: 4C 9E B7  JMP $B79E     ; Evaluate Text to 1 Byte in XR



 $E206/57862:   Check Default Parameters

Jump from $E1E0, $E1E6, $E1F3, $E22E, $E242, $E251:

E206: 20 79 00  JSR $0079     ; CHRGOT: Get same Byte again
E209: D0 02     BNE $E20D
E20B: 68        PLA
E20C: 68        PLA

Jump from $E209, $E214:

E20D: 60        RTS



 $E20E/57870:   Check For Comma

Jump from $E200, $E254:

E20E: 20 FD AE  JSR $AEFD     ; Test ','

Jump from $E21E:

E211: 20 79 00  JSR $0079     ; CHRGOT: Get same Byte again
E214: D0 F7     BNE $E20D     ; Check Default Parameters
E216: 4C 08 AF  JMP $AF08     ; Output ?SYNTAX Error



 $E219/57881:   Get Parameters For OPEN/CLOSE

Jump from $E1BE, $E1C7:

E219: A9 00     LDA #$00
E21B: 20 BD FF  JSR $FFBD     ; Set Filename
E21E: 20 11 E2  JSR $E211     ; Check For Comma
E221: 20 9E B7  JSR $B79E     ; Evaluate Text to 1 Byte in XR
E224: 86 49     STX $49       ; Pointer: Index Variable for FOR/NEXT loop
E226: 8A        TXA
E227: A2 01     LDX #$01
E229: A0 00     LDY #$00
E22B: 20 BA FF  JSR $FFBA     ; Set Logical File Parameters
E22E: 20 06 E2  JSR $E206     ; Check Default Parameters
E231: 20 00 E2  JSR $E200     ; Get Next One Byte Parameter
E234: 86 4A     STX $4A       ; Pointer: Index Variable for FOR/NEXT loop
E236: A0 00     LDY #$00
E238: A5 49     LDA $49       ; Pointer: Index Variable for FOR/NEXT loop
E23A: E0 03     CPX #$03
E23C: 90 01     BCC $E23F
E23E: 88        DEY

Jump from $E23C:

E23F: 20 BA FF  JSR $FFBA     ; Set Logical File Parameters
E242: 20 06 E2  JSR $E206     ; Check Default Parameters
E245: 20 00 E2  JSR $E200     ; Get Next One Byte Parameter
E248: 8A        TXA
E249: A8        TAY
E24A: A6 4A     LDX $4A       ; Pointer: Index Variable for FOR/NEXT loop
E24C: A5 49     LDA $49       ; Pointer: Index Variable for FOR/NEXT loop
E24E: 20 BA FF  JSR $FFBA     ; Set Logical File Parameters
E251: 20 06 E2  JSR $E206     ; Check Default Parameters
E254: 20 0E E2  JSR $E20E     ; Check For Comma

Jump from $E1E3:

E257: 20 9E AD  JSR $AD9E     ; Evaluate Expression in Text
E25A: 20 A3 B6  JSR $B6A3     ; Perform String Housekeeping
E25D: A6 22     LDX $22       ; Second Utility Pointer
E25F: A4 23     LDY $23       ; Second Utility Pointer
E261: 4C BD FF  JMP $FFBD     ; Set Filename



 $E264/57956:   Evaluate <cos>

E264: A9 E0     LDA #$E0
E266: A0 E2     LDY #$E2
E268: 20 67 B8  JSR $B867     ; Perform Addition



 $E26B/57963:   Evaluate <sin>

Jump from $E2BB:

E26B: 20 0C BC  JSR $BC0C     ; Copy FAC#1 into FAC#2
E26E: A9 E5     LDA #$E5
E270: A0 E2     LDY #$E2
E272: A6 6E     LDX $6E       ; AFAC Sign
E274: 20 07 BB  JSR $BB07     ; Divide FAC#2 by Flpt at (AC/YR)
E277: 20 0C BC  JSR $BC0C     ; Copy FAC#1 into FAC#2
E27A: 20 CC BC  JSR $BCCC     ; Evaluate <int>
E27D: A9 00     LDA #$00
E27F: 85 6F     STA $6F       ; Sign of result of Arithmetic Evaluation
E281: 20 53 B8  JSR $B853     ; Perform Subtraction
E284: A9 EA     LDA #$EA
E286: A0 E2     LDY #$E2
E288: 20 50 B8  JSR $B850     ; Perform Subtraction
E28B: A5 66     LDA $66       ; FAC Sign
E28D: 48        PHA
E28E: 10 0D     BPL $E29D
E290: 20 49 B8  JSR $B849     ; Add 0.5 to FAC#1
E293: A5 66     LDA $66       ; FAC Sign
E295: 30 09     BMI $E2A0
E297: A5 12     LDA $12       ; Flag: TAN sign/Comparative result
E299: 49 FF     EOR #$FF
E29B: 85 12     STA $12       ; Flag: TAN sign/Comparative result

Jump from $E28E, $E2DD:

E29D: 20 B4 BF  JSR $BFB4     ; Negate FAC#1

Jump from $E295:

E2A0: A9 EA     LDA #$EA
E2A2: A0 E2     LDY #$E2
E2A4: 20 67 B8  JSR $B867     ; Perform Addition
E2A7: 68        PLA
E2A8: 10 03     BPL $E2AD
E2AA: 20 B4 BF  JSR $BFB4     ; Negate FAC#1

Jump from $E2A8:

E2AD: A9 EF     LDA #$EF
E2AF: A0 E2     LDY #$E2
E2B1: 4C 43 E0  JMP $E043     ; Series Evaluation



 $E2B4/58036:   Evaluate <tan>

E2B4: 20 CA BB  JSR $BBCA     ; Store FAC#1 in Memory
E2B7: A9 00     LDA #$00
E2B9: 85 12     STA $12       ; Flag: TAN sign/Comparative result
E2BB: 20 6B E2  JSR $E26B     ; Evaluate <sin>
E2BE: A2 4E     LDX #$4E
E2C0: A0 00     LDY #$00
E2C2: 20 F6 E0  JSR $E0F6     ; Evaluate <rnd>
E2C5: A9 57     LDA #$57
E2C7: A0 00     LDY #$00
E2C9: 20 A2 BB  JSR $BBA2     ; Load FAC#1 From Memory
E2CC: A9 00     LDA #$00
E2CE: 85 66     STA $66       ; FAC Sign
E2D0: A5 12     LDA $12       ; Flag: TAN sign/Comparative result
E2D2: 20 DC E2  JSR $E2DC
E2D5: A9 4E     LDA #$4E
E2D7: A0 00     LDY #$00
E2D9: 4C 0F BB  JMP $BB0F     ; Divide FAC#2 by FAC#1

Jump from $E2D2:

E2DC: 48        PHA
E2DD: 4C 9D E2  JMP $E29D     ; Evaluate <sin>



 $E2E0/58080:   Table of Trig Constants   1.570796327

E2E0: 81 49 0F DA A2



 $E2E5/58085:   Table of Trig Constants   6.28318531

E2E5: 83 49 0F DA A2



 $E2EA/58090:   Table of Trig Constants   0.25

E2EA: 7F 00 00 00 00



 $E2EF/58095:   Table of Trig Constants   #05

E2EF: 05



 $E2F0/58096:   Table of Trig Constants   -14.3813907

E2F0: 84 E6 1A 2D 1B



 $E2F5/58101:   Table of Trig Constants   42.0077971

E2F5: 86 28 07 FB F8



 $E2FA/58106:   Table of Trig Constants   -76.7041703

E2FA: 87 99 68 89 01



 $E2FF/58111:   Table of Trig Constants   81.6052237

E2FF: 87 23 35 DF E1



 $E304/58116:   Table of Trig Constants   -41.3417021

E304: 86 A5 5D E7 28



 $E309/58121:   Table of Trig Constants   6.28318531

E309: 83 49 0F DA A2



 $E30E/58126:   Evaluate <atn>

E30E: A5 66     LDA $66       ; FAC Sign
E310: 48        PHA
E311: 10 03     BPL $E316
E313: 20 B4 BF  JSR $BFB4     ; Negate FAC#1

Jump from $E311:

E316: A5 61     LDA $61       ; FAC Exponent
E318: 48        PHA
E319: C9 81     CMP #$81
E31B: 90 07     BCC $E324
E31D: A9 BC     LDA #$BC
E31F: A0 B9     LDY #$B9
E321: 20 0F BB  JSR $BB0F     ; Divide FAC#2 by FAC#1

Jump from $E31B:

E324: A9 3E     LDA #$3E
E326: A0 E3     LDY #$E3
E328: 20 43 E0  JSR $E043     ; Series Evaluation
E32B: 68        PLA
E32C: C9 81     CMP #$81
E32E: 90 07     BCC $E337
E330: A9 E0     LDA #$E0
E332: A0 E2     LDY #$E2
E334: 20 50 B8  JSR $B850     ; Perform Subtraction

Jump from $E32E:

E337: 68        PLA
E338: 10 03     BPL $E33D
E33A: 4C B4 BF  JMP $BFB4     ; Negate FAC#1

Jump from $E338:

E33D: 60        RTS



 $E33E/58174:   Table of ATN Constants   #0b

E33E: 0B



 $E33F/58175:   Table of ATN Constants   -0.00068479391

E33F: 76 B3 83 BD D3



 $E344/58180:   Table of ATN Constants   0.00485094216

E344: 79 1E F4 A6 F5



 $E349/58185:   Table of ATN Constants   -0.161117018

E349: 7B 83 FC B0 10



 $E34E/58190:   Table of ATN Constants   0.034209638

E34E: 7C 0C 1F 67 CA



 $E353/58195:   Table of ATN Constants   -0.0542791328

E353: 7C DE 53 CB C1



 $E358/58200:   Table of ATN Constants   0.0724571965

E358: 7D 14 64 70 4C



 $E35D/58205:   Table of ATN Constants   -0.0898023954

E35D: 7D B7 EA 51 7A



 $E362/58210:   Table of ATN Constants   0.110932413

E362: 7D 63 30 88 7E



 $E367/58215:   Table of ATN Constants   -0.142839808

E367: 7E 92 44 99 3A



 $E36C/58220:   Table of ATN Constants   0.19999912

E36C: 7E 4C CC 91 C7



 $E371/58225:   Table of ATN Constants   -0.333333316

E371: 7F AA AA AA 13



 $E376/58230:   Table of ATN Constants   1.00

E376: 81 00 00 00 00



 $E37B/58235:   BASIC Warm Start [RUNSTOP-RESTORE]

E37B: 20 CC FF  JSR $FFCC     ; Restore I/O Vector
E37E: A9 00     LDA #$00
E380: 85 13     STA $13       ; File number of current Input Device
E382: 20 7A A6  JSR $A67A     ; Perform [clr]
E385: 58        CLI

Jump from $A714, $A854, $E3A0:

E386: A2 80     LDX #$80
E388: 6C 00 03  JMP ($0300)   ; Vector: BASIC Error Message
E38B: 8A        TXA
E38C: 30 03     BMI $E391
E38E: 4C 3A A4  JMP $A43A     ; Error Routine

Jump from $E38C:

E391: 4C 74 A4  JMP $A474     ; Restart BASIC



 $E394/58260:   BASIC Cold Start

E394: 20 53 E4  JSR $E453     ; Initialize Vectors
E397: 20 BF E3  JSR $E3BF     ; Initialize BASIC RAM
E39A: 20 22 E4  JSR $E422     ; Output Power-Up Message
E39D: A2 FB     LDX #$FB
E39F: 9A        TXS
E3A0: D0 E4     BNE $E386     ; BASIC Warm Start [RUNSTOP-RESTORE]



 $E3A2/58274:   CHRGET For Zero-page

Jump from $E3B1:

E3A2: E6 7A     INC $7A       ; Pointer: Current Byte of BASIC Text
E3A4: D0 02     BNE $E3A8
E3A6: E6 7B     INC $7B       ; Pointer: Current Byte of BASIC Text

Jump from $E3A4:

E3A8: AD 60 EA  LDA $EA60     ; Main IRQ Entry Point
E3AB: C9 3A     CMP #$3A
E3AD: B0 0A     BCS $E3B9
E3AF: C9 20     CMP #$20
E3B1: F0 EF     BEQ $E3A2
E3B3: 38        SEC
E3B4: E9 30     SBC #$30
E3B6: 38        SEC
E3B7: E9 D0     SBC #$D0

Jump from $E3AD:

E3B9: 60        RTS


Kernal-Reference:

 LDA $E3A2,X : $E3E2


 $E3BA/58298:   RND Seed For zero-page

E3BA: 80 4F C7 52 58



 $E3BF/58303:   Initialize BASIC RAM

Jump from $E397:

E3BF: A9 4C     LDA #$4C
E3C1: 85 54     STA $54       ; Jump Vector used in Function Evaluation
E3C3: 8D 10 03  STA $0310     ; USR Function JMP Instruction
E3C6: A9 48     LDA #$48
E3C8: A0 B2     LDY #$B2
E3CA: 8D 11 03  STA $0311     ; USR Address
E3CD: 8C 12 03  STY $0312     ; USR Address
E3D0: A9 91     LDA #$91
E3D2: A0 B3     LDY #$B3
E3D4: 85 05     STA $05       ; Jump Vector: Convert Integer to Floating point
E3D6: 84 06     STY $06       ; Jump Vector: Convert Integer to Floating point
E3D8: A9 AA     LDA #$AA
E3DA: A0 B1     LDY #$B1
E3DC: 85 03     STA $03       ; Jump Vector: Convert FAC to Integer
E3DE: 84 04     STY $04       ; Jump Vector: Convert FAC to Integer
E3E0: A2 1C     LDX #$1C

Jump from $E3E8:

E3E2: BD A2 E3  LDA $E3A2,X   ; CHRGET For Zero-page
E3E5: 95 73     STA $73,X     ; CHRGET: Get next Byte of BASIC Text
E3E7: CA        DEX
E3E8: 10 F8     BPL $E3E2
E3EA: A9 03     LDA #$03
E3EC: 85 53     STA $53       ; Length of String during Garbage collection
E3EE: A9 00     LDA #$00
E3F0: 85 68     STA $68       ; Bit Overflow Area during normalisation Routine
E3F2: 85 13     STA $13       ; File number of current Input Device
E3F4: 85 18     STA $18       ; Last temporary String Address
E3F6: A2 01     LDX #$01
E3F8: 8E FD 01  STX $01FD     ; BASIC Stack Area
E3FB: 8E FC 01  STX $01FC     ; BASIC Stack Area
E3FE: A2 19     LDX #$19
E400: 86 16     STX $16       ; Pointer: Temporary String Stack
E402: 38        SEC
E403: 20 9C FF  JSR $FF9C     ; Set/Read System RAM Bottom
E406: 86 2B     STX $2B       ; Pointer: Start of BASIC Text Area
E408: 84 2C     STY $2C       ; Pointer: Start of BASIC Text Area
E40A: 38        SEC
E40B: 20 99 FF  JSR $FF99     ; Set/Read System RAM Top
E40E: 86 37     STX $37       ; Pointer: Highest Address available to BASIC
E410: 84 38     STY $38       ; Pointer: Highest Address available to BASIC
E412: 86 33     STX $33       ; Pointer: Bottom of String space
E414: 84 34     STY $34       ; Pointer: Bottom of String space
E416: A0 00     LDY #$00
E418: 98        TYA
E419: 91 2B     STA ($2B),Y   ; Pointer: Start of BASIC Text Area
E41B: E6 2B     INC $2B       ; Pointer: Start of BASIC Text Area
E41D: D0 02     BNE $E421
E41F: E6 2C     INC $2C       ; Pointer: Start of BASIC Text Area

Jump from $E41D:

E421: 60        RTS



 $E422/58402:   Output Power-Up Message

Jump from $E39A:

E422: A5 2B     LDA $2B       ; Pointer: Start of BASIC Text Area
E424: A4 2C     LDY $2C       ; Pointer: Start of BASIC Text Area
E426: 20 08 A4  JSR $A408     ; Check Memory Overlap
E429: A9 73     LDA #$73
E42B: A0 E4     LDY #$E4
E42D: 20 1E AB  JSR $AB1E     ; Output String
E430: A5 37     LDA $37       ; Pointer: Highest Address available to BASIC
E432: 38        SEC
E433: E5 2B     SBC $2B       ; Pointer: Start of BASIC Text Area
E435: AA        TAX
E436: A5 38     LDA $38       ; Pointer: Highest Address available to BASIC
E438: E5 2C     SBC $2C       ; Pointer: Start of BASIC Text Area
E43A: 20 CD BD  JSR $BDCD     ; Output Positive Integer in A/X
E43D: A9 60     LDA #$60
E43F: A0 E4     LDY #$E4
E441: 20 1E AB  JSR $AB1E     ; Output String
E444: 4C 44 A6  JMP $A644     ; Perform [new]



 $E447/58439:   Table of BASIC Vectors (for 0300)

E447: 8B E3 83 A4 7C A5 1A A7    $E38B,$A483,$A57C,$A71A
E44F: E4 A7 86 AE                $A7E4,$AE86


Kernal-Reference:

 LDA $E447,X : $E455


 $E453/58451:   Initialize Vectors

Jump from $E394:

E453: A2 0B     LDX #$0B

Jump from $E45C:

E455: BD 47 E4  LDA $E447,X   ; Table of BASIC Vectors (for 0300)
E458: 9D 00 03  STA $0300,X   ; Vector: BASIC Error Message
E45B: CA        DEX
E45C: 10 F7     BPL $E455
E45E: 60        RTS



 $E45F/58463:   Power-Up Message

E45F: 00 20 42 41 53 49 43 20    '{0} BASIC '
E467: 42 59 54 45 53 20 46 52    'BYTES FR'
E46F: 45 45 0D 00 93 0D 20 20    'EE{CR}{0}{CLR}{CR}  '
E477: 20 20 2A 2A 2A 2A 20 43    '  **** C'
E47F: 4F 4D 4D 4F 44 4F 52 45    'OMMODORE'
E487: 20 36 34 20 42 41 53 49    ' 64 BASI'
E48F: 43 20 56 32 20 2A 2A 2A    'C V2 ***'
E497: 2A 0D 0D 20 36 34 4B 20    '*{CR}{CR} 64K '
E49F: 52 41 4D 20 53 59 53 54    'RAM SYST'
E4A7: 45 4D 20 20 00             'EM  {0}'

* SX64:
E477: 20 20 20 2A 2A 2A 2A 4A    '   *****'
E47F: 20 20 53 58 2D 36 34 20    '  SX-64 '
E487: 42 41 53 49 43 20 56 32    'BASIC V2'
E48F: 2E 30 20 20 2A 2A 2A 2A    '.0  ****'
E497: 2A 0D                      '*{CR}'



 $E4AC/58540:   Version Number(?)

E4AC: 5C = Revision 2 (old)
      81 = Revision 3 (new)
      B3 = SX64



 $E4AD/58541:   Patch for BASIC Call to CHKOUT

Jump from $E118:

E4AD: 48        PHA
E4AE: 20 C9 FF  JSR $FFC9     ; Set Output
E4B1: AA        TAX
E4B2: 68        PLA
E4B3: 90 01     BCC $E4B6
E4B5: 8A        TXA

Jump from $E4B3:

E4B6: 60        RTS



 $E4B7/58551:   Unused Bytes For Future Patches

E4B7: AA AA AA AA AA AA AA AA
E4BF: AA AA AA AA AA AA AA AA
E4C7: AA AA AA AA AA AA AA AA
E4CF: AA AA AA AA



 $E4D3/58579:   Patch for RS232-Routines

Jump from $EF94:

E4D3: 85 A9     STA $A9       ; RS232 Flag: Start Bit check/Tape temporary
E4D5: A9 01     LDA #$01
E4D7: 85 AB     STA $AB       ; RS232 Input parity/Tape temporary
E4D9: 60        RTS

* Old KERNAL:
E4D3: AA AA AA AA AA AA AA



 $E4DA/58586:   Reset Character Color

Jump from $EA07:

E4DA: AD 86 02  LDA $0286     ; Current Character Color code
* Old KERNAL:
E4DA: AD 21 D0  LDA $D021     ; VIC: Background Color 0

E4DD: 91 F3     STA ($F3),Y   ; Pointer: Current Color RAM Location
E4DF: 60        RTS



 $E4E0/58592:   Pause After Finding Tape File

Jump from $F763:

E4E0: 69 02     ADC #$02

Jump from $E4E9:

E4E2: A4 91     LDY $91       ; Flag: $7F = STOP key
E4E4: C8        INY
E4E5: D0 04     BNE $E4EB
E4E7: C5 A1     CMP $A1       ; Real-time jiffy Clock
E4E9: D0 F7     BNE $E4E2

Jump from $E4E5:

E4EB: 60        RTS


Kernal-Reference:

 LDA $E4EA,X : $F43D

 LDY $E4EB,X : $F43A


 $E4EC/58604:   RS232 Timing Table -- PAL

E4EC: 19 26 44 19 1A 11 E8 0D
E4F4: 70 0C 06 06 D1 02 37 01
E4FC: AE 00 69 00



 $E500/58624:   Get I/O Address

Jump from $FFF3:

E500: A2 00     LDX #$00
E502: A0 DC     LDY #$DC
E504: 60        RTS



 $E505/58629:   Get Screen Size

Jump from $FFED:

E505: A2 28     LDX #$28
E507: A0 19     LDY #$19
E509: 60        RTS



 $E50A/58634:   Put / Get Row And Column

Jump from $FFF0:

E50A: B0 07     BCS $E513
E50C: 86 D6     STX $D6       ; Current Screen Line number of Cursor
E50E: 84 D3     STY $D3       ; Cursor Column on current Line
E510: 20 6C E5  JSR $E56C     ; Set Screen Pointers

Jump from $E50A:

E513: A6 D6     LDX $D6       ; Current Screen Line number of Cursor
E515: A4 D3     LDY $D3       ; Cursor Column on current Line
E517: 60        RTS



 $E518/58648:   Initialize I/O

Jump from $FE6C, $FF5B:

E518: 20 A0 E5  JSR $E5A0     ; Set I/O Defaults
E51B: A9 00     LDA #$00
E51D: 8D 91 02  STA $0291     ; Flag: Upper/Lower Case change
E520: 85 CF     STA $CF       ; Flag: Cursor Status
E522: A9 48     LDA #$48
E524: 8D 8F 02  STA $028F     ; Vector: Routine to determine Keyboard table
E527: A9 EB     LDA #$EB
E529: 8D 90 02  STA $0290     ; Vector: Routine to determine Keyboard table
E52C: A9 0A     LDA #$0A
E52E: 8D 89 02  STA $0289     ; Maximum number of Bytes in Keyboard Buffer
E531: 8D 8C 02  STA $028C     ; Repeat Key: First repeat delay Counter
E534: A9 0E     LDA #$0E
* SX64:
E534: A9 0E     LDA #$06

E536: 8D 86 02  STA $0286     ; Current Character Color code
E539: A9 04     LDA #$04
E53B: 8D 8B 02  STA $028B     ; Repeat Key: Speed Counter
E53E: A9 0C     LDA #$0C
E540: 85 CD     STA $CD       ; Timer: Count down for Cursor blink toggle
E542: 85 CC     STA $CC       ; Flag: Cursor blink



 $E544/58692:   Clear Screen

Jump from $E86E:

E544: AD 88 02  LDA $0288     ; High Byte of Screen Memory Address
E547: 09 80     ORA #$80
E549: A8        TAY
E54A: A9 00     LDA #$00
E54C: AA        TAX

Jump from $E558:

E54D: 94 D9     STY $D9,X     ; Screen Line Link Table
E54F: 18        CLC
E550: 69 28     ADC #$28
E552: 90 01     BCC $E555
E554: C8        INY

Jump from $E552:

E555: E8        INX
E556: E0 1A     CPX #$1A
E558: D0 F3     BNE $E54D
E55A: A9 FF     LDA #$FF
E55C: 95 D9     STA $D9,X     ; Screen Line Link Table
E55E: A2 18     LDX #$18

Jump from $E564:

E560: 20 FF E9  JSR $E9FF     ; Clear Screen Line
E563: CA        DEX
E564: 10 FA     BPL $E560



 $E566/58726:   Home Cursor

Jump from $E59D, $E78F:

E566: A0 00     LDY #$00
E568: 84 D3     STY $D3       ; Cursor Column on current Line
E56A: 84 D6     STY $D6       ; Current Screen Line number of Cursor



 $E56C/58732:   Set Screen Pointers

Jump from $E510, $E70E, $E847, $E88E:

E56C: A6 D6     LDX $D6       ; Current Screen Line number of Cursor
E56E: A5 D3     LDA $D3       ; Cursor Column on current Line

Jump from $E57A:

E570: B4 D9     LDY $D9,X     ; Screen Line Link Table
E572: 30 08     BMI $E57C
E574: 18        CLC
E575: 69 28     ADC #$28
E577: 85 D3     STA $D3       ; Cursor Column on current Line
E579: CA        DEX
E57A: 10 F4     BPL $E570

Jump from $E572:

E57C: 20 F0 E9  JSR $E9F0     ; Set Start of Line
E57F: A9 27     LDA #$27
E581: E8        INX

Jump from $E58A:

E582: B4 D9     LDY $D9,X     ; Screen Line Link Table
E584: 30 06     BMI $E58C
E586: 18        CLC
E587: 69 28     ADC #$28
E589: E8        INX
E58A: 10 F6     BPL $E582

Jump from $E584:

E58C: 85 D5     STA $D5       ; Current logical Line length: 39 or 79
E58E: 4C 24 EA  JMP $EA24     ; Syncronise Color Pointer

Jump from $E621:

E591: E4 C9     CPX $C9       ; Cursor X/Y position at start of Input
E593: F0 03     BEQ $E598
E595: 4C ED E6  JMP $E6ED     ; Retreat Cursor

Jump from $E593:

E598: 60        RTS
E599: EA        NOP

* Old KERNAL:
E57C: B5 D9     LDA $D9,X     ; Screen Line Link Table
E57E: 29 03     AND #$03
E580: 0D 88 02  ORA $0288     ; High Byte of Screen Memory Address
E583: 85 D2     STA $D2       ; Pointer: Current Screen Line Address
E585: BD F0 EC  LDA $ECF0,X   ; Low Byte Screen Line Addresses
E588: 85 D1     STA $D1       ; Pointer: Current Screen Line Address
E58A: A9 27     LDA #$27
E58C: E8        INX

Jump from $E595:

E58D: B4 D9     LDY $D9,X     ; Screen Line Link Table
E58F: 30 06     BMI $E597
E591: 18        CLC
E592: 69 28     ADC #$28
E594: E8        INX
E595: 10 F6     BPL $E58D

Jump from $E58F:

E597: 85 D5     STA $D5       ; Current logical Line length: 39 or 79
E599: 60        RTS



 $E59A/58778:   Set I/O Defaults (Unused Entry)

E59A: 20 A0 E5  JSR $E5A0     ; Set I/O Defaults
E59D: 4C 66 E5  JMP $E566     ; Home Cursor



 $E5A0/58784:   Set I/O Defaults

Jump from $E518, $E59A:

E5A0: A9 03     LDA #$03
E5A2: 85 9A     STA $9A       ; Default Output Device (3)
E5A4: A9 00     LDA #$00
E5A6: 85 99     STA $99       ; Default Input Device (0)
E5A8: A2 2F     LDX #$2F

Jump from $E5B1:

E5AA: BD B8 EC  LDA $ECB8,X   ; Keyboard 4 -- Control
E5AD: 9D FF CF  STA $CFFF,X
E5B0: CA        DEX
E5B1: D0 F7     BNE $E5AA
E5B3: 60        RTS



 $E5B4/58804:   Get Character From Keyboard Buffer

Jump from $E5E7, $F147:

E5B4: AC 77 02  LDY $0277     ; Keyboard Buffer Queue (FIFO)
E5B7: A2 00     LDX #$00

Jump from $E5C2:

E5B9: BD 78 02  LDA $0278,X   ; Keyboard Buffer Queue (FIFO)
E5BC: 9D 77 02  STA $0277,X   ; Keyboard Buffer Queue (FIFO)
E5BF: E8        INX
E5C0: E4 C6     CPX $C6       ; Number of Characters in Keyboard Buffer queue
E5C2: D0 F5     BNE $E5B9
E5C4: C6 C6     DEC $C6       ; Number of Characters in Keyboard Buffer queue
E5C6: 98        TYA
E5C7: 58        CLI
E5C8: 18        CLC
E5C9: 60        RTS



 $E5CA/58826:   Input From Keyboard

Jump from $E600:

E5CA: 20 16 E7  JSR $E716     ; Output to Screen

Jump from $E5D4, $E5FC, $E638:

E5CD: A5 C6     LDA $C6       ; Number of Characters in Keyboard Buffer queue
E5CF: 85 CC     STA $CC       ; Flag: Cursor blink
E5D1: 8D 92 02  STA $0292     ; Flag: Auto scroll down
E5D4: F0 F7     BEQ $E5CD
E5D6: 78        SEI
E5D7: A5 CF     LDA $CF       ; Flag: Cursor Status
E5D9: F0 0C     BEQ $E5E7
E5DB: A5 CE     LDA $CE       ; Character under Cursor while Cursor Inverted
E5DD: AE 87 02  LDX $0287     ; Background Color under Cursor
E5E0: A0 00     LDY #$00
E5E2: 84 CF     STY $CF       ; Flag: Cursor Status
E5E4: 20 13 EA  JSR $EA13     ; Print To Screen

Jump from $E5D9:

E5E7: 20 B4 E5  JSR $E5B4     ; Get Character From Keyboard Buffer
E5EA: C9 83     CMP #$83
E5EC: D0 10     BNE $E5FE
E5EE: A2 09     LDX #$09
* SX64:
E5EE: A2 09     LDX #$0F

E5F0: 78        SEI
E5F1: 86 C6     STX $C6       ; Number of Characters in Keyboard Buffer queue

Jump from $E5FA:

E5F3: BD E6 EC  LDA $ECE6,X   ; Video Chip Setup Table
* SX64:
E5F3: BD D7 F0  LDA $F0D7,X   ; Table of Kernal I/O Messages

E5F6: 9D 76 02  STA $0276,X   ; Active File Secondary Addresses
E5F9: CA        DEX
E5FA: D0 F7     BNE $E5F3
E5FC: F0 CF     BEQ $E5CD

Jump from $E5EC:

E5FE: C9 0D     CMP #$0D
E600: D0 C8     BNE $E5CA
E602: A4 D5     LDY $D5       ; Current logical Line length: 39 or 79
E604: 84 D0     STY $D0       ; Flag: Input from ...

Jump from $E60D:

E606: B1 D1     LDA ($D1),Y   ; Pointer: Current Screen Line Address
E608: C9 20     CMP #$20
E60A: D0 03     BNE $E60F
E60C: 88        DEY
E60D: D0 F7     BNE $E606

Jump from $E60A:

E60F: C8        INY
E610: 84 C8     STY $C8       ; Pointer: End of Line for Input
E612: A0 00     LDY #$00
E614: 8C 92 02  STY $0292     ; Flag: Auto scroll down
E617: 84 D3     STY $D3       ; Cursor Column on current Line
E619: 84 D4     STY $D4       ; Flag: Editor in Quote Mode
E61B: A5 C9     LDA $C9       ; Cursor X/Y position at start of Input
E61D: 30 1B     BMI $E63A     ; Input From Screen or Keyboard
E61F: A6 D6     LDX $D6       ; Current Screen Line number of Cursor
E621: 20 91 E5  JSR $E591     ; Set Screen Pointers
* Old KERNAL:
E621: 20 ED E6  JSR $E6ED     ; Retreat Cursor

E624: E4 C9     CPX $C9       ; Cursor X/Y position at start of Input
E626: D0 12     BNE $E63A     ; Input From Screen or Keyboard
E628: A5 CA     LDA $CA       ; Cursor X/Y position at start of Input
E62A: 85 D3     STA $D3       ; Cursor Column on current Line
E62C: C5 C8     CMP $C8       ; Pointer: End of Line for Input
E62E: 90 0A     BCC $E63A     ; Input From Screen or Keyboard
E630: B0 2B     BCS $E65D     ; Input From Screen or Keyboard



 $E632/58930:   Input From Screen or Keyboard

Jump from $F163, $F170:

E632: 98        TYA
E633: 48        PHA
E634: 8A        TXA
E635: 48        PHA
E636: A5 D0     LDA $D0       ; Flag: Input from ...
E638: F0 93     BEQ $E5CD     ; Input From Keyboard

Jump from $E61D, $E626, $E62E:

E63A: A4 D3     LDY $D3       ; Cursor Column on current Line
E63C: B1 D1     LDA ($D1),Y   ; Pointer: Current Screen Line Address
E63E: 85 D7     STA $D7       ; Current Input Character/Last Character Output
E640: 29 3F     AND #$3F
E642: 06 D7     ASL $D7       ; Current Input Character/Last Character Output
E644: 24 D7     BIT $D7       ; Current Input Character/Last Character Output
E646: 10 02     BPL $E64A
E648: 09 80     ORA #$80

Jump from $E646:

E64A: 90 04     BCC $E650
E64C: A6 D4     LDX $D4       ; Flag: Editor in Quote Mode
E64E: D0 04     BNE $E654

Jump from $E64A:

E650: 70 02     BVS $E654
E652: 09 40     ORA #$40

Jump from $E64E, $E650:

E654: E6 D3     INC $D3       ; Cursor Column on current Line
E656: 20 84 E6  JSR $E684     ; Quotes Test
E659: C4 C8     CPY $C8       ; Pointer: End of Line for Input
E65B: D0 17     BNE $E674

Jump from $E630:

E65D: A9 00     LDA #$00
E65F: 85 D0     STA $D0       ; Flag: Input from ...
E661: A9 0D     LDA #$0D
E663: A6 99     LDX $99       ; Default Input Device (0)
E665: E0 03     CPX #$03
E667: F0 06     BEQ $E66F
E669: A6 9A     LDX $9A       ; Default Output Device (3)
E66B: E0 03     CPX #$03
E66D: F0 03     BEQ $E672

Jump from $E667:

E66F: 20 16 E7  JSR $E716     ; Output to Screen

Jump from $E66D:

E672: A9 0D     LDA #$0D

Jump from $E65B:

E674: 85 D7     STA $D7       ; Current Input Character/Last Character Output
E676: 68        PLA
E677: AA        TAX
E678: 68        PLA
E679: A8        TAY
E67A: A5 D7     LDA $D7       ; Current Input Character/Last Character Output
E67C: C9 DE     CMP #$DE
E67E: D0 02     BNE $E682
E680: A9 FF     LDA #$FF

Jump from $E67E:

E682: 18        CLC
E683: 60        RTS



 $E684/59012:   Quotes Test

Jump from $E656, $E73F:

E684: C9 22     CMP #$22
E686: D0 08     BNE $E690
E688: A5 D4     LDA $D4       ; Flag: Editor in Quote Mode
E68A: 49 01     EOR #$01
E68C: 85 D4     STA $D4       ; Flag: Editor in Quote Mode
E68E: A9 22     LDA #$22

Jump from $E686:

E690: 60        RTS



 $E691/59025:   Set Up Screen Print

Jump from $E7E0:

E691: 09 40     ORA #$40

Jump from $E742:

E693: A6 C7     LDX $C7       ; Flag: Reverse On/Off
E695: F0 02     BEQ $E699

Jump from $E749, $E782, $E82F:

E697: 09 80     ORA #$80

Jump from $E695:

E699: A6 D8     LDX $D8       ; Count of number of inserts outstanding
E69B: F0 02     BEQ $E69F
E69D: C6 D8     DEC $D8       ; Count of number of inserts outstanding

Jump from $E69B:

E69F: AE 86 02  LDX $0286     ; Current Character Color code
E6A2: 20 13 EA  JSR $EA13     ; Print To Screen
E6A5: 20 B6 E6  JSR $E6B6     ; Advance Cursor

Jump from $E709, $E7AA, $E7CB, $E826, $E861, $E867, $E871, $E89E, $EC5B, $EC75:

E6A8: 68        PLA
E6A9: A8        TAY
E6AA: A5 D8     LDA $D8       ; Count of number of inserts outstanding
E6AC: F0 02     BEQ $E6B0
E6AE: 46 D4     LSR $D4       ; Flag: Editor in Quote Mode

Jump from $E6AC:

E6B0: 68        PLA
E6B1: AA        TAX
E6B2: 68        PLA
E6B3: 18        CLC
E6B4: 58        CLI
E6B5: 60        RTS



 $E6B6/59062:   Advance Cursor

Jump from $E6A5:

E6B6: 20 B3 E8  JSR $E8B3     ; Check Line Increment
E6B9: E6 D3     INC $D3       ; Cursor Column on current Line
E6BB: A5 D5     LDA $D5       ; Current logical Line length: 39 or 79
E6BD: C5 D3     CMP $D3       ; Cursor Column on current Line
E6BF: B0 3F     BCS $E700     ; Retreat Cursor
E6C1: C9 4F     CMP #$4F
E6C3: F0 32     BEQ $E6F7     ; Retreat Cursor
E6C5: AD 92 02  LDA $0292     ; Flag: Auto scroll down
E6C8: F0 03     BEQ $E6CD
E6CA: 4C 67 E9  JMP $E967     ; Open A Space On The Screen

Jump from $E6C8:

E6CD: A6 D6     LDX $D6       ; Current Screen Line number of Cursor
E6CF: E0 19     CPX #$19
E6D1: 90 07     BCC $E6DA
E6D3: 20 EA E8  JSR $E8EA     ; Scroll Screen
E6D6: C6 D6     DEC $D6       ; Current Screen Line number of Cursor
E6D8: A6 D6     LDX $D6       ; Current Screen Line number of Cursor

Jump from $E6D1, $E97E, $E9C2:

E6DA: 16 D9     ASL $D9,X     ; Screen Line Link Table
E6DC: 56 D9     LSR $D9,X     ; Screen Line Link Table
E6DE: E8        INX
E6DF: B5 D9     LDA $D9,X     ; Screen Line Link Table
E6E1: 09 80     ORA #$80
E6E3: 95 D9     STA $D9,X     ; Screen Line Link Table
E6E5: CA        DEX
E6E6: A5 D5     LDA $D5       ; Current logical Line length: 39 or 79
E6E8: 18        CLC
E6E9: 69 28     ADC #$28
E6EB: 85 D5     STA $D5       ; Current logical Line length: 39 or 79



 $E6ED/59117:   Retreat Cursor

Jump from $E6F2, $E595:

E6ED: B5 D9     LDA $D9,X     ; Screen Line Link Table
E6EF: 30 03     BMI $E6F4
E6F1: CA        DEX
E6F2: D0 F9     BNE $E6ED

Jump from $E6EF:

E6F4: 4C F0 E9  JMP $E9F0     ; Set Start of Line

Jump from $E6C3:

E6F7: C6 D6     DEC $D6       ; Current Screen Line number of Cursor
E6F9: 20 7C E8  JSR $E87C     ; Go to Next Line
E6FC: A9 00     LDA #$00
E6FE: 85 D3     STA $D3       ; Cursor Column on current Line

Jump from $E6BF:

E700: 60        RTS



 $E701/59137:   Back on to Previous Line

Jump from $E753, $E864:

E701: A6 D6     LDX $D6       ; Current Screen Line number of Cursor
E703: D0 06     BNE $E70B
E705: 86 D3     STX $D3       ; Cursor Column on current Line
E707: 68        PLA
E708: 68        PLA
E709: D0 9D     BNE $E6A8     ; Set Up Screen Print

Jump from $E703:

E70B: CA        DEX
E70C: 86 D6     STX $D6       ; Current Screen Line number of Cursor
E70E: 20 6C E5  JSR $E56C     ; Set Screen Pointers
E711: A4 D5     LDY $D5       ; Current logical Line length: 39 or 79
E713: 84 D3     STY $D3       ; Cursor Column on current Line
E715: 60        RTS



 $E716/59158:   Output to Screen

Jump from $E5CA, $E66F, $F1D2:

E716: 48        PHA
E717: 85 D7     STA $D7       ; Current Input Character/Last Character Output
E719: 8A        TXA
E71A: 48        PHA
E71B: 98        TYA
E71C: 48        PHA
E71D: A9 00     LDA #$00
E71F: 85 D0     STA $D0       ; Flag: Input from ...
E721: A4 D3     LDY $D3       ; Cursor Column on current Line
E723: A5 D7     LDA $D7       ; Current Input Character/Last Character Output
E725: 10 03     BPL $E72A     ; -unshifted characters-
E727: 4C D4 E7  JMP $E7D4     ; -shifted characters-



 $E72A/59178:   -unshifted characters-

Jump from $E725:

E72A: C9 0D     CMP #$0D
E72C: D0 03     BNE $E731
E72E: 4C 91 E8  JMP $E891     ; Output <CR>

Jump from $E72C:

E731: C9 20     CMP #$20
E733: 90 10     BCC $E745
E735: C9 60     CMP #$60
E737: 90 04     BCC $E73D
E739: 29 DF     AND #$DF
E73B: D0 02     BNE $E73F

Jump from $E737:

E73D: 29 3F     AND #$3F

Jump from $E73B:

E73F: 20 84 E6  JSR $E684     ; Quotes Test
E742: 4C 93 E6  JMP $E693     ; Set Up Screen Print

Jump from $E733:

E745: A6 D8     LDX $D8       ; Count of number of inserts outstanding
E747: F0 03     BEQ $E74C
E749: 4C 97 E6  JMP $E697     ; Set Up Screen Print

Jump from $E747:

E74C: C9 14     CMP #$14
E74E: D0 2E     BNE $E77E
E750: 98        TYA
E751: D0 06     BNE $E759
E753: 20 01 E7  JSR $E701     ; Back on to Previous Line
E756: 4C 73 E7  JMP $E773

Jump from $E751:

E759: 20 A1 E8  JSR $E8A1     ; Check Line Decrement
E75C: 88        DEY
E75D: 84 D3     STY $D3       ; Cursor Column on current Line
E75F: 20 24 EA  JSR $EA24     ; Syncronise Color Pointer

Jump from $E771:

E762: C8        INY
E763: B1 D1     LDA ($D1),Y   ; Pointer: Current Screen Line Address
E765: 88        DEY
E766: 91 D1     STA ($D1),Y   ; Pointer: Current Screen Line Address
E768: C8        INY
E769: B1 F3     LDA ($F3),Y   ; Pointer: Current Color RAM Location
E76B: 88        DEY
E76C: 91 F3     STA ($F3),Y   ; Pointer: Current Color RAM Location
E76E: C8        INY
E76F: C4 D5     CPY $D5       ; Current logical Line length: 39 or 79
E771: D0 EF     BNE $E762

Jump from $E756:

E773: A9 20     LDA #$20
E775: 91 D1     STA ($D1),Y   ; Pointer: Current Screen Line Address
E777: AD 86 02  LDA $0286     ; Current Character Color code
E77A: 91 F3     STA ($F3),Y   ; Pointer: Current Color RAM Location
E77C: 10 4D     BPL $E7CB

Jump from $E74E:

E77E: A6 D4     LDX $D4       ; Flag: Editor in Quote Mode
E780: F0 03     BEQ $E785
E782: 4C 97 E6  JMP $E697     ; Set Up Screen Print

Jump from $E780:

E785: C9 12     CMP #$12
E787: D0 02     BNE $E78B
E789: 85 C7     STA $C7       ; Flag: Reverse On/Off

Jump from $E787:

E78B: C9 13     CMP #$13
E78D: D0 03     BNE $E792
E78F: 20 66 E5  JSR $E566     ; Home Cursor

Jump from $E78D:

E792: C9 1D     CMP #$1D
E794: D0 17     BNE $E7AD
E796: C8        INY
E797: 20 B3 E8  JSR $E8B3     ; Check Line Increment
E79A: 84 D3     STY $D3       ; Cursor Column on current Line
E79C: 88        DEY
E79D: C4 D5     CPY $D5       ; Current logical Line length: 39 or 79
E79F: 90 09     BCC $E7AA
E7A1: C6 D6     DEC $D6       ; Current Screen Line number of Cursor
E7A3: 20 7C E8  JSR $E87C     ; Go to Next Line
E7A6: A0 00     LDY #$00

Jump from $E7BA, $E7BC:

E7A8: 84 D3     STY $D3       ; Cursor Column on current Line

Jump from $E79F:

E7AA: 4C A8 E6  JMP $E6A8     ; Set Up Screen Print

Jump from $E794:

E7AD: C9 11     CMP #$11
E7AF: D0 1D     BNE $E7CE
E7B1: 18        CLC
E7B2: 98        TYA
E7B3: 69 28     ADC #$28
E7B5: A8        TAY
E7B6: E6 D6     INC $D6       ; Current Screen Line number of Cursor
E7B8: C5 D5     CMP $D5       ; Current logical Line length: 39 or 79
E7BA: 90 EC     BCC $E7A8
E7BC: F0 EA     BEQ $E7A8
E7BE: C6 D6     DEC $D6       ; Current Screen Line number of Cursor

Jump from $E7C6:

E7C0: E9 28     SBC #$28
E7C2: 90 04     BCC $E7C8
E7C4: 85 D3     STA $D3       ; Cursor Column on current Line
E7C6: D0 F8     BNE $E7C0

Jump from $E7C2:

E7C8: 20 7C E8  JSR $E87C     ; Go to Next Line

Jump from $E77C:

E7CB: 4C A8 E6  JMP $E6A8     ; Set Up Screen Print

Jump from $E7AF:

E7CE: 20 CB E8  JSR $E8CB     ; Set Color Code
E7D1: 4C 44 EC  JMP $EC44     ; Graphics/Text Control



 $E7D4/59348:   -shifted characters-

Jump from $E727:

E7D4: 29 7F     AND #$7F
E7D6: C9 7F     CMP #$7F
E7D8: D0 02     BNE $E7DC
E7DA: A9 5E     LDA #$5E

Jump from $E7D8:

E7DC: C9 20     CMP #$20
E7DE: 90 03     BCC $E7E3
E7E0: 4C 91 E6  JMP $E691     ; Set Up Screen Print

Jump from $E7DE:

E7E3: C9 0D     CMP #$0D
E7E5: D0 03     BNE $E7EA
E7E7: 4C 91 E8  JMP $E891     ; Output <CR>

Jump from $E7E5:

E7EA: A6 D4     LDX $D4       ; Flag: Editor in Quote Mode
E7EC: D0 3F     BNE $E82D
E7EE: C9 14     CMP #$14
E7F0: D0 37     BNE $E829
E7F2: A4 D5     LDY $D5       ; Current logical Line length: 39 or 79
E7F4: B1 D1     LDA ($D1),Y   ; Pointer: Current Screen Line Address
E7F6: C9 20     CMP #$20
E7F8: D0 04     BNE $E7FE
E7FA: C4 D3     CPY $D3       ; Cursor Column on current Line
E7FC: D0 07     BNE $E805

Jump from $E7F8:

E7FE: C0 4F     CPY #$4F
E800: F0 24     BEQ $E826
E802: 20 65 E9  JSR $E965     ; Open A Space On The Screen

Jump from $E7FC:

E805: A4 D5     LDY $D5       ; Current logical Line length: 39 or 79
E807: 20 24 EA  JSR $EA24     ; Syncronise Color Pointer

Jump from $E819:

E80A: 88        DEY
E80B: B1 D1     LDA ($D1),Y   ; Pointer: Current Screen Line Address
E80D: C8        INY
E80E: 91 D1     STA ($D1),Y   ; Pointer: Current Screen Line Address
E810: 88        DEY
E811: B1 F3     LDA ($F3),Y   ; Pointer: Current Color RAM Location
E813: C8        INY
E814: 91 F3     STA ($F3),Y   ; Pointer: Current Color RAM Location
E816: 88        DEY
E817: C4 D3     CPY $D3       ; Cursor Column on current Line
E819: D0 EF     BNE $E80A
E81B: A9 20     LDA #$20
E81D: 91 D1     STA ($D1),Y   ; Pointer: Current Screen Line Address
E81F: AD 86 02  LDA $0286     ; Current Character Color code
E822: 91 F3     STA ($F3),Y   ; Pointer: Current Color RAM Location
E824: E6 D8     INC $D8       ; Count of number of inserts outstanding

Jump from $E800:

E826: 4C A8 E6  JMP $E6A8     ; Set Up Screen Print

Jump from $E7F0:

E829: A6 D8     LDX $D8       ; Count of number of inserts outstanding
E82B: F0 05     BEQ $E832

Jump from $E7EC:

E82D: 09 40     ORA #$40
E82F: 4C 97 E6  JMP $E697     ; Set Up Screen Print

Jump from $E82B:

E832: C9 11     CMP #$11
E834: D0 16     BNE $E84C
E836: A6 D6     LDX $D6       ; Current Screen Line number of Cursor
E838: F0 37     BEQ $E871
E83A: C6 D6     DEC $D6       ; Current Screen Line number of Cursor
E83C: A5 D3     LDA $D3       ; Cursor Column on current Line
E83E: 38        SEC
E83F: E9 28     SBC #$28
E841: 90 04     BCC $E847
E843: 85 D3     STA $D3       ; Cursor Column on current Line
E845: 10 2A     BPL $E871

Jump from $E841:

E847: 20 6C E5  JSR $E56C     ; Set Screen Pointers
E84A: D0 25     BNE $E871

Jump from $E834:

E84C: C9 12     CMP #$12
E84E: D0 04     BNE $E854
E850: A9 00     LDA #$00
E852: 85 C7     STA $C7       ; Flag: Reverse On/Off

Jump from $E84E:

E854: C9 1D     CMP #$1D
E856: D0 12     BNE $E86A
E858: 98        TYA
E859: F0 09     BEQ $E864
E85B: 20 A1 E8  JSR $E8A1     ; Check Line Decrement
E85E: 88        DEY
E85F: 84 D3     STY $D3       ; Cursor Column on current Line
E861: 4C A8 E6  JMP $E6A8     ; Set Up Screen Print

Jump from $E859:

E864: 20 01 E7  JSR $E701     ; Back on to Previous Line
E867: 4C A8 E6  JMP $E6A8     ; Set Up Screen Print

Jump from $E856:

E86A: C9 13     CMP #$13
E86C: D0 06     BNE $E874
E86E: 20 44 E5  JSR $E544     ; Clear Screen

Jump from $E838, $E845, $E84A:

E871: 4C A8 E6  JMP $E6A8     ; Set Up Screen Print

Jump from $E86C:

E874: 09 80     ORA #$80
E876: 20 CB E8  JSR $E8CB     ; Set Color Code
E879: 4C 4F EC  JMP $EC4F     ; Graphics/Text Control



 $E87C/59516:   Go to Next Line

Jump from $E6F9, $E7A3, $E7C8, $E89B:

E87C: 46 C9     LSR $C9       ; Cursor X/Y position at start of Input
E87E: A6 D6     LDX $D6       ; Current Screen Line number of Cursor

Jump from $E88A:

E880: E8        INX
E881: E0 19     CPX #$19
E883: D0 03     BNE $E888
E885: 20 EA E8  JSR $E8EA     ; Scroll Screen

Jump from $E883:

E888: B5 D9     LDA $D9,X     ; Screen Line Link Table
E88A: 10 F4     BPL $E880
E88C: 86 D6     STX $D6       ; Current Screen Line number of Cursor
E88E: 4C 6C E5  JMP $E56C     ; Set Screen Pointers



 $E891/59537:   Output <CR>

Jump from $E72E, $E7E7:

E891: A2 00     LDX #$00
E893: 86 D8     STX $D8       ; Count of number of inserts outstanding
E895: 86 C7     STX $C7       ; Flag: Reverse On/Off
E897: 86 D4     STX $D4       ; Flag: Editor in Quote Mode
E899: 86 D3     STX $D3       ; Cursor Column on current Line
E89B: 20 7C E8  JSR $E87C     ; Go to Next Line
E89E: 4C A8 E6  JMP $E6A8     ; Set Up Screen Print



 $E8A1/59553:   Check Line Decrement

Jump from $E759, $E85B:

E8A1: A2 02     LDX #$02
E8A3: A9 00     LDA #$00

Jump from $E8AD:

E8A5: C5 D3     CMP $D3       ; Cursor Column on current Line
E8A7: F0 07     BEQ $E8B0
E8A9: 18        CLC
E8AA: 69 28     ADC #$28
E8AC: CA        DEX
E8AD: D0 F6     BNE $E8A5
E8AF: 60        RTS

Jump from $E8A7:

E8B0: C6 D6     DEC $D6       ; Current Screen Line number of Cursor
E8B2: 60        RTS



 $E8B3/59571:   Check Line Increment

Jump from $E6B6, $E797:

E8B3: A2 02     LDX #$02
E8B5: A9 27     LDA #$27

Jump from $E8BF:

E8B7: C5 D3     CMP $D3       ; Cursor Column on current Line
E8B9: F0 07     BEQ $E8C2
E8BB: 18        CLC
E8BC: 69 28     ADC #$28
E8BE: CA        DEX
E8BF: D0 F6     BNE $E8B7
E8C1: 60        RTS

Jump from $E8B9:

E8C2: A6 D6     LDX $D6       ; Current Screen Line number of Cursor
E8C4: E0 19     CPX #$19
E8C6: F0 02     BEQ $E8CA
E8C8: E6 D6     INC $D6       ; Current Screen Line number of Cursor

Jump from $E8C6:

E8CA: 60        RTS



 $E8CB/59595:   Set Color Code

Jump from $E7CE, $E876:

E8CB: A2 0F     LDX #$0F

Jump from $E8D3:

E8CD: DD DA E8  CMP $E8DA,X   ; Color Code Table
E8D0: F0 04     BEQ $E8D6
E8D2: CA        DEX
E8D3: 10 F8     BPL $E8CD
E8D5: 60        RTS

Jump from $E8D0:

E8D6: 8E 86 02  STX $0286     ; Current Character Color code
E8D9: 60        RTS



 $E8DA/59610:   Color Code Table

E8DA: 90 05 1C 9F 9C 1E 1F 9E
E8E2: 81 95 96 97 98 99 9A 9B


Kernal-Reference:

 CMP $E8DA,X : $E8CD


 $E8EA/59626:   Scroll Screen

Jump from $E6D3, $E885, $E975:

E8EA: A5 AC     LDA $AC       ; Pointer: Tape Buffer/Screen scrolling
E8EC: 48        PHA
E8ED: A5 AD     LDA $AD       ; Pointer: Tape Buffer/Screen scrolling
E8EF: 48        PHA
E8F0: A5 AE     LDA $AE       ; Tape End Address/End of Program
E8F2: 48        PHA
E8F3: A5 AF     LDA $AF       ; Tape End Address/End of Program
E8F5: 48        PHA

Jump from $E931:

E8F6: A2 FF     LDX #$FF
E8F8: C6 D6     DEC $D6       ; Current Screen Line number of Cursor
E8FA: C6 C9     DEC $C9       ; Cursor X/Y position at start of Input
E8FC: CE A5 02  DEC $02A5     ; Temporary for Line Index

Jump from $E911:

E8FF: E8        INX
E900: 20 F0 E9  JSR $E9F0     ; Set Start of Line
E903: E0 18     CPX #$18
E905: B0 0C     BCS $E913
E907: BD F1 EC  LDA $ECF1,X   ; Low Byte Screen Line Addresses
E90A: 85 AC     STA $AC       ; Pointer: Tape Buffer/Screen scrolling
E90C: B5 DA     LDA $DA,X     ; Screen Line Link Table
E90E: 20 C8 E9  JSR $E9C8     ; Move A Screen Line
E911: 30 EC     BMI $E8FF

Jump from $E905:

E913: 20 FF E9  JSR $E9FF     ; Clear Screen Line
E916: A2 00     LDX #$00

Jump from $E927:

E918: B5 D9     LDA $D9,X     ; Screen Line Link Table
E91A: 29 7F     AND #$7F
E91C: B4 DA     LDY $DA,X     ; Screen Line Link Table
E91E: 10 02     BPL $E922
E920: 09 80     ORA #$80

Jump from $E91E:

E922: 95 D9     STA $D9,X     ; Screen Line Link Table
E924: E8        INX
E925: E0 18     CPX #$18
E927: D0 EF     BNE $E918
E929: A5 F1     LDA $F1       ; Screen Line Link Table
E92B: 09 80     ORA #$80
E92D: 85 F1     STA $F1       ; Screen Line Link Table
E92F: A5 D9     LDA $D9       ; Screen Line Link Table
E931: 10 C3     BPL $E8F6
E933: E6 D6     INC $D6       ; Current Screen Line number of Cursor
E935: EE A5 02  INC $02A5     ; Temporary for Line Index
E938: A9 7F     LDA #$7F
E93A: 8D 00 DC  STA $DC00     ; CIA1: Data Port A (Keyboard, Joystick, Paddles)
E93D: AD 01 DC  LDA $DC01     ; CIA1: Data Port B (Keyboard, Joystick, Paddles)
E940: C9 FB     CMP #$FB
E942: 08        PHP
E943: A9 7F     LDA #$7F
E945: 8D 00 DC  STA $DC00     ; CIA1: Data Port A (Keyboard, Joystick, Paddles)
E948: 28        PLP
E949: D0 0B     BNE $E956
E94B: A0 00     LDY #$00

Jump from $E94F, $E952:

E94D: EA        NOP
E94E: CA        DEX
E94F: D0 FC     BNE $E94D
E951: 88        DEY
E952: D0 F9     BNE $E94D
E954: 84 C6     STY $C6       ; Number of Characters in Keyboard Buffer queue

Jump from $E949:

E956: A6 D6     LDX $D6       ; Current Screen Line number of Cursor

Jump from $E9C5:

E958: 68        PLA
E959: 85 AF     STA $AF       ; Tape End Address/End of Program
E95B: 68        PLA
E95C: 85 AE     STA $AE       ; Tape End Address/End of Program
E95E: 68        PLA
E95F: 85 AD     STA $AD       ; Pointer: Tape Buffer/Screen scrolling
E961: 68        PLA
E962: 85 AC     STA $AC       ; Pointer: Tape Buffer/Screen scrolling
E964: 60        RTS



 $E965/59749:   Open A Space On The Screen

Jump from $E802:

E965: A6 D6     LDX $D6       ; Current Screen Line number of Cursor

Jump from $E96A, $E6CA:

E967: E8        INX
E968: B5 D9     LDA $D9,X     ; Screen Line Link Table
E96A: 10 FB     BPL $E967
E96C: 8E A5 02  STX $02A5     ; Temporary for Line Index
E96F: E0 18     CPX #$18
E971: F0 0E     BEQ $E981
E973: 90 0C     BCC $E981
E975: 20 EA E8  JSR $E8EA     ; Scroll Screen
E978: AE A5 02  LDX $02A5     ; Temporary for Line Index
E97B: CA        DEX
E97C: C6 D6     DEC $D6       ; Current Screen Line number of Cursor
E97E: 4C DA E6  JMP $E6DA     ; Advance Cursor

Jump from $E971, $E973:

E981: A5 AC     LDA $AC       ; Pointer: Tape Buffer/Screen scrolling
E983: 48        PHA
E984: A5 AD     LDA $AD       ; Pointer: Tape Buffer/Screen scrolling
E986: 48        PHA
E987: A5 AE     LDA $AE       ; Tape End Address/End of Program
E989: 48        PHA
E98A: A5 AF     LDA $AF       ; Tape End Address/End of Program
E98C: 48        PHA
E98D: A2 19     LDX #$19

Jump from $E9A4:

E98F: CA        DEX
E990: 20 F0 E9  JSR $E9F0     ; Set Start of Line
E993: EC A5 02  CPX $02A5     ; Temporary for Line Index
E996: 90 0E     BCC $E9A6
E998: F0 0C     BEQ $E9A6
E99A: BD EF EC  LDA $ECEF,X   ; Shift-Run Equivalent
E99D: 85 AC     STA $AC       ; Pointer: Tape Buffer/Screen scrolling
E99F: B5 D8     LDA $D8,X     ; Count of number of inserts outstanding
E9A1: 20 C8 E9  JSR $E9C8     ; Move A Screen Line
E9A4: 30 E9     BMI $E98F

Jump from $E996, $E998:

E9A6: 20 FF E9  JSR $E9FF     ; Clear Screen Line
E9A9: A2 17     LDX #$17

Jump from $E9BD:

E9AB: EC A5 02  CPX $02A5     ; Temporary for Line Index
E9AE: 90 0F     BCC $E9BF
E9B0: B5 DA     LDA $DA,X     ; Screen Line Link Table
E9B2: 29 7F     AND #$7F
E9B4: B4 D9     LDY $D9,X     ; Screen Line Link Table
E9B6: 10 02     BPL $E9BA
E9B8: 09 80     ORA #$80

Jump from $E9B6:

E9BA: 95 DA     STA $DA,X     ; Screen Line Link Table
E9BC: CA        DEX
E9BD: D0 EC     BNE $E9AB

Jump from $E9AE:

E9BF: AE A5 02  LDX $02A5     ; Temporary for Line Index
E9C2: 20 DA E6  JSR $E6DA     ; Advance Cursor
E9C5: 4C 58 E9  JMP $E958     ; Scroll Screen



 $E9C8/59848:   Move A Screen Line

Jump from $E90E, $E9A1:

E9C8: 29 03     AND #$03
E9CA: 0D 88 02  ORA $0288     ; High Byte of Screen Memory Address
E9CD: 85 AD     STA $AD       ; Pointer: Tape Buffer/Screen scrolling
E9CF: 20 E0 E9  JSR $E9E0     ; Syncronise Color Transfer
E9D2: A0 27     LDY #$27

Jump from $E9DD:

E9D4: B1 AC     LDA ($AC),Y   ; Pointer: Tape Buffer/Screen scrolling
E9D6: 91 D1     STA ($D1),Y   ; Pointer: Current Screen Line Address
E9D8: B1 AE     LDA ($AE),Y   ; Tape End Address/End of Program
E9DA: 91 F3     STA ($F3),Y   ; Pointer: Current Color RAM Location
E9DC: 88        DEY
E9DD: 10 F5     BPL $E9D4
E9DF: 60        RTS



 $E9E0/59872:   Syncronise Color Transfer

Jump from $E9CF:

E9E0: 20 24 EA  JSR $EA24     ; Syncronise Color Pointer
E9E3: A5 AC     LDA $AC       ; Pointer: Tape Buffer/Screen scrolling
E9E5: 85 AE     STA $AE       ; Tape End Address/End of Program
E9E7: A5 AD     LDA $AD       ; Pointer: Tape Buffer/Screen scrolling
E9E9: 29 03     AND #$03
E9EB: 09 D8     ORA #$D8
E9ED: 85 AF     STA $AF       ; Tape End Address/End of Program
E9EF: 60        RTS



 $E9F0/59888:   Set Start of Line

Jump from $E57C, $E6F4, $E900, $E990, $EA01:

E9F0: BD F0 EC  LDA $ECF0,X   ; Low Byte Screen Line Addresses
E9F3: 85 D1     STA $D1       ; Pointer: Current Screen Line Address
E9F5: B5 D9     LDA $D9,X     ; Screen Line Link Table
E9F7: 29 03     AND #$03
E9F9: 0D 88 02  ORA $0288     ; High Byte of Screen Memory Address
E9FC: 85 D2     STA $D2       ; Pointer: Current Screen Line Address
E9FE: 60        RTS



 $E9FF/59903:   Clear Screen Line

Jump from $E560, $E913, $E9A6:

E9FF: A0 27     LDY #$27
EA01: 20 F0 E9  JSR $E9F0     ; Set Start of Line
EA04: 20 24 EA  JSR $EA24     ; Syncronise Color Pointer

Jump from $EA0F:

EA07: 20 DA E4  JSR $E4DA     ; Reset Character Color
EA0A: A9 20     LDA #$20
EA0C: 91 D1     STA ($D1),Y   ; Pointer: Current Screen Line Address
EA0E: 88        DEY
EA0F: 10 F6     BPL $EA07
EA11: 60        RTS
EA12: EA        NOP

* Old KERNAL:
Jump from $EA10:

EA07: A9 20     LDA #$20
EA09: 91 D1     STA ($D1),Y   ; Pointer: Current Screen Line Address
EA0B: 20 DA E4  JSR $E4DA     ; Reset Character Color
EA0E: EA        NOP
EA0F: 88        DEY
EA10: 10 F5     BPL $EA07
EA12: 60        RTS




 $EA13/59923:   Print To Screen

Jump from $E5E4, $E6A2:

EA13: A8        TAY
EA14: A9 02     LDA #$02
EA16: 85 CD     STA $CD       ; Timer: Count down for Cursor blink toggle
EA18: 20 24 EA  JSR $EA24     ; Syncronise Color Pointer
EA1B: 98        TYA

Jump from $EA5E:

EA1C: A4 D3     LDY $D3       ; Cursor Column on current Line
EA1E: 91 D1     STA ($D1),Y   ; Pointer: Current Screen Line Address
EA20: 8A        TXA
EA21: 91 F3     STA ($F3),Y   ; Pointer: Current Color RAM Location
EA23: 60        RTS



 $EA24/59940:   Syncronise Color Pointer

Jump from $E58E, $E75F, $E807, $E9E0, $EA04, $EA18, $EA4F:

EA24: A5 D1     LDA $D1       ; Pointer: Current Screen Line Address
EA26: 85 F3     STA $F3       ; Pointer: Current Color RAM Location
EA28: A5 D2     LDA $D2       ; Pointer: Current Screen Line Address
EA2A: 29 03     AND #$03
EA2C: 09 D8     ORA #$D8
EA2E: 85 F4     STA $F4       ; Pointer: Current Color RAM Location
EA30: 60        RTS



 $EA31/59953:   Main IRQ Entry Point

EA31: 20 EA FF  JSR $FFEA     ; Increment Real-Time Clock
EA34: A5 CC     LDA $CC       ; Flag: Cursor blink
EA36: D0 29     BNE $EA61
EA38: C6 CD     DEC $CD       ; Timer: Count down for Cursor blink toggle
EA3A: D0 25     BNE $EA61
EA3C: A9 14     LDA #$14
EA3E: 85 CD     STA $CD       ; Timer: Count down for Cursor blink toggle
EA40: A4 D3     LDY $D3       ; Cursor Column on current Line
EA42: 46 CF     LSR $CF       ; Flag: Cursor Status
EA44: AE 87 02  LDX $0287     ; Background Color under Cursor
EA47: B1 D1     LDA ($D1),Y   ; Pointer: Current Screen Line Address
EA49: B0 11     BCS $EA5C
EA4B: E6 CF     INC $CF       ; Flag: Cursor Status
EA4D: 85 CE     STA $CE       ; Character under Cursor while Cursor Inverted
EA4F: 20 24 EA  JSR $EA24     ; Syncronise Color Pointer
EA52: B1 F3     LDA ($F3),Y   ; Pointer: Current Color RAM Location
EA54: 8D 87 02  STA $0287     ; Background Color under Cursor
EA57: AE 86 02  LDX $0286     ; Current Character Color code
EA5A: A5 CE     LDA $CE       ; Character under Cursor while Cursor Inverted

Jump from $EA49:

EA5C: 49 80     EOR #$80
EA5E: 20 1C EA  JSR $EA1C     ; Print To Screen

Jump from $EA36, $EA3A:

EA61: A5 01     LDA $01       ; 6510 On-chip 8-bit Input/Output Register
EA63: 29 10     AND #$10
EA65: F0 0A     BEQ $EA71
EA67: A0 00     LDY #$00
EA69: 84 C0     STY $C0       ; Tape Motor Switch
EA6B: A5 01     LDA $01       ; 6510 On-chip 8-bit Input/Output Register
EA6D: 09 20     ORA #$20
EA6F: D0 08     BNE $EA79

Jump from $EA65:

EA71: A5 C0     LDA $C0       ; Tape Motor Switch
EA73: D0 06     BNE $EA7B
EA75: A5 01     LDA $01       ; 6510 On-chip 8-bit Input/Output Register
EA77: 29 1F     AND #$1F

Jump from $EA6F:

EA79: 85 01     STA $01       ; 6510 On-chip 8-bit Input/Output Register

Jump from $EA73:

EA7B: 20 87 EA  JSR $EA87     ; Scan Keyboard
EA7E: AD 0D DC  LDA $DC0D     ; CIA1: Interrupt (IRQ) Control Register


Kernal-Reference:

 LDA $EA60   : $E3A8


 $EA81/60033:   Restore A/X/Y and End IRQ

EA81: 68        PLA
EA82: A8        TAY
EA83: 68        PLA
EA84: AA        TAX
EA85: 68        PLA
EA86: 40        RTI



 $EA87/60039:   Scan Keyboard

Jump from $EA7B, $FF9F:

EA87: A9 00     LDA #$00
EA89: 8D 8D 02  STA $028D     ; Flag: Shift Keys
EA8C: A0 40     LDY #$40
EA8E: 84 CB     STY $CB       ; Matrix value of last Key pressed
EA90: 8D 00 DC  STA $DC00     ; CIA1: Data Port A (Keyboard, Joystick, Paddles)
EA93: AE 01 DC  LDX $DC01     ; CIA1: Data Port B (Keyboard, Joystick, Paddles)
EA96: E0 FF     CPX #$FF
EA98: F0 61     BEQ $EAFB     ; Process Key Image
EA9A: A8        TAY
EA9B: A9 81     LDA #$81
EA9D: 85 F5     STA $F5       ; Vector: Current Keyboard decoding Table
EA9F: A9 EB     LDA #$EB
EAA1: 85 F6     STA $F6       ; Vector: Current Keyboard decoding Table
EAA3: A9 FE     LDA #$FE
EAA5: 8D 00 DC  STA $DC00     ; CIA1: Data Port A (Keyboard, Joystick, Paddles)

Jump from $EADA:

EAA8: A2 08     LDX #$08
EAAA: 48        PHA

Jump from $EAB1:

EAAB: AD 01 DC  LDA $DC01     ; CIA1: Data Port B (Keyboard, Joystick, Paddles)
EAAE: CD 01 DC  CMP $DC01     ; CIA1: Data Port B (Keyboard, Joystick, Paddles)
EAB1: D0 F8     BNE $EAAB

Jump from $EAD2:

EAB3: 4A        LSR
EAB4: B0 16     BCS $EACC
EAB6: 48        PHA
EAB7: B1 F5     LDA ($F5),Y   ; Vector: Current Keyboard decoding Table
EAB9: C9 05     CMP #$05
EABB: B0 0C     BCS $EAC9
EABD: C9 03     CMP #$03
EABF: F0 08     BEQ $EAC9
EAC1: 0D 8D 02  ORA $028D     ; Flag: Shift Keys
EAC4: 8D 8D 02  STA $028D     ; Flag: Shift Keys
EAC7: 10 02     BPL $EACB

Jump from $EABB, $EABF:

EAC9: 84 CB     STY $CB       ; Matrix value of last Key pressed

Jump from $EAC7:

EACB: 68        PLA

Jump from $EAB4:

EACC: C8        INY
EACD: C0 41     CPY #$41
EACF: B0 0B     BCS $EADC
EAD1: CA        DEX
EAD2: D0 DF     BNE $EAB3
EAD4: 38        SEC
EAD5: 68        PLA
EAD6: 2A        ROL
EAD7: 8D 00 DC  STA $DC00     ; CIA1: Data Port A (Keyboard, Joystick, Paddles)
EADA: D0 CC     BNE $EAA8

Jump from $EACF:

EADC: 68        PLA



 $EADD/60125:   Process Key Image

EADD: 6C 8F 02  JMP ($028F)   ; Vector: Routine to determine Keyboard table

Jump from $EB76:

EAE0: A4 CB     LDY $CB       ; Matrix value of last Key pressed
EAE2: B1 F5     LDA ($F5),Y   ; Vector: Current Keyboard decoding Table
EAE4: AA        TAX
EAE5: C4 C5     CPY $C5       ; Matrix value of last Key pressed
EAE7: F0 07     BEQ $EAF0
EAE9: A0 10     LDY #$10
EAEB: 8C 8C 02  STY $028C     ; Repeat Key: First repeat delay Counter
EAEE: D0 36     BNE $EB26

Jump from $EAE7:

EAF0: 29 7F     AND #$7F
EAF2: 2C 8A 02  BIT $028A     ; Flag: Repeat keys
EAF5: 30 16     BMI $EB0D
EAF7: 70 49     BVS $EB42
EAF9: C9 7F     CMP #$7F

Jump from $EA98:

EAFB: F0 29     BEQ $EB26
EAFD: C9 14     CMP #$14
EAFF: F0 0C     BEQ $EB0D
EB01: C9 20     CMP #$20
EB03: F0 08     BEQ $EB0D
EB05: C9 1D     CMP #$1D
EB07: F0 04     BEQ $EB0D
EB09: C9 11     CMP #$11
EB0B: D0 35     BNE $EB42

Jump from $EAF5, $EAFF, $EB03, $EB07:

EB0D: AC 8C 02  LDY $028C     ; Repeat Key: First repeat delay Counter
EB10: F0 05     BEQ $EB17
EB12: CE 8C 02  DEC $028C     ; Repeat Key: First repeat delay Counter
EB15: D0 2B     BNE $EB42

Jump from $EB10:

EB17: CE 8B 02  DEC $028B     ; Repeat Key: Speed Counter
EB1A: D0 26     BNE $EB42
EB1C: A0 04     LDY #$04
EB1E: 8C 8B 02  STY $028B     ; Repeat Key: Speed Counter
EB21: A4 C6     LDY $C6       ; Number of Characters in Keyboard Buffer queue
EB23: 88        DEY
EB24: 10 1C     BPL $EB42

Jump from $EAEE, $EAFB:

EB26: A4 CB     LDY $CB       ; Matrix value of last Key pressed
EB28: 84 C5     STY $C5       ; Matrix value of last Key pressed
EB2A: AC 8D 02  LDY $028D     ; Flag: Shift Keys
EB2D: 8C 8E 02  STY $028E     ; Last Shift Key used for debouncing
EB30: E0 FF     CPX #$FF
EB32: F0 0E     BEQ $EB42
EB34: 8A        TXA
EB35: A6 C6     LDX $C6       ; Number of Characters in Keyboard Buffer queue
EB37: EC 89 02  CPX $0289     ; Maximum number of Bytes in Keyboard Buffer
EB3A: B0 06     BCS $EB42
EB3C: 9D 77 02  STA $0277,X   ; Keyboard Buffer Queue (FIFO)
EB3F: E8        INX
EB40: 86 C6     STX $C6       ; Number of Characters in Keyboard Buffer queue

Jump from $EAF7, $EB0B, $EB15, $EB1A, $EB24, $EB32, $EB3A, $EB52:

EB42: A9 7F     LDA #$7F
EB44: 8D 00 DC  STA $DC00     ; CIA1: Data Port A (Keyboard, Joystick, Paddles)
EB47: 60        RTS



 $EB48/60232:   Check for Shift, CTRL, C=

EB48: AD 8D 02  LDA $028D     ; Flag: Shift Keys
EB4B: C9 03     CMP #$03
EB4D: D0 15     BNE $EB64
EB4F: CD 8E 02  CMP $028E     ; Last Shift Key used for debouncing
EB52: F0 EE     BEQ $EB42     ; Process Key Image
EB54: AD 91 02  LDA $0291     ; Flag: Upper/Lower Case change
EB57: 30 1D     BMI $EB76
EB59: AD 18 D0  LDA $D018     ; VIC: Memory Control Register
EB5C: 49 02     EOR #$02
EB5E: 8D 18 D0  STA $D018     ; VIC: Memory Control Register
EB61: 4C 76 EB  JMP $EB76

Jump from $EB4D:

EB64: 0A        ASL
EB65: C9 08     CMP #$08
EB67: 90 02     BCC $EB6B
EB69: A9 06     LDA #$06

Jump from $EB67:

EB6B: AA        TAX
EB6C: BD 79 EB  LDA $EB79,X   ; Pointers to Keyboard decoding tables
EB6F: 85 F5     STA $F5       ; Vector: Current Keyboard decoding Table
EB71: BD 7A EB  LDA $EB7A,X   ; Pointers to Keyboard decoding tables
EB74: 85 F6     STA $F6       ; Vector: Current Keyboard decoding Table

Jump from $EB57, $EB61:

EB76: 4C E0 EA  JMP $EAE0     ; Process Key Image



 $EB79/60281:   Pointers to Keyboard decoding tables

EB79: 81 EB C2 EB 03 EC 78 EC    $EB81,$EBC2,$EC03,$EC78


Kernal-Reference:

 LDA $EB79,X : $EB6C

 LDA $EB7A,X : $EB71


 $EB81/60289:   Keyboard 1 -- Unshifted

EB81: 14 0D 1D 88 85 86 87 11
EB89: 33 57 41 34 5A 53 45 01
EB91: 35 52 44 36 43 46 54 58
EB99: 37 59 47 38 42 48 55 56
EBA1: 39 49 4A 30 4D 4B 4F 4E
EBA9: 2B 50 4C 2D 2E 3A 40 2C
EBB1: 5C 2A 3B 13 01 3D 5E 2F
EBB9: 31 5F 04 32 20 02 51 03
EBC1: FF



 $EBC2/60354:   Keyboard 2 -- Shifted

EBC2: 94 8D 9D 8C 89 8A 8B 91
EBCA: 23 D7 C1 24 DA D3 C5 01
EBD2: 25 D2 C4 26 C3 C6 D4 D8
EBDA: 27 D9 C7 28 C2 C8 D5 D6
EBE2: 29 C9 CA 30 CD CB CF CE
EBEA: DB D0 CC DD 3E 5B BA 3C
EBF2: A9 C0 5D 93 01 3D DE 3F
EBFA: 21 5F 04 22 A0 02 D1 83
EC02: FF



 $EC03/60419:   Keyboard 3 -- Commodore

EC03: 94 8D 9D 8C 89 8A 8B 91
EC0B: 96 B3 B0 97 AD AE B1 01
EC13: 98 B2 AC 99 BC BB A3 BD
EC1B: 9A B7 A5 9B BF B4 B8 BE
EC23: 29 A2 B5 30 A7 A1 B9 AA
EC2B: A6 AF B6 DC 3E 5B A4 3C
EC33: A8 DF 5D 93 01 3D DE 3F
EC3B: 81 5F 04 95 A0 02 AB 83
EC43: FF



 $EC44/60484:   Graphics/Text Control

Jump from $E7D1:

EC44: C9 0E     CMP #$0E
EC46: D0 07     BNE $EC4F
EC48: AD 18 D0  LDA $D018     ; VIC: Memory Control Register
EC4B: 09 02     ORA #$02
EC4D: D0 09     BNE $EC58

Jump from $EC46, $E879:

EC4F: C9 8E     CMP #$8E
EC51: D0 0B     BNE $EC5E
EC53: AD 18 D0  LDA $D018     ; VIC: Memory Control Register
EC56: 29 FD     AND #$FD

Jump from $EC4D:

EC58: 8D 18 D0  STA $D018     ; VIC: Memory Control Register

Jump from $EC6B:

EC5B: 4C A8 E6  JMP $E6A8     ; Set Up Screen Print

Jump from $EC51:

EC5E: C9 08     CMP #$08
EC60: D0 07     BNE $EC69
EC62: A9 80     LDA #$80
EC64: 0D 91 02  ORA $0291     ; Flag: Upper/Lower Case change
EC67: 30 09     BMI $EC72

Jump from $EC60:

EC69: C9 09     CMP #$09
EC6B: D0 EE     BNE $EC5B
EC6D: A9 7F     LDA #$7F
EC6F: 2D 91 02  AND $0291     ; Flag: Upper/Lower Case change

Jump from $EC67:

EC72: 8D 91 02  STA $0291     ; Flag: Upper/Lower Case change
EC75: 4C A8 E6  JMP $E6A8     ; Set Up Screen Print



 $EC78/60536:   Keyboard 4 -- Control

EC78: FF FF FF FF FF FF FF FF
EC80: 1C 17 01 9F 1A 13 05 FF
EC88: 9C 12 04 1E 03 06 14 18
EC90: 1F 19 07 9E 02 08 15 16
EC98: 12 09 0A 92 0D 0B 0F 0E
ECA0: FF 10 0C FF FF 1B 00 FF
ECA8: 1C FF 1D FF FF 1F 1E FF
ECB0: 90 06 FF 05 FF FF 11 FF
ECB8: FF


Kernal-Reference:

 LDA $ECB8,X : $E5AA


 $ECB9/60601:   Video Chip Setup Table

ECB9: 00 00 00 00 00 00 00 00
ECC1: 00 00 00 00 00 00 00 00
ECC9: 00 9B 37 00 00 00 08 00
ECD1: 14 0F 00 00 00 00 00 00
ECD9: 0E 06 01 02 03 04 00 01
ECE1: 02 03 04 05 06 07

* SX64:
ECD9: 03 01


Kernal-Reference:

 LDA $ECE6,X : $E5F3


 $ECE7/60647:   Shift-Run Equivalent

ECE7: 4C 4F 41 44 0D 52 55 4E    'LOAD{CR}RUN'
ECEF: 0D                         '{CR}'


Kernal-Reference:

 LDA $ECEF,X : $E99A


 $ECF0/60656:   Low Byte Screen Line Addresses

ECF0: 00 28 50 78 A0 C8 F0 18
ECF8: 40 68 90 B8 E0 08 30 58
ED00: 80 A8 D0 F8 20 48 70 98
ED08: C0


Kernal-Reference:

 LDA $ECF0,X : $E9F0

 LDA $ECF1,X : $E907


 $ED09/60681:   Send TALK Command on Serial Bus

Jump from $F238, $F4CD, $FFB4:

ED09: 09 40     ORA #$40
ED0B: 2C        .BYTE $2C



 $ED0C/60684:   Send LISTEN Command on Serial Bus

Jump from $F27A, $F3E3, $F60D, $F648, $FFB1:

ED0C: 09 20     ORA #$20
ED0E: 20 A4 F0  JSR $F0A4     ; Serial Bus Idle

Jump from $EE00:

ED11: 48        PHA
ED12: 24 94     BIT $94       ; Flag: Serial Bus - Output Character buffered
ED14: 10 0A     BPL $ED20
ED16: 38        SEC
ED17: 66 A3     ROR $A3       ; Serial Bus EOI (End Of Input) Flag
ED19: 20 40 ED  JSR $ED40     ; Send Data On Serial Bus
ED1C: 46 94     LSR $94       ; Flag: Serial Bus - Output Character buffered
ED1E: 46 A3     LSR $A3       ; Serial Bus EOI (End Of Input) Flag

Jump from $ED14:

ED20: 68        PLA
ED21: 85 95     STA $95       ; Buffered Character for Serial Bus
ED23: 78        SEI
ED24: 20 97 EE  JSR $EE97     ; Serial Output 1
ED27: C9 3F     CMP #$3F
ED29: D0 03     BNE $ED2E
ED2B: 20 85 EE  JSR $EE85     ; Serial Clock On

Jump from $ED29:

ED2E: AD 00 DD  LDA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
ED31: 09 08     ORA #$08
ED33: 8D 00 DD  STA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)

Jump from $EDBB, $EDC9:

ED36: 78        SEI
ED37: 20 8E EE  JSR $EE8E     ; Serial Clock Off
ED3A: 20 97 EE  JSR $EE97     ; Serial Output 1
ED3D: 20 B3 EE  JSR $EEB3     ; Delay 1 ms



 $ED40/60736:   Send Data On Serial Bus

Jump from $ED19, $EDE7:

ED40: 78        SEI
ED41: 20 97 EE  JSR $EE97     ; Serial Output 1
ED44: 20 A9 EE  JSR $EEA9     ; Get Serial Data And Clock In
ED47: B0 64     BCS $EDAD     ; Flag Errors: Status #80 - DEVICE NOT PRESENT
ED49: 20 85 EE  JSR $EE85     ; Serial Clock On
ED4C: 24 A3     BIT $A3       ; Serial Bus EOI (End Of Input) Flag
ED4E: 10 0A     BPL $ED5A

Jump from $ED53:

ED50: 20 A9 EE  JSR $EEA9     ; Get Serial Data And Clock In
ED53: 90 FB     BCC $ED50

Jump from $ED58:

ED55: 20 A9 EE  JSR $EEA9     ; Get Serial Data And Clock In
ED58: B0 FB     BCS $ED55

Jump from $ED4E, $ED5D:

ED5A: 20 A9 EE  JSR $EEA9     ; Get Serial Data And Clock In
ED5D: 90 FB     BCC $ED5A
ED5F: 20 8E EE  JSR $EE8E     ; Serial Clock Off
ED62: A9 08     LDA #$08
ED64: 85 A5     STA $A5       ; Tape Synchronising count down

Jump from $ED6C, $ED90:

ED66: AD 00 DD  LDA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
ED69: CD 00 DD  CMP $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
ED6C: D0 F8     BNE $ED66
ED6E: 0A        ASL
ED6F: 90 3F     BCC $EDB0     ; Flag Errors: Status #03 - WRITE TIMEOUT
ED71: 66 95     ROR $95       ; Buffered Character for Serial Bus
ED73: B0 05     BCS $ED7A
ED75: 20 A0 EE  JSR $EEA0     ; Serial Output 0
ED78: D0 03     BNE $ED7D

Jump from $ED73:

ED7A: 20 97 EE  JSR $EE97     ; Serial Output 1

Jump from $ED78:

ED7D: 20 85 EE  JSR $EE85     ; Serial Clock On
ED80: EA        NOP
ED81: EA        NOP
ED82: EA        NOP
ED83: EA        NOP
ED84: AD 00 DD  LDA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
ED87: 29 DF     AND #$DF
ED89: 09 10     ORA #$10
ED8B: 8D 00 DD  STA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
ED8E: C6 A5     DEC $A5       ; Tape Synchronising count down
ED90: D0 D4     BNE $ED66
ED92: A9 04     LDA #$04
ED94: 8D 07 DC  STA $DC07     ; CIA1: Timer B High-Byte (Tape, Serial Port)
ED97: A9 19     LDA #$19
ED99: 8D 0F DC  STA $DC0F     ; CIA1: Control Register B
ED9C: AD 0D DC  LDA $DC0D     ; CIA1: Interrupt (IRQ) Control Register

Jump from $EDA9:

ED9F: AD 0D DC  LDA $DC0D     ; CIA1: Interrupt (IRQ) Control Register
EDA2: 29 02     AND #$02
EDA4: D0 0A     BNE $EDB0     ; Flag Errors: Status #03 - WRITE TIMEOUT
EDA6: 20 A9 EE  JSR $EEA9     ; Get Serial Data And Clock In
EDA9: B0 F4     BCS $ED9F
EDAB: 58        CLI
EDAC: 60        RTS



 $EDAD/60845:   Flag Errors: Status #80 - DEVICE NOT PRESENT

Jump from $ED47:

EDAD: A9 80     LDA #$80
EDAF: 2C        .BYTE $2C



 $EDB0/60848:   Flag Errors: Status #03 - WRITE TIMEOUT

Jump from $ED6F, $EDA4:

EDB0: A9 03     LDA #$03

Jump from $EE44:

EDB2: 20 1C FE  JSR $FE1C     ; Control OS Messages
EDB5: 58        CLI
EDB6: 18        CLC
EDB7: 90 4A     BCC $EE03     ; Send UNLISTEN



 $EDB9/60857:   Send LISTEN Secondary Address

Jump from $F286, $F3EA, $F612, $F651, $FF93:

EDB9: 85 95     STA $95       ; Buffered Character for Serial Bus
EDBB: 20 36 ED  JSR $ED36     ; Send LISTEN Command on Serial Bus



 $EDBE/60862:   Clear ATN

Jump from $EDD0, $EE03, $F281:

EDBE: AD 00 DD  LDA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
EDC1: 29 F7     AND #$F7
EDC3: 8D 00 DD  STA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
EDC6: 60        RTS



 $EDC7/60871:   Send TALK Secondary Address

Jump from $F245, $F4D2, $FF96:

EDC7: 85 95     STA $95       ; Buffered Character for Serial Bus
EDC9: 20 36 ED  JSR $ED36     ; Send LISTEN Command on Serial Bus



 $EDCC/60876:   Wait For Clock

Jump from $F23F:

EDCC: 78        SEI
EDCD: 20 A0 EE  JSR $EEA0     ; Serial Output 0
EDD0: 20 BE ED  JSR $EDBE     ; Clear ATN
EDD3: 20 85 EE  JSR $EE85     ; Serial Clock On

Jump from $EDD9:

EDD6: 20 A9 EE  JSR $EEA9     ; Get Serial Data And Clock In
EDD9: 30 FB     BMI $EDD6
EDDB: 58        CLI
EDDC: 60        RTS



 $EDDD/60893:   Send Serial Deferred

Jump from $F1D8, $F3FE, $F61C, $F621, $F62B, $FFA8:

EDDD: 24 94     BIT $94       ; Flag: Serial Bus - Output Character buffered
EDDF: 30 05     BMI $EDE6
EDE1: 38        SEC
EDE2: 66 94     ROR $94       ; Flag: Serial Bus - Output Character buffered
EDE4: D0 05     BNE $EDEB

Jump from $EDDF:

EDE6: 48        PHA
EDE7: 20 40 ED  JSR $ED40     ; Send Data On Serial Bus
EDEA: 68        PLA

Jump from $EDE4:

EDEB: 85 95     STA $95       ; Buffered Character for Serial Bus
EDED: 18        CLC
EDEE: 60        RTS



 $EDEF/60911:   Send UNTALK

Jump from $F340, $F528, $FFAB:

EDEF: 78        SEI
EDF0: 20 8E EE  JSR $EE8E     ; Serial Clock Off
EDF3: AD 00 DD  LDA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
EDF6: 09 08     ORA #$08
EDF8: 8D 00 DD  STA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
EDFB: A9 5F     LDA #$5F
EDFD: 2C        .BYTE $2C



 $EDFE/60926:   Send UNLISTEN

Jump from $F339, $F63F, $F654, $FFAE:

EDFE: A9 3F     LDA #$3F
EE00: 20 11 ED  JSR $ED11     ; Send LISTEN Command on Serial Bus

Jump from $EDB7:

EE03: 20 BE ED  JSR $EDBE     ; Clear ATN

Jump from $EE7D:

EE06: 8A        TXA
EE07: A2 0A     LDX #$0A

Jump from $EE0A:

EE09: CA        DEX
EE0A: D0 FD     BNE $EE09
EE0C: AA        TAX
EE0D: 20 85 EE  JSR $EE85     ; Serial Clock On
EE10: 4C 97 EE  JMP $EE97     ; Serial Output 1



 $EE13/60947:   Receive From Serial Bus

Jump from $F1B5, $F4D5, $F4E0, $F501, $FFA5:

EE13: 78        SEI
EE14: A9 00     LDA #$00
EE16: 85 A5     STA $A5       ; Tape Synchronising count down
EE18: 20 85 EE  JSR $EE85     ; Serial Clock On

Jump from $EE1E:

EE1B: 20 A9 EE  JSR $EEA9     ; Get Serial Data And Clock In
EE1E: 10 FB     BPL $EE1B

Jump from $EE54:

EE20: A9 01     LDA #$01
EE22: 8D 07 DC  STA $DC07     ; CIA1: Timer B High-Byte (Tape, Serial Port)
EE25: A9 19     LDA #$19
EE27: 8D 0F DC  STA $DC0F     ; CIA1: Control Register B
EE2A: 20 97 EE  JSR $EE97     ; Serial Output 1
EE2D: AD 0D DC  LDA $DC0D     ; CIA1: Interrupt (IRQ) Control Register

Jump from $EE3A:

EE30: AD 0D DC  LDA $DC0D     ; CIA1: Interrupt (IRQ) Control Register
EE33: 29 02     AND #$02
EE35: D0 07     BNE $EE3E
EE37: 20 A9 EE  JSR $EEA9     ; Get Serial Data And Clock In
EE3A: 30 F4     BMI $EE30
EE3C: 10 18     BPL $EE56

Jump from $EE35:

EE3E: A5 A5     LDA $A5       ; Tape Synchronising count down
EE40: F0 05     BEQ $EE47
EE42: A9 02     LDA #$02
EE44: 4C B2 ED  JMP $EDB2     ; Flag Errors: Status #03 - WRITE TIMEOUT

Jump from $EE40:

EE47: 20 A0 EE  JSR $EEA0     ; Serial Output 0
EE4A: 20 85 EE  JSR $EE85     ; Serial Clock On
EE4D: A9 40     LDA #$40
EE4F: 20 1C FE  JSR $FE1C     ; Control OS Messages
EE52: E6 A5     INC $A5       ; Tape Synchronising count down
EE54: D0 CA     BNE $EE20

Jump from $EE3C:

EE56: A9 08     LDA #$08
EE58: 85 A5     STA $A5       ; Tape Synchronising count down

Jump from $EE60, $EE63, $EE74:

EE5A: AD 00 DD  LDA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
EE5D: CD 00 DD  CMP $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
EE60: D0 F8     BNE $EE5A
EE62: 0A        ASL
EE63: 10 F5     BPL $EE5A
EE65: 66 A4     ROR $A4       ; Serial Bus shift Counter

Jump from $EE6D, $EE70:

EE67: AD 00 DD  LDA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
EE6A: CD 00 DD  CMP $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
EE6D: D0 F8     BNE $EE67
EE6F: 0A        ASL
EE70: 30 F5     BMI $EE67
EE72: C6 A5     DEC $A5       ; Tape Synchronising count down
EE74: D0 E4     BNE $EE5A
EE76: 20 A0 EE  JSR $EEA0     ; Serial Output 0
EE79: 24 90     BIT $90       ; Kernal I/O Status Word ST
EE7B: 50 03     BVC $EE80
EE7D: 20 06 EE  JSR $EE06     ; Send UNLISTEN

Jump from $EE7B:

EE80: A5 A4     LDA $A4       ; Serial Bus shift Counter
EE82: 58        CLI
EE83: 18        CLC
EE84: 60        RTS



 $EE85/61061:   Serial Clock On

Jump from $ED2B, $ED49, $ED7D, $EDD3, $EE0D, $EE18, $EE4A:

EE85: AD 00 DD  LDA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
EE88: 29 EF     AND #$EF
EE8A: 8D 00 DD  STA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
EE8D: 60        RTS



 $EE8E/61070:   Serial Clock Off

Jump from $ED37, $ED5F, $EDF0, $FF7D:

EE8E: AD 00 DD  LDA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
EE91: 09 10     ORA #$10
EE93: 8D 00 DD  STA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
EE96: 60        RTS



 $EE97/61079:   Serial Output 1

Jump from $ED24, $ED3A, $ED41, $ED7A, $EE10, $EE2A:

EE97: AD 00 DD  LDA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
EE9A: 29 DF     AND #$DF
EE9C: 8D 00 DD  STA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
EE9F: 60        RTS



 $EEA0/61088:   Serial Output 0

Jump from $ED75, $EDCD, $EE47, $EE76:

EEA0: AD 00 DD  LDA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
EEA3: 09 20     ORA #$20
EEA5: 8D 00 DD  STA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
EEA8: 60        RTS



 $EEA9/61097:   Get Serial Data And Clock In

Jump from $EEAF, $ED44, $ED50, $ED55, $ED5A, $EDA6, $EDD6, $EE1B, $EE37:

EEA9: AD 00 DD  LDA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
EEAC: CD 00 DD  CMP $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
EEAF: D0 F8     BNE $EEA9
EEB1: 0A        ASL
EEB2: 60        RTS



 $EEB3/61107:   Delay 1 ms

Jump from $ED3D:

EEB3: 8A        TXA
EEB4: A2 B8     LDX #$B8

Jump from $EEB7:

EEB6: CA        DEX
EEB7: D0 FD     BNE $EEB6
EEB9: AA        TAX
EEBA: 60        RTS



 $EEBB/61115:   RS232 Send

Jump from $FE9D:

EEBB: A5 B4     LDA $B4       ; RS232 Write bit count/Tape Read timing Flag
EEBD: F0 47     BEQ $EF06     ; Send New RS232 Byte
EEBF: 30 3F     BMI $EF00
EEC1: 46 B6     LSR $B6       ; RS232 Output Byte Buffer/Tape Read Error Flag
EEC3: A2 00     LDX #$00
EEC5: 90 01     BCC $EEC8
EEC7: CA        DEX

Jump from $EEC5:

EEC8: 8A        TXA
EEC9: 45 BD     EOR $BD       ; RS232 Output Parity/Tape Byte temporary
EECB: 85 BD     STA $BD       ; RS232 Output Parity/Tape Byte temporary
EECD: C6 B4     DEC $B4       ; RS232 Write bit count/Tape Read timing Flag
EECF: F0 06     BEQ $EED7

Jump from $EEEC, $EEF0, $EF04:

EED1: 8A        TXA
EED2: 29 04     AND #$04
EED4: 85 B5     STA $B5       ; RS232 Next Bit to send/Tape Read - End of Tape
EED6: 60        RTS

Jump from $EECF:

EED7: A9 20     LDA #$20
EED9: 2C 94 02  BIT $0294     ; RS232 Pseudo 6551 command Register Image
EEDC: F0 14     BEQ $EEF2
EEDE: 30 1C     BMI $EEFC
EEE0: 70 14     BVS $EEF6
EEE2: A5 BD     LDA $BD       ; RS232 Output Parity/Tape Byte temporary
EEE4: D0 01     BNE $EEE7

Jump from $EEF4, $EEFA, $EEFE:

EEE6: CA        DEX

Jump from $EEE4, $EEF8, $EEFC:

EEE7: C6 B4     DEC $B4       ; RS232 Write bit count/Tape Read timing Flag
EEE9: AD 93 02  LDA $0293     ; RS232 Pseudo 6551 control Register Image
EEEC: 10 E3     BPL $EED1
EEEE: C6 B4     DEC $B4       ; RS232 Write bit count/Tape Read timing Flag
EEF0: D0 DF     BNE $EED1

Jump from $EEDC:

EEF2: E6 B4     INC $B4       ; RS232 Write bit count/Tape Read timing Flag
EEF4: D0 F0     BNE $EEE6

Jump from $EEE0:

EEF6: A5 BD     LDA $BD       ; RS232 Output Parity/Tape Byte temporary
EEF8: F0 ED     BEQ $EEE7
EEFA: D0 EA     BNE $EEE6

Jump from $EEDE:

EEFC: 70 E9     BVS $EEE7
EEFE: 50 E6     BVC $EEE6

Jump from $EEBF:

EF00: E6 B4     INC $B4       ; RS232 Write bit count/Tape Read timing Flag
EF02: A2 FF     LDX #$FF
EF04: D0 CB     BNE $EED1



 $EF06/61190:   Send New RS232 Byte

Jump from $EEBD, $F044:

EF06: AD 94 02  LDA $0294     ; RS232 Pseudo 6551 command Register Image
EF09: 4A        LSR
EF0A: 90 07     BCC $EF13
EF0C: 2C 01 DD  BIT $DD01     ; CIA2: Data Port B (User Port, RS232)
EF0F: 10 1D     BPL $EF2E     ; 'No DSR' / 'No CTS' Error
EF11: 50 1E     BVC $EF31     ; 'No DSR' / 'No CTS' Error

Jump from $EF0A:

EF13: A9 00     LDA #$00
EF15: 85 BD     STA $BD       ; RS232 Output Parity/Tape Byte temporary
EF17: 85 B5     STA $B5       ; RS232 Next Bit to send/Tape Read - End of Tape
EF19: AE 98 02  LDX $0298     ; RS232 Number of Bits left to send
EF1C: 86 B4     STX $B4       ; RS232 Write bit count/Tape Read timing Flag
EF1E: AC 9D 02  LDY $029D     ; RS232 Pointer: High Byte of Output Buffer
EF21: CC 9E 02  CPY $029E     ; RS232 Index to End of Output Buffer
EF24: F0 13     BEQ $EF39     ; Disable Timer
EF26: B1 F9     LDA ($F9),Y   ; RS232 Output Buffer Pointer
EF28: 85 B6     STA $B6       ; RS232 Output Byte Buffer/Tape Read Error Flag
EF2A: EE 9D 02  INC $029D     ; RS232 Pointer: High Byte of Output Buffer
EF2D: 60        RTS



 $EF2E/61230:   'No DSR' / 'No CTS' Error

Jump from $EF0F:

EF2E: A9 40     LDA #$40
EF30: 2C        .BYTE $2C

Jump from $EF11:

EF31: A9 10     LDA #$10
EF33: 0D 97 02  ORA $0297     ; RS232 Pseudo 6551 Status Register Image
EF36: 8D 97 02  STA $0297     ; RS232 Pseudo 6551 Status Register Image



 $EF39/61241:   Disable Timer

Jump from $EF24:

EF39: A9 01     LDA #$01

Jump from $EF8D, $F041, $F07A:

EF3B: 8D 0D DD  STA $DD0D     ; CIA2: Interrupt (NMI) Control Register
EF3E: 4D A1 02  EOR $02A1     ; RS232 Enables
EF41: 09 80     ORA #$80
EF43: 8D A1 02  STA $02A1     ; RS232 Enables
EF46: 8D 0D DD  STA $DD0D     ; CIA2: Interrupt (NMI) Control Register
EF49: 60        RTS



 $EF4A/61258:   Compute Bit Count

Jump from $F41D:

EF4A: A2 09     LDX #$09
EF4C: A9 20     LDA #$20
EF4E: 2C 93 02  BIT $0293     ; RS232 Pseudo 6551 control Register Image
EF51: F0 01     BEQ $EF54
EF53: CA        DEX

Jump from $EF51:

EF54: 50 02     BVC $EF58
EF56: CA        DEX
EF57: CA        DEX

Jump from $EF54:

EF58: 60        RTS



 $EF59/61273:   RS232 Receive

Jump from $FF04:

EF59: A6 A9     LDX $A9       ; RS232 Flag: Start Bit check/Tape temporary
EF5B: D0 33     BNE $EF90     ; Process RS232 Byte
EF5D: C6 A8     DEC $A8       ; RS232 Input Bit count/Tape temporary
EF5F: F0 36     BEQ $EF97     ; Process RS232 Byte
EF61: 30 0D     BMI $EF70
EF63: A5 A7     LDA $A7       ; Tape temporary
EF65: 45 AB     EOR $AB       ; RS232 Input parity/Tape temporary
EF67: 85 AB     STA $AB       ; RS232 Input parity/Tape temporary
EF69: 46 A7     LSR $A7       ; Tape temporary
EF6B: 66 AA     ROR $AA       ; RS232 Input Byte Buffer/Tape temporary

Jump from $EF7C, $EFBA, $EFC2, $EFC5:

EF6D: 60        RTS

Jump from $EFB8:

EF6E: C6 A8     DEC $A8       ; RS232 Input Bit count/Tape temporary

Jump from $EF61:

EF70: A5 A7     LDA $A7       ; Tape temporary
EF72: F0 67     BEQ $EFDB     ; Process RS232 Byte
EF74: AD 93 02  LDA $0293     ; RS232 Pseudo 6551 control Register Image
EF77: 0A        ASL
EF78: A9 01     LDA #$01
EF7A: 65 A8     ADC $A8       ; RS232 Input Bit count/Tape temporary
EF7C: D0 EF     BNE $EF6D



 $EF7E/61310:   Set Up To Receive

Jump from $EF92, $EFD8:

EF7E: A9 90     LDA #$90
EF80: 8D 0D DD  STA $DD0D     ; CIA2: Interrupt (NMI) Control Register
EF83: 0D A1 02  ORA $02A1     ; RS232 Enables
EF86: 8D A1 02  STA $02A1     ; RS232 Enables
EF89: 85 A9     STA $A9       ; RS232 Flag: Start Bit check/Tape temporary
EF8B: A9 02     LDA #$02
EF8D: 4C 3B EF  JMP $EF3B     ; Disable Timer



 $EF90/61328:   Process RS232 Byte

Jump from $EF5B:

EF90: A5 A7     LDA $A7       ; Tape temporary
EF92: D0 EA     BNE $EF7E     ; Set Up To Receive
EF94: 4C D3 E4  JMP $E4D3     ; Unused Bytes For Future Patches

* Old KERNAL:
EF94: 85 A9     STA $A9       ; RS232 Flag: Start Bit check/Tape temporary
EF96: 60        RTS

Jump from $EF5F:

EF97: AC 9B 02  LDY $029B     ; RS232 Index to End of Input Buffer
EF9A: C8        INY
EF9B: CC 9C 02  CPY $029C     ; RS232 Pointer: High Byte of Input Buffer
EF9E: F0 2A     BEQ $EFCA
EFA0: 8C 9B 02  STY $029B     ; RS232 Index to End of Input Buffer
EFA3: 88        DEY
EFA4: A5 AA     LDA $AA       ; RS232 Input Byte Buffer/Tape temporary
EFA6: AE 98 02  LDX $0298     ; RS232 Number of Bits left to send

Jump from $EFAF:

EFA9: E0 09     CPX #$09
EFAB: F0 04     BEQ $EFB1
EFAD: 4A        LSR
EFAE: E8        INX
EFAF: D0 F8     BNE $EFA9

Jump from $EFAB:

EFB1: 91 F7     STA ($F7),Y   ; RS232 Input Buffer Pointer
EFB3: A9 20     LDA #$20
EFB5: 2C 94 02  BIT $0294     ; RS232 Pseudo 6551 command Register Image
EFB8: F0 B4     BEQ $EF6E     ; RS232 Receive
EFBA: 30 B1     BMI $EF6D     ; RS232 Receive
EFBC: A5 A7     LDA $A7       ; Tape temporary
EFBE: 45 AB     EOR $AB       ; RS232 Input parity/Tape temporary
EFC0: F0 03     BEQ $EFC5
EFC2: 70 A9     BVS $EF6D     ; RS232 Receive
EFC4: 2C        .BYTE $2C

Jump from $EFC0:

EFC5: 50 A6     BVC $EF6D     ; RS232 Receive
EFC7: A9 01     LDA #$01
EFC9: 2C        .BYTE $2C

Jump from $EF9E:

EFCA: A9 04     LDA #$04
EFCC: 2C        .BYTE $2C

Jump from $EFDF:

EFCD: A9 80     LDA #$80
EFCF: 2C        .BYTE $2C

Jump from $EFDD:

EFD0: A9 02     LDA #$02
EFD2: 0D 97 02  ORA $0297     ; RS232 Pseudo 6551 Status Register Image
EFD5: 8D 97 02  STA $0297     ; RS232 Pseudo 6551 Status Register Image
EFD8: 4C 7E EF  JMP $EF7E     ; Set Up To Receive

Jump from $EF72:

EFDB: A5 AA     LDA $AA       ; RS232 Input Byte Buffer/Tape temporary
EFDD: D0 F1     BNE $EFD0
EFDF: F0 EC     BEQ $EFCD



 $EFE1/61409:   Submit to RS232

Jump from $F26C:

EFE1: 85 9A     STA $9A       ; Default Output Device (3)
EFE3: AD 94 02  LDA $0294     ; RS232 Pseudo 6551 command Register Image
EFE6: 4A        LSR
EFE7: 90 29     BCC $F012     ; No DSR (Data Set Ready) Error
EFE9: A9 02     LDA #$02
EFEB: 2C 01 DD  BIT $DD01     ; CIA2: Data Port B (User Port, RS232)
EFEE: 10 1D     BPL $F00D     ; No DSR (Data Set Ready) Error
EFF0: D0 20     BNE $F012     ; No DSR (Data Set Ready) Error

Jump from $EFF7:

EFF2: AD A1 02  LDA $02A1     ; RS232 Enables
EFF5: 29 02     AND #$02
EFF7: D0 F9     BNE $EFF2

Jump from $EFFC:

EFF9: 2C 01 DD  BIT $DD01     ; CIA2: Data Port B (User Port, RS232)
EFFC: 70 FB     BVS $EFF9
EFFE: AD 01 DD  LDA $DD01     ; CIA2: Data Port B (User Port, RS232)
F001: 09 02     ORA #$02
F003: 8D 01 DD  STA $DD01     ; CIA2: Data Port B (User Port, RS232)

Jump from $F00B:

F006: 2C 01 DD  BIT $DD01     ; CIA2: Data Port B (User Port, RS232)
F009: 70 07     BVS $F012     ; No DSR (Data Set Ready) Error
F00B: 30 F9     BMI $F006



 $F00D/61453:   No DSR (Data Set Ready) Error

Jump from $EFEE, $F05E, $F459:

F00D: A9 40     LDA #$40
F00F: 8D 97 02  STA $0297     ; RS232 Pseudo 6551 Status Register Image

Jump from $EFE7, $EFF0, $F009:

F012: 18        CLC
F013: 60        RTS

Jump from $F01E:

F014: 20 28 F0  JSR $F028     ; Send to RS232 Buffer



 $F017/61463:   Send to RS232 Buffer

Jump from $F208:

F017: AC 9E 02  LDY $029E     ; RS232 Index to End of Output Buffer
F01A: C8        INY
F01B: CC 9D 02  CPY $029D     ; RS232 Pointer: High Byte of Output Buffer
F01E: F0 F4     BEQ $F014     ; No DSR (Data Set Ready) Error
F020: 8C 9E 02  STY $029E     ; RS232 Index to End of Output Buffer
F023: 88        DEY
F024: A5 9E     LDA $9E       ; Tape Error log pass 1
F026: 91 F9     STA ($F9),Y   ; RS232 Output Buffer Pointer

Jump from $F014:

F028: AD A1 02  LDA $02A1     ; RS232 Enables
F02B: 4A        LSR
F02C: B0 1E     BCS $F04C
F02E: A9 10     LDA #$10
F030: 8D 0E DD  STA $DD0E     ; CIA2: Control Register A
F033: AD 99 02  LDA $0299     ; RS232 Baud Rate; Full Bit time microseconds
F036: 8D 04 DD  STA $DD04     ; CIA2: Timer A Low-Byte  (RS232)
F039: AD 9A 02  LDA $029A     ; RS232 Baud Rate; Full Bit time microseconds
F03C: 8D 05 DD  STA $DD05     ; CIA2: Timer A High-Byte (RS232)
F03F: A9 81     LDA #$81
F041: 20 3B EF  JSR $EF3B     ; Disable Timer
F044: 20 06 EF  JSR $EF06     ; Send New RS232 Byte
F047: A9 11     LDA #$11
F049: 8D 0E DD  STA $DD0E     ; CIA2: Control Register A

Jump from $F02C:

F04C: 60        RTS



 $F04D/61517:   Input From RS232

Jump from $F227:

F04D: 85 99     STA $99       ; Default Input Device (0)
F04F: AD 94 02  LDA $0294     ; RS232 Pseudo 6551 command Register Image
F052: 4A        LSR
F053: 90 28     BCC $F07D
F055: 29 08     AND #$08
F057: F0 24     BEQ $F07D
F059: A9 02     LDA #$02
F05B: 2C 01 DD  BIT $DD01     ; CIA2: Data Port B (User Port, RS232)
F05E: 10 AD     BPL $F00D     ; No DSR (Data Set Ready) Error
F060: F0 22     BEQ $F084

Jump from $F066:

F062: AD A1 02  LDA $02A1     ; RS232 Enables
F065: 4A        LSR
F066: B0 FA     BCS $F062
F068: AD 01 DD  LDA $DD01     ; CIA2: Data Port B (User Port, RS232)
F06B: 29 FD     AND #$FD
F06D: 8D 01 DD  STA $DD01     ; CIA2: Data Port B (User Port, RS232)

Jump from $F075:

F070: AD 01 DD  LDA $DD01     ; CIA2: Data Port B (User Port, RS232)
F073: 29 04     AND #$04
F075: F0 F9     BEQ $F070

Jump from $F082:

F077: A9 90     LDA #$90
F079: 18        CLC
F07A: 4C 3B EF  JMP $EF3B     ; Disable Timer

Jump from $F053, $F057:

F07D: AD A1 02  LDA $02A1     ; RS232 Enables
F080: 29 12     AND #$12
F082: F0 F3     BEQ $F077

Jump from $F060:

F084: 18        CLC
F085: 60        RTS



 $F086/61574:   Get From RS232

Jump from $F150:

F086: AD 97 02  LDA $0297     ; RS232 Pseudo 6551 Status Register Image
F089: AC 9C 02  LDY $029C     ; RS232 Pointer: High Byte of Input Buffer
F08C: CC 9B 02  CPY $029B     ; RS232 Index to End of Input Buffer
F08F: F0 0B     BEQ $F09C
F091: 29 F7     AND #$F7
F093: 8D 97 02  STA $0297     ; RS232 Pseudo 6551 Status Register Image
F096: B1 F7     LDA ($F7),Y   ; RS232 Input Buffer Pointer
F098: EE 9C 02  INC $029C     ; RS232 Pointer: High Byte of Input Buffer
F09B: 60        RTS

Jump from $F08F:

F09C: 09 08     ORA #$08
F09E: 8D 97 02  STA $0297     ; RS232 Pseudo 6551 Status Register Image
F0A1: A9 00     LDA #$00
F0A3: 60        RTS



 $F0A4/61604:   Serial Bus Idle

Jump from $ED0E, $F88A:

F0A4: 48        PHA
F0A5: AD A1 02  LDA $02A1     ; RS232 Enables
F0A8: F0 11     BEQ $F0BB

Jump from $F0AF:

F0AA: AD A1 02  LDA $02A1     ; RS232 Enables
F0AD: 29 03     AND #$03
F0AF: D0 F9     BNE $F0AA
F0B1: A9 10     LDA #$10
F0B3: 8D 0D DD  STA $DD0D     ; CIA2: Interrupt (NMI) Control Register
F0B6: A9 00     LDA #$00
F0B8: 8D A1 02  STA $02A1     ; RS232 Enables

Jump from $F0A8:

F0BB: 68        PLA
F0BC: 60        RTS



 $F0BD/61629:   Table of Kernal I/O Messages

F0BD: 0D 49 2F 4F 20 45 52 52    '{CR}I/O ERR'
F0C5: 4F 52 20 A3 0D 53 45 41    'OR #, {CR}SEA'
F0CD: 52 43 48 49 4E 47 A0 46    'RCHING F'
F0D5: 4F 52 A0 0D 50 52 45 53    'OR {CR}PRES'
F0DD: 53 20 50 4C 41 59 20 4F    'S PLAY O'
F0E5: 4E 20 54 41 50 C5 50 52    'N TAPE, PR'
F0ED: 45 53 53 20 52 45 43 4F    'ESS RECO'
F0F5: 52 44 20 26 20 50 4C 41    'RD & PLA'
F0FD: 59 20 4F 4E 20 54 41 50    'Y ON TAP'
F105: C5 0D 4C 4F 41 44 49 4E    'E, {CR}LOADIN'
F10D: C7 0D 53 41 56 49 4E 47    'G, {CR}SAVING'
F115: A0 0D 56 45 52 49 46 59    ' {CR}VERIFY'
F11D: 49 4E C7 0D 46 4F 55 4E    'ING, {CR}FOUN'
F125: 44 A0 0D 4F 4B 8D          'D {CR}OK{CR},'

* SX64:
F0D5:          4C 4F 41 44 22       'LOAD"'
F0DD: 3A 2A 22 2C 38 0D 52 55    ':*",8{CR}RU'
F0E5: 4E 0D                      'N{CR}'


Kernal-Reference:

 LDA $F0BD,Y : $F12F


 $F12B/61739:   Print Message if Direct

Jump from $F5DA:

F12B: 24 9D     BIT $9D       ; Error-Mode-Flag
F12D: 10 0D     BPL $F13C     ; Print Message



 $F12F/61743:   Print Message

Jump from $F13A, $F5B5, $F5BE, $F695, $F71F, $F752, $F81E, $F82B:

F12F: B9 BD F0  LDA $F0BD,Y   ; Table of Kernal I/O Messages
F132: 08        PHP
F133: 29 7F     AND #$7F
F135: 20 D2 FF  JSR $FFD2     ; Output Vector, chrout
F138: C8        INY
F139: 28        PLP
F13A: 10 F3     BPL $F12F

Jump from $F12D:

F13C: 18        CLC
F13D: 60        RTS



 $F13E/61758:   Get a byte

F13E: A5 99     LDA $99       ; Default Input Device (0)
F140: D0 08     BNE $F14A
F142: A5 C6     LDA $C6       ; Number of Characters in Keyboard Buffer queue
F144: F0 0F     BEQ $F155
F146: 78        SEI
F147: 4C B4 E5  JMP $E5B4     ; Get Character From Keyboard Buffer

Jump from $F140:

F14A: C9 02     CMP #$02
F14C: D0 18     BNE $F166     ; Input a byte

Jump from $F1B8:

F14E: 84 97     STY $97       ; Storage of Y Register during RS232 fetch
F150: 20 86 F0  JSR $F086     ; Get From RS232
F153: A4 97     LDY $97       ; Storage of Y Register during RS232 fetch

Jump from $F144:

F155: 18        CLC
F156: 60        RTS



 $F157/61783:   Input a byte

F157: A5 99     LDA $99       ; Default Input Device (0)
F159: D0 0B     BNE $F166
F15B: A5 D3     LDA $D3       ; Cursor Column on current Line
F15D: 85 CA     STA $CA       ; Cursor X/Y position at start of Input
F15F: A5 D6     LDA $D6       ; Current Screen Line number of Cursor
F161: 85 C9     STA $C9       ; Cursor X/Y position at start of Input
F163: 4C 32 E6  JMP $E632     ; Input From Screen or Keyboard

Jump from $F159, $F14C:

F166: C9 03     CMP #$03
F168: D0 09     BNE $F173
F16A: 85 D0     STA $D0       ; Flag: Input from ...
F16C: A5 D5     LDA $D5       ; Current logical Line length: 39 or 79
F16E: 85 C8     STA $C8       ; Pointer: End of Line for Input
F170: 4C 32 E6  JMP $E632     ; Input From Screen or Keyboard

Jump from $F168:

F173: B0 38     BCS $F1AD     ; Get From Tape / Serial / RS232
F175: C9 02     CMP #$02
F177: F0 3F     BEQ $F1B8     ; Get From Tape / Serial / RS232
F179: 86 97     STX $97       ; Storage of Y Register during RS232 fetch
F17B: 20 99 F1  JSR $F199     ; Get From Tape / Serial / RS232
F17E: B0 16     BCS $F196
F180: 48        PHA
F181: 20 99 F1  JSR $F199     ; Get From Tape / Serial / RS232
F184: B0 0D     BCS $F193
F186: D0 05     BNE $F18D
F188: A9 40     LDA #$40
F18A: 20 1C FE  JSR $FE1C     ; Control OS Messages

Jump from $F186:

F18D: C6 A6     DEC $A6       ; Pointer: Tape I/O buffer
F18F: A6 97     LDX $97       ; Storage of Y Register during RS232 fetch
F191: 68        PLA
F192: 60        RTS

Jump from $F184:

F193: AA        TAX
F194: 68        PLA
F195: 8A        TXA

Jump from $F17E:

F196: A6 97     LDX $97       ; Storage of Y Register during RS232 fetch
F198: 60        RTS



 $F199/61849:   Get From Tape / Serial / RS232

Jump from $F1A7, $F17B, $F181:

F199: 20 0D F8  JSR $F80D     ; Bump Tape Pointer
F19C: D0 0B     BNE $F1A9
F19E: 20 41 F8  JSR $F841     ; Initiate Tape Read
F1A1: B0 11     BCS $F1B4
F1A3: A9 00     LDA #$00
F1A5: 85 A6     STA $A6       ; Pointer: Tape I/O buffer
F1A7: F0 F0     BEQ $F199

Jump from $F19C:

F1A9: B1 B2     LDA ($B2),Y   ; Pointer: Start Address of Tape Buffer
F1AB: 18        CLC
F1AC: 60        RTS

Jump from $F173:

F1AD: A5 90     LDA $90       ; Kernal I/O Status Word ST
F1AF: F0 04     BEQ $F1B5

Jump from $F1C6:

F1B1: A9 0D     LDA #$0D

Jump from $F1BF:

F1B3: 18        CLC

Jump from $F1A1, $F1BB:

F1B4: 60        RTS

Jump from $F1AF:

F1B5: 4C 13 EE  JMP $EE13     ; Receive From Serial Bus

Jump from $F1C8, $F177:

F1B8: 20 4E F1  JSR $F14E     ; Get a byte
F1BB: B0 F7     BCS $F1B4
F1BD: C9 00     CMP #$00
F1BF: D0 F2     BNE $F1B3
F1C1: AD 97 02  LDA $0297     ; RS232 Pseudo 6551 Status Register Image
F1C4: 29 60     AND #$60
F1C6: D0 E9     BNE $F1B1
F1C8: F0 EE     BEQ $F1B8



 $F1CA/61898:   Output One Character

F1CA: 48        PHA
F1CB: A5 9A     LDA $9A       ; Default Output Device (3)
F1CD: C9 03     CMP #$03
F1CF: D0 04     BNE $F1D5
F1D1: 68        PLA
F1D2: 4C 16 E7  JMP $E716     ; Output to Screen

Jump from $F1CF:

F1D5: 90 04     BCC $F1DB
F1D7: 68        PLA
F1D8: 4C DD ED  JMP $EDDD     ; Send Serial Deferred

Jump from $F1D5:

F1DB: 4A        LSR
F1DC: 68        PLA

Jump from $F2D4:

F1DD: 85 9E     STA $9E       ; Tape Error log pass 1
F1DF: 8A        TXA
F1E0: 48        PHA
F1E1: 98        TYA
F1E2: 48        PHA
F1E3: 90 23     BCC $F208
F1E5: 20 0D F8  JSR $F80D     ; Bump Tape Pointer
F1E8: D0 0E     BNE $F1F8
F1EA: 20 64 F8  JSR $F864     ; Initiate Tape Write
F1ED: B0 0E     BCS $F1FD
F1EF: A9 02     LDA #$02
F1F1: A0 00     LDY #$00
F1F3: 91 B2     STA ($B2),Y   ; Pointer: Start Address of Tape Buffer
F1F5: C8        INY
F1F6: 84 A6     STY $A6       ; Pointer: Tape I/O buffer

Jump from $F1E8:

F1F8: A5 9E     LDA $9E       ; Tape Error log pass 1
F1FA: 91 B2     STA ($B2),Y   ; Pointer: Start Address of Tape Buffer

Jump from $F20B:

F1FC: 18        CLC

Jump from $F1ED:

F1FD: 68        PLA
F1FE: A8        TAY
F1FF: 68        PLA
F200: AA        TAX
F201: A5 9E     LDA $9E       ; Tape Error log pass 1
F203: 90 02     BCC $F207
F205: A9 00     LDA #$00

Jump from $F203:

F207: 60        RTS

Jump from $F1E3:

F208: 20 17 F0  JSR $F017     ; Send to RS232 Buffer
F20B: 4C FC F1  JMP $F1FC



 $F20E/61966:   Set Input Device

F20E: 20 0F F3  JSR $F30F     ; Find File
F211: F0 03     BEQ $F216
F213: 4C 01 F7  JMP $F701     ; Output I/O Error Messages: 'FILE NOT OPEN'

Jump from $F211:

F216: 20 1F F3  JSR $F31F     ; Set File values
F219: A5 BA     LDA $BA       ; Current File - First Address (Device number)
F21B: F0 16     BEQ $F233
F21D: C9 03     CMP #$03
F21F: F0 12     BEQ $F233
F221: B0 14     BCS $F237
F223: C9 02     CMP #$02
F225: D0 03     BNE $F22A
F227: 4C 4D F0  JMP $F04D     ; Input From RS232

Jump from $F225:

F22A: A6 B9     LDX $B9       ; Current File - Secondary Address
F22C: E0 60     CPX #$60
F22E: F0 03     BEQ $F233
F230: 4C 0A F7  JMP $F70A     ; Output I/O Error Messages: 'NOT INPUT FILE'

Jump from $F21B, $F21F, $F22E, $F24B:

F233: 85 99     STA $99       ; Default Input Device (0)
F235: 18        CLC
F236: 60        RTS

Jump from $F221:

F237: AA        TAX
F238: 20 09 ED  JSR $ED09     ; Send TALK Command on Serial Bus
F23B: A5 B9     LDA $B9       ; Current File - Secondary Address
F23D: 10 06     BPL $F245
F23F: 20 CC ED  JSR $EDCC     ; Wait For Clock
F242: 4C 48 F2  JMP $F248

Jump from $F23D:

F245: 20 C7 ED  JSR $EDC7     ; Send TALK Secondary Address

Jump from $F242:

F248: 8A        TXA
F249: 24 90     BIT $90       ; Kernal I/O Status Word ST
F24B: 10 E6     BPL $F233
F24D: 4C 07 F7  JMP $F707     ; Output I/O Error Messages: 'DEVICE NOT PRESENT'



 $F250/62032:   Set Output Device

F250: 20 0F F3  JSR $F30F     ; Find File
F253: F0 03     BEQ $F258
F255: 4C 01 F7  JMP $F701     ; Output I/O Error Messages: 'FILE NOT OPEN'

Jump from $F253:

F258: 20 1F F3  JSR $F31F     ; Set File values
F25B: A5 BA     LDA $BA       ; Current File - First Address (Device number)
F25D: D0 03     BNE $F262

Jump from $F273:

F25F: 4C 0D F7  JMP $F70D     ; Output I/O Error Messages: 'NOT OUTPUT FILE'

Jump from $F25D:

F262: C9 03     CMP #$03
F264: F0 0F     BEQ $F275
F266: B0 11     BCS $F279
F268: C9 02     CMP #$02
F26A: D0 03     BNE $F26F
F26C: 4C E1 EF  JMP $EFE1     ; Submit to RS232

Jump from $F26A:

F26F: A6 B9     LDX $B9       ; Current File - Secondary Address
F271: E0 60     CPX #$60
F273: F0 EA     BEQ $F25F

Jump from $F264, $F28C:

F275: 85 9A     STA $9A       ; Default Output Device (3)
F277: 18        CLC
F278: 60        RTS

Jump from $F266:

F279: AA        TAX
F27A: 20 0C ED  JSR $ED0C     ; Send LISTEN Command on Serial Bus
F27D: A5 B9     LDA $B9       ; Current File - Secondary Address
F27F: 10 05     BPL $F286
F281: 20 BE ED  JSR $EDBE     ; Clear ATN
F284: D0 03     BNE $F289

Jump from $F27F:

F286: 20 B9 ED  JSR $EDB9     ; Send LISTEN Secondary Address

Jump from $F284:

F289: 8A        TXA
F28A: 24 90     BIT $90       ; Kernal I/O Status Word ST
F28C: 10 E7     BPL $F275
F28E: 4C 07 F7  JMP $F707     ; Output I/O Error Messages: 'DEVICE NOT PRESENT'



 $F291/62097:   Close File

F291: 20 14 F3  JSR $F314     ; Find File
F294: F0 02     BEQ $F298
F296: 18        CLC
F297: 60        RTS

Jump from $F294:

F298: 20 1F F3  JSR $F31F     ; Set File values
F29B: 8A        TXA
F29C: 48        PHA
F29D: A5 BA     LDA $BA       ; Current File - First Address (Device number)
F29F: F0 50     BEQ $F2F1
F2A1: C9 03     CMP #$03
F2A3: F0 4C     BEQ $F2F1
F2A5: B0 47     BCS $F2EE
F2A7: C9 02     CMP #$02
F2A9: D0 1D     BNE $F2C8
F2AB: 68        PLA
F2AC: 20 F2 F2  JSR $F2F2
F2AF: 20 83 F4  JSR $F483     ; Open RS232
F2B2: 20 27 FE  JSR $FE27     ; Read / Set Top of Memory
F2B5: A5 F8     LDA $F8       ; RS232 Input Buffer Pointer
F2B7: F0 01     BEQ $F2BA
F2B9: C8        INY

Jump from $F2B7:

F2BA: A5 FA     LDA $FA       ; RS232 Output Buffer Pointer
F2BC: F0 01     BEQ $F2BF
F2BE: C8        INY

Jump from $F2BC:

F2BF: A9 00     LDA #$00
F2C1: 85 F8     STA $F8       ; RS232 Input Buffer Pointer
F2C3: 85 FA     STA $FA       ; RS232 Output Buffer Pointer
F2C5: 4C 7D F4  JMP $F47D     ; Open RS232

Jump from $F2A9:

F2C8: A5 B9     LDA $B9       ; Current File - Secondary Address
F2CA: 29 0F     AND #$0F
F2CC: F0 23     BEQ $F2F1
F2CE: 20 D0 F7  JSR $F7D0     ; Get Buffer Address
F2D1: A9 00     LDA #$00
F2D3: 38        SEC
F2D4: 20 DD F1  JSR $F1DD     ; Output One Character
F2D7: 20 64 F8  JSR $F864     ; Initiate Tape Write
F2DA: 90 04     BCC $F2E0
F2DC: 68        PLA
F2DD: A9 00     LDA #$00
F2DF: 60        RTS

Jump from $F2DA:

F2E0: A5 B9     LDA $B9       ; Current File - Secondary Address
F2E2: C9 62     CMP #$62
F2E4: D0 0B     BNE $F2F1
F2E6: A9 05     LDA #$05
F2E8: 20 6A F7  JSR $F76A     ; Write Tape Header
F2EB: 4C F1 F2  JMP $F2F1

Jump from $F2A5:

F2EE: 20 42 F6  JSR $F642     ; Save to Serial Bus

Jump from $F29F, $F2A3, $F2CC, $F2E4, $F2EB:

F2F1: 68        PLA

Jump from $F2AC:

F2F2: AA        TAX
F2F3: C6 98     DEC $98       ; Number of Open Files/Index to File Table
F2F5: E4 98     CPX $98       ; Number of Open Files/Index to File Table
F2F7: F0 14     BEQ $F30D
F2F9: A4 98     LDY $98       ; Number of Open Files/Index to File Table
F2FB: B9 59 02  LDA $0259,Y   ; Active logical File numbers
F2FE: 9D 59 02  STA $0259,X   ; Active logical File numbers
F301: B9 63 02  LDA $0263,Y   ; Active File First Addresses (Device numbers)
F304: 9D 63 02  STA $0263,X   ; Active File First Addresses (Device numbers)
F307: B9 6D 02  LDA $026D,Y   ; Active File Secondary Addresses
F30A: 9D 6D 02  STA $026D,X   ; Active File Secondary Addresses

Jump from $F2F7:

F30D: 18        CLC
F30E: 60        RTS



 $F30F/62223:   Find File

Jump from $F20E, $F250, $F351:

F30F: A9 00     LDA #$00
F311: 85 90     STA $90       ; Kernal I/O Status Word ST
F313: 8A        TXA

Jump from $F291:

F314: A6 98     LDX $98       ; Number of Open Files/Index to File Table

Jump from $F31C:

F316: CA        DEX
F317: 30 15     BMI $F32E     ; Set File values
F319: DD 59 02  CMP $0259,X   ; Active logical File numbers
F31C: D0 F8     BNE $F316
F31E: 60        RTS



 $F31F/62239:   Set File values

Jump from $F216, $F258, $F298:

F31F: BD 59 02  LDA $0259,X   ; Active logical File numbers
F322: 85 B8     STA $B8       ; Current File - Logical File number
F324: BD 63 02  LDA $0263,X   ; Active File First Addresses (Device numbers)
F327: 85 BA     STA $BA       ; Current File - First Address (Device number)
F329: BD 6D 02  LDA $026D,X   ; Active File Secondary Addresses
F32C: 85 B9     STA $B9       ; Current File - Secondary Address

Jump from $F317:

F32E: 60        RTS



 $F32F/62255:   Abort All Files

F32F: A9 00     LDA #$00
F331: 85 98     STA $98       ; Number of Open Files/Index to File Table



 $F333/62259:   Restore Default I/O

F333: A2 03     LDX #$03
F335: E4 9A     CPX $9A       ; Default Output Device (3)
F337: B0 03     BCS $F33C
F339: 20 FE ED  JSR $EDFE     ; Send UNLISTEN

Jump from $F337:

F33C: E4 99     CPX $99       ; Default Input Device (0)
F33E: B0 03     BCS $F343
F340: 20 EF ED  JSR $EDEF     ; Send UNTALK

Jump from $F33E:

F343: 86 9A     STX $9A       ; Default Output Device (3)
F345: A9 00     LDA #$00
F347: 85 99     STA $99       ; Default Input Device (0)
F349: 60        RTS



 $F34A/62282:   Open File

F34A: A6 B8     LDX $B8       ; Current File - Logical File number
F34C: D0 03     BNE $F351
F34E: 4C 0A F7  JMP $F70A     ; Output I/O Error Messages: 'NOT INPUT FILE'

Jump from $F34C:

F351: 20 0F F3  JSR $F30F     ; Find File
F354: D0 03     BNE $F359
F356: 4C FE F6  JMP $F6FE     ; Output I/O Error Messages: 'FILE OPEN'

Jump from $F354:

F359: A6 98     LDX $98       ; Number of Open Files/Index to File Table
F35B: E0 0A     CPX #$0A
F35D: 90 03     BCC $F362
F35F: 4C FB F6  JMP $F6FB     ; Output I/O Error Messages: 'TOO MANY FILES'

Jump from $F35D:

F362: E6 98     INC $98       ; Number of Open Files/Index to File Table
F364: A5 B8     LDA $B8       ; Current File - Logical File number
F366: 9D 59 02  STA $0259,X   ; Active logical File numbers
F369: A5 B9     LDA $B9       ; Current File - Secondary Address
F36B: 09 60     ORA #$60
F36D: 85 B9     STA $B9       ; Current File - Secondary Address
F36F: 9D 6D 02  STA $026D,X   ; Active File Secondary Addresses
F372: A5 BA     LDA $BA       ; Current File - First Address (Device number)
F374: 9D 63 02  STA $0263,X   ; Active File First Addresses (Device numbers)
F377: F0 5A     BEQ $F3D3
F379: C9 03     CMP #$03
F37B: F0 56     BEQ $F3D3
F37D: 90 05     BCC $F384
F37F: 20 D5 F3  JSR $F3D5     ; Send Secondary Address
F382: 90 4F     BCC $F3D3

Jump from $F37D:

F384: C9 02     CMP #$02
F386: D0 03     BNE $F38B
* SX64:
F386: D0 08     BNE $F390

F388: 4C 09 F4  JMP $F409     ; Open RS232

Jump from $F386:

F38B: 20 D0 F7  JSR $F7D0     ; Get Buffer Address
F38E: B0 03     BCS $F393

Jump from $F386 (SX64):

F390: 4C 13 F7  JMP $F713     ; Output I/O Error Messages: 'ILLEGAL DEVICE NUMBER'

Jump from $F38E:

F393: A5 B9     LDA $B9       ; Current File - Secondary Address
F395: 29 0F     AND #$0F
F397: D0 1F     BNE $F3B8
F399: 20 17 F8  JSR $F817     ; Print "PRESS PLAY ON TAPE"
F39C: B0 36     BCS $F3D4
F39E: 20 AF F5  JSR $F5AF     ; Print "SEARCHING"
F3A1: A5 B7     LDA $B7       ; Number of Characters in Filename
F3A3: F0 0A     BEQ $F3AF
F3A5: 20 EA F7  JSR $F7EA     ; Find Specific Tape Header
F3A8: 90 18     BCC $F3C2
F3AA: F0 28     BEQ $F3D4

Jump from $F3B6:

F3AC: 4C 04 F7  JMP $F704     ; Output I/O Error Messages: 'FILE NOT FOUND'

Jump from $F3A3:

F3AF: 20 2C F7  JSR $F72C     ; Find Any Tape Header
F3B2: F0 20     BEQ $F3D4
F3B4: 90 0C     BCC $F3C2
F3B6: B0 F4     BCS $F3AC

Jump from $F397:

F3B8: 20 38 F8  JSR $F838     ; Print "PRESS RECORD..."
F3BB: B0 17     BCS $F3D4
F3BD: A9 04     LDA #$04
F3BF: 20 6A F7  JSR $F76A     ; Write Tape Header

Jump from $F3A8, $F3B4:

F3C2: A9 BF     LDA #$BF
F3C4: A4 B9     LDY $B9       ; Current File - Secondary Address
F3C6: C0 60     CPY #$60
F3C8: F0 07     BEQ $F3D1
F3CA: A0 00     LDY #$00
F3CC: A9 02     LDA #$02
F3CE: 91 B2     STA ($B2),Y   ; Pointer: Start Address of Tape Buffer
F3D0: 98        TYA

Jump from $F3C8:

F3D1: 85 A6     STA $A6       ; Pointer: Tape I/O buffer

Jump from $F377, $F37B, $F382, $F3D7, $F3DB:

F3D3: 18        CLC

Jump from $F39C, $F3AA, $F3B2, $F3BB:

F3D4: 60        RTS



 $F3D5/62421:   Send Secondary Address

Jump from $F37F, $F4C8, $F605:

F3D5: A5 B9     LDA $B9       ; Current File - Secondary Address
F3D7: 30 FA     BMI $F3D3     ; Open File
F3D9: A4 B7     LDY $B7       ; Number of Characters in Filename
F3DB: F0 F6     BEQ $F3D3     ; Open File
F3DD: A9 00     LDA #$00
F3DF: 85 90     STA $90       ; Kernal I/O Status Word ST
F3E1: A5 BA     LDA $BA       ; Current File - First Address (Device number)
F3E3: 20 0C ED  JSR $ED0C     ; Send LISTEN Command on Serial Bus
F3E6: A5 B9     LDA $B9       ; Current File - Secondary Address
F3E8: 09 F0     ORA #$F0
F3EA: 20 B9 ED  JSR $EDB9     ; Send LISTEN Secondary Address
F3ED: A5 90     LDA $90       ; Kernal I/O Status Word ST
F3EF: 10 05     BPL $F3F6
F3F1: 68        PLA
F3F2: 68        PLA
F3F3: 4C 07 F7  JMP $F707     ; Output I/O Error Messages: 'DEVICE NOT PRESENT'

Jump from $F3EF:

F3F6: A5 B7     LDA $B7       ; Number of Characters in Filename
F3F8: F0 0C     BEQ $F406
F3FA: A0 00     LDY #$00

Jump from $F404:

F3FC: B1 BB     LDA ($BB),Y   ; Pointer: Current File name Address
F3FE: 20 DD ED  JSR $EDDD     ; Send Serial Deferred
F401: C8        INY
F402: C4 B7     CPY $B7       ; Number of Characters in Filename
F404: D0 F6     BNE $F3FC

Jump from $F3F8:

F406: 4C 54 F6  JMP $F654     ; Save to Serial Bus



 $F409/62473:   Open RS232

Jump from $F388:

F409: 20 83 F4  JSR $F483
F40C: 8C 97 02  STY $0297     ; RS232 Pseudo 6551 Status Register Image

Jump from $F41B:

F40F: C4 B7     CPY $B7       ; Number of Characters in Filename
F411: F0 0A     BEQ $F41D
F413: B1 BB     LDA ($BB),Y   ; Pointer: Current File name Address
F415: 99 93 02  STA $0293,Y   ; RS232 Pseudo 6551 control Register Image
F418: C8        INY
F419: C0 04     CPY #$04
F41B: D0 F2     BNE $F40F

Jump from $F411:

F41D: 20 4A EF  JSR $EF4A     ; Compute Bit Count
F420: 8E 98 02  STX $0298     ; RS232 Number of Bits left to send
F423: AD 93 02  LDA $0293     ; RS232 Pseudo 6551 control Register Image
F426: 29 0F     AND #$0F
F428: F0 1C     BEQ $F446
F42A: 0A        ASL
F42B: AA        TAX
F42C: AD A6 02  LDA $02A6     ; Flag: TV Standard
F42F: D0 09     BNE $F43A
F431: BC C1 FE  LDY $FEC1,X   ; Exit Interrupt
F434: BD C0 FE  LDA $FEC0,X   ; Exit Interrupt
F437: 4C 40 F4  JMP $F440

Jump from $F42F:

F43A: BC EB E4  LDY $E4EB,X   ; Pause After Finding Tape File
F43D: BD EA E4  LDA $E4EA,X   ; Pause After Finding Tape File

Jump from $F437:

F440: 8C 96 02  STY $0296     ; RS232 Non-standard Bits/Second
F443: 8D 95 02  STA $0295     ; RS232 Non-standard Bits/Second

Jump from $F428:

F446: AD 95 02  LDA $0295     ; RS232 Non-standard Bits/Second
F449: 0A        ASL
F44A: 20 2E FF  JSR $FF2E     ; NMI RS232 Out
F44D: AD 94 02  LDA $0294     ; RS232 Pseudo 6551 command Register Image
F450: 4A        LSR
F451: 90 09     BCC $F45C
F453: AD 01 DD  LDA $DD01     ; CIA2: Data Port B (User Port, RS232)
F456: 0A        ASL
F457: B0 03     BCS $F45C
F459: 20 0D F0  JSR $F00D     ; No DSR (Data Set Ready) Error

Jump from $F451, $F457:

F45C: AD 9B 02  LDA $029B     ; RS232 Index to End of Input Buffer
F45F: 8D 9C 02  STA $029C     ; RS232 Pointer: High Byte of Input Buffer
F462: AD 9E 02  LDA $029E     ; RS232 Index to End of Output Buffer
F465: 8D 9D 02  STA $029D     ; RS232 Pointer: High Byte of Output Buffer
F468: 20 27 FE  JSR $FE27     ; Read / Set Top of Memory
F46B: A5 F8     LDA $F8       ; RS232 Input Buffer Pointer
F46D: D0 05     BNE $F474
F46F: 88        DEY
F470: 84 F8     STY $F8       ; RS232 Input Buffer Pointer
F472: 86 F7     STX $F7       ; RS232 Input Buffer Pointer

Jump from $F46D:

F474: A5 FA     LDA $FA       ; RS232 Output Buffer Pointer
F476: D0 05     BNE $F47D
F478: 88        DEY
F479: 84 FA     STY $FA       ; RS232 Output Buffer Pointer
F47B: 86 F9     STX $F9       ; RS232 Output Buffer Pointer

Jump from $F476, $F2C5:

F47D: 38        SEC
F47E: A9 F0     LDA #$F0
F480: 4C 2D FE  JMP $FE2D     ; Read / Set Top of Memory

Jump from $F409, $F2AF:

F483: A9 7F     LDA #$7F
F485: 8D 0D DD  STA $DD0D     ; CIA2: Interrupt (NMI) Control Register
F488: A9 06     LDA #$06
F48A: 8D 03 DD  STA $DD03     ; CIA2: Data Direction Register B
F48D: 8D 01 DD  STA $DD01     ; CIA2: Data Port B (User Port, RS232)
F490: A9 04     LDA #$04
F492: 0D 00 DD  ORA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
F495: 8D 00 DD  STA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
F498: A0 00     LDY #$00
F49A: 8C A1 02  STY $02A1     ; RS232 Enables
F49D: 60        RTS



 $F49E/62622:   Load RAM

Jump from $FFD5:

F49E: 86 C3     STX $C3       ; Pointer: Type 3 Tape LOAD and general use
F4A0: 84 C4     STY $C4       ; Pointer: Type 3 Tape LOAD and general use
F4A2: 6C 30 03  JMP ($0330)   ; Vector: Kernal LOAD Routine
F4A5: 85 93     STA $93       ; Flag: 0 = Load, 1 = Verify
F4A7: A9 00     LDA #$00
F4A9: 85 90     STA $90       ; Kernal I/O Status Word ST
F4AB: A5 BA     LDA $BA       ; Current File - First Address (Device number)
F4AD: D0 03     BNE $F4B2

Jump from $F4B4, $F4B6 (SX64):

F4AF: 4C 13 F7  JMP $F713     ; Output I/O Error Messages: 'ILLEGAL DEVICE NUMBER'

Jump from $F4AD:

F4B2: C9 03     CMP #$03
F4B4: F0 F9     BEQ $F4AF
F4B6: 90 7B     BCC $F533     ; Load File From Tape
* SX64:
F4B6: 90 F7     BCC $F4AF



 $F4B8/62648:   Load File From Serial Bus

F4B8: A4 B7     LDY $B7       ; Number of Characters in Filename
F4BA: D0 03     BNE $F4BF
F4BC: 4C 10 F7  JMP $F710     ; Output I/O Error Messages: 'MISSING FILENAME'

Jump from $F4BA:

F4BF: A6 B9     LDX $B9       ; Current File - Secondary Address
F4C1: 20 AF F5  JSR $F5AF     ; Print "SEARCHING"
F4C4: A9 60     LDA #$60
F4C6: 85 B9     STA $B9       ; Current File - Secondary Address
F4C8: 20 D5 F3  JSR $F3D5     ; Send Secondary Address
F4CB: A5 BA     LDA $BA       ; Current File - First Address (Device number)
F4CD: 20 09 ED  JSR $ED09     ; Send TALK Command on Serial Bus
F4D0: A5 B9     LDA $B9       ; Current File - Secondary Address
F4D2: 20 C7 ED  JSR $EDC7     ; Send TALK Secondary Address
F4D5: 20 13 EE  JSR $EE13     ; Receive From Serial Bus
F4D8: 85 AE     STA $AE       ; Tape End Address/End of Program
F4DA: A5 90     LDA $90       ; Kernal I/O Status Word ST
F4DC: 4A        LSR
F4DD: 4A        LSR
F4DE: B0 50     BCS $F530
F4E0: 20 13 EE  JSR $EE13     ; Receive From Serial Bus
F4E3: 85 AF     STA $AF       ; Tape End Address/End of Program
F4E5: 8A        TXA
F4E6: D0 08     BNE $F4F0
F4E8: A5 C3     LDA $C3       ; Pointer: Type 3 Tape LOAD and general use
F4EA: 85 AE     STA $AE       ; Tape End Address/End of Program
F4EC: A5 C4     LDA $C4       ; Pointer: Type 3 Tape LOAD and general use
F4EE: 85 AF     STA $AF       ; Tape End Address/End of Program

Jump from $F4E6:

F4F0: 20 D2 F5  JSR $F5D2     ; Print "LOADING / VERIFYING"

Jump from $F509, $F526:

F4F3: A9 FD     LDA #$FD
F4F5: 25 90     AND $90       ; Kernal I/O Status Word ST
F4F7: 85 90     STA $90       ; Kernal I/O Status Word ST
F4F9: 20 E1 FF  JSR $FFE1     ; Test-Stop Vector
F4FC: D0 03     BNE $F501
F4FE: 4C 33 F6  JMP $F633     ; Save to Serial Bus

Jump from $F4FC:

F501: 20 13 EE  JSR $EE13     ; Receive From Serial Bus
F504: AA        TAX
F505: A5 90     LDA $90       ; Kernal I/O Status Word ST
F507: 4A        LSR
F508: 4A        LSR
F509: B0 E8     BCS $F4F3
F50B: 8A        TXA
F50C: A4 93     LDY $93       ; Flag: 0 = Load, 1 = Verify
F50E: F0 0C     BEQ $F51C
F510: A0 00     LDY #$00
F512: D1 AE     CMP ($AE),Y   ; Tape End Address/End of Program
F514: F0 08     BEQ $F51E
F516: A9 10     LDA #$10
F518: 20 1C FE  JSR $FE1C     ; Control OS Messages
F51B: 2C        .BYTE $2C

Jump from $F50E:

F51C: 91 AE     STA ($AE),Y   ; Tape End Address/End of Program

Jump from $F514:

F51E: E6 AE     INC $AE       ; Tape End Address/End of Program
F520: D0 02     BNE $F524
F522: E6 AF     INC $AF       ; Tape End Address/End of Program

Jump from $F520:

F524: 24 90     BIT $90       ; Kernal I/O Status Word ST
F526: 50 CB     BVC $F4F3
F528: 20 EF ED  JSR $EDEF     ; Send UNTALK
F52B: 20 42 F6  JSR $F642     ; Save to Serial Bus
F52E: 90 79     BCC $F5A9     ; Load File From Tape

Jump from $F4DE, $F554, $F55B:

F530: 4C 04 F7  JMP $F704     ; Output I/O Error Messages: 'FILE NOT FOUND'



 $F533/62771:   Load File From Tape

Jump from $F4B6:

F533: 4A        LSR
F534: B0 03     BCS $F539
F536: 4C 13 F7  JMP $F713     ; Output I/O Error Messages: 'ILLEGAL DEVICE NUMBER'

Jump from $F534:

F539: 20 D0 F7  JSR $F7D0     ; Get Buffer Address
F53C: B0 03     BCS $F541
F53E: 4C 13 F7  JMP $F713     ; Output I/O Error Messages: 'ILLEGAL DEVICE NUMBER'

Jump from $F53C:

F541: 20 17 F8  JSR $F817     ; Print "PRESS PLAY ON TAPE"
F544: B0 68     BCS $F5AE
F546: 20 AF F5  JSR $F5AF     ; Print "SEARCHING"

Jump from $F56A:

F549: A5 B7     LDA $B7       ; Number of Characters in Filename
F54B: F0 09     BEQ $F556
F54D: 20 EA F7  JSR $F7EA     ; Find Specific Tape Header
F550: 90 0B     BCC $F55D
F552: F0 5A     BEQ $F5AE
F554: B0 DA     BCS $F530     ; Load File From Serial Bus

Jump from $F54B:

F556: 20 2C F7  JSR $F72C     ; Find Any Tape Header
F559: F0 53     BEQ $F5AE
F55B: B0 D3     BCS $F530     ; Load File From Serial Bus

Jump from $F550:

F55D: A5 90     LDA $90       ; Kernal I/O Status Word ST
F55F: 29 10     AND #$10
F561: 38        SEC
F562: D0 4A     BNE $F5AE
F564: E0 01     CPX #$01
F566: F0 11     BEQ $F579
F568: E0 03     CPX #$03
F56A: D0 DD     BNE $F549

Jump from $F57B:

F56C: A0 01     LDY #$01
F56E: B1 B2     LDA ($B2),Y   ; Pointer: Start Address of Tape Buffer
F570: 85 C3     STA $C3       ; Pointer: Type 3 Tape LOAD and general use
F572: C8        INY
F573: B1 B2     LDA ($B2),Y   ; Pointer: Start Address of Tape Buffer
F575: 85 C4     STA $C4       ; Pointer: Type 3 Tape LOAD and general use
F577: B0 04     BCS $F57D

Jump from $F566:

F579: A5 B9     LDA $B9       ; Current File - Secondary Address
F57B: D0 EF     BNE $F56C

Jump from $F577:

F57D: A0 03     LDY #$03
F57F: B1 B2     LDA ($B2),Y   ; Pointer: Start Address of Tape Buffer
F581: A0 01     LDY #$01
F583: F1 B2     SBC ($B2),Y   ; Pointer: Start Address of Tape Buffer
F585: AA        TAX
F586: A0 04     LDY #$04
F588: B1 B2     LDA ($B2),Y   ; Pointer: Start Address of Tape Buffer
F58A: A0 02     LDY #$02
F58C: F1 B2     SBC ($B2),Y   ; Pointer: Start Address of Tape Buffer
F58E: A8        TAY
F58F: 18        CLC
F590: 8A        TXA
F591: 65 C3     ADC $C3       ; Pointer: Type 3 Tape LOAD and general use
F593: 85 AE     STA $AE       ; Tape End Address/End of Program
F595: 98        TYA
F596: 65 C4     ADC $C4       ; Pointer: Type 3 Tape LOAD and general use
F598: 85 AF     STA $AF       ; Tape End Address/End of Program
F59A: A5 C3     LDA $C3       ; Pointer: Type 3 Tape LOAD and general use
F59C: 85 C1     STA $C1       ; Start Address for LOAD and Cassette Write
F59E: A5 C4     LDA $C4       ; Pointer: Type 3 Tape LOAD and general use
F5A0: 85 C2     STA $C2       ; Start Address for LOAD and Cassette Write
F5A2: 20 D2 F5  JSR $F5D2     ; Print "LOADING / VERIFYING"
F5A5: 20 4A F8  JSR $F84A     ; Initiate Tape Read
F5A8: 24        .BYTE $24

Jump from $F52E:

F5A9: 18        CLC
F5AA: A6 AE     LDX $AE       ; Tape End Address/End of Program
F5AC: A4 AF     LDY $AF       ; Tape End Address/End of Program

Jump from $F544, $F552, $F559, $F562:

F5AE: 60        RTS



 $F5AF/62895:   Print "SEARCHING"

Jump from $F39E, $F4C1, $F546:

F5AF: A5 9D     LDA $9D       ; Error-Mode-Flag
F5B1: 10 1E     BPL $F5D1     ; Print Filename
F5B3: A0 0C     LDY #$0C
F5B5: 20 2F F1  JSR $F12F     ; Print Message
F5B8: A5 B7     LDA $B7       ; Number of Characters in Filename
F5BA: F0 15     BEQ $F5D1     ; Print Filename
F5BC: A0 17     LDY #$17
F5BE: 20 2F F1  JSR $F12F     ; Print Message



 $F5C1/62913:   Print Filename

Jump from $F698:

F5C1: A4 B7     LDY $B7       ; Number of Characters in Filename
F5C3: F0 0C     BEQ $F5D1
F5C5: A0 00     LDY #$00

Jump from $F5CF:

F5C7: B1 BB     LDA ($BB),Y   ; Pointer: Current File name Address
F5C9: 20 D2 FF  JSR $FFD2     ; Output Vector, chrout
F5CC: C8        INY
F5CD: C4 B7     CPY $B7       ; Number of Characters in Filename
F5CF: D0 F6     BNE $F5C7

Jump from $F5C3, $F5B1, $F5BA:

F5D1: 60        RTS



 $F5D2/62930:   Print "LOADING / VERIFYING"

Jump from $F4F0, $F5A2:

F5D2: A0 49     LDY #$49
F5D4: A5 93     LDA $93       ; Flag: 0 = Load, 1 = Verify
F5D6: F0 02     BEQ $F5DA
F5D8: A0 59     LDY #$59

Jump from $F5D6:

F5DA: 4C 2B F1  JMP $F12B     ; Print Message if Direct



 $F5DD/62941:   Save RAM

Jump from $FFD8:

F5DD: 86 AE     STX $AE       ; Tape End Address/End of Program
F5DF: 84 AF     STY $AF       ; Tape End Address/End of Program
F5E1: AA        TAX
F5E2: B5 00     LDA $00,X     ; 6510 On-chip Data Direction Register
F5E4: 85 C1     STA $C1       ; Start Address for LOAD and Cassette Write
F5E6: B5 01     LDA $01,X     ; 6510 On-chip 8-bit Input/Output Register
F5E8: 85 C2     STA $C2       ; Start Address for LOAD and Cassette Write
F5EA: 6C 32 03  JMP ($0332)   ; Vector: Kernal SAVE Routine
F5ED: A5 BA     LDA $BA       ; Current File - First Address (Device number)
F5EF: D0 03     BNE $F5F4

Jump from $F5F6, $F5F8 (SX64), $F662:

F5F1: 4C 13 F7  JMP $F713     ; Output I/O Error Messages: 'ILLEGAL DEVICE NUMBER'

Jump from $F5EF:

F5F4: C9 03     CMP #$03
F5F6: F0 F9     BEQ $F5F1
F5F8: 90 5F     BCC $F659     ; Save to Tape
* SX64:
F5F8: 90 F7     BCC $F5F1



 $F5FA/62970:   Save to Serial Bus

F5FA: A9 61     LDA #$61
F5FC: 85 B9     STA $B9       ; Current File - Secondary Address
F5FE: A4 B7     LDY $B7       ; Number of Characters in Filename
F600: D0 03     BNE $F605
F602: 4C 10 F7  JMP $F710     ; Output I/O Error Messages: 'MISSING FILENAME'

Jump from $F600:

F605: 20 D5 F3  JSR $F3D5     ; Send Secondary Address
F608: 20 8F F6  JSR $F68F     ; Print "SAVING"
F60B: A5 BA     LDA $BA       ; Current File - First Address (Device number)
F60D: 20 0C ED  JSR $ED0C     ; Send LISTEN Command on Serial Bus
F610: A5 B9     LDA $B9       ; Current File - Secondary Address
F612: 20 B9 ED  JSR $EDB9     ; Send LISTEN Secondary Address
F615: A0 00     LDY #$00
F617: 20 8E FB  JSR $FB8E     ; Reset Tape Pointer
F61A: A5 AC     LDA $AC       ; Pointer: Tape Buffer/Screen scrolling
F61C: 20 DD ED  JSR $EDDD     ; Send Serial Deferred
F61F: A5 AD     LDA $AD       ; Pointer: Tape Buffer/Screen scrolling
F621: 20 DD ED  JSR $EDDD     ; Send Serial Deferred

Jump from $F63D:

F624: 20 D1 FC  JSR $FCD1     ; Check Read / Write Pointer
F627: B0 16     BCS $F63F
F629: B1 AC     LDA ($AC),Y   ; Pointer: Tape Buffer/Screen scrolling
F62B: 20 DD ED  JSR $EDDD     ; Send Serial Deferred
F62E: 20 E1 FF  JSR $FFE1     ; Test-Stop Vector
F631: D0 07     BNE $F63A

Jump from $F4FE:

F633: 20 42 F6  JSR $F642
F636: A9 00     LDA #$00
F638: 38        SEC
F639: 60        RTS

Jump from $F631:

F63A: 20 DB FC  JSR $FCDB     ; Bump Read / Write Pointer
F63D: D0 E5     BNE $F624

Jump from $F627:

F63F: 20 FE ED  JSR $EDFE     ; Send UNLISTEN

Jump from $F633, $F2EE, $F52B:

F642: 24 B9     BIT $B9       ; Current File - Secondary Address
F644: 30 11     BMI $F657
F646: A5 BA     LDA $BA       ; Current File - First Address (Device number)
F648: 20 0C ED  JSR $ED0C     ; Send LISTEN Command on Serial Bus
F64B: A5 B9     LDA $B9       ; Current File - Secondary Address
F64D: 29 EF     AND #$EF
F64F: 09 E0     ORA #$E0
F651: 20 B9 ED  JSR $EDB9     ; Send LISTEN Secondary Address

Jump from $F406:

F654: 20 FE ED  JSR $EDFE     ; Send UNLISTEN

Jump from $F644:

F657: 18        CLC
F658: 60        RTS



 $F659/63065:   Save to Tape

Jump from $F5F8:

F659: 4A        LSR
F65A: B0 03     BCS $F65F
F65C: 4C 13 F7  JMP $F713     ; Output I/O Error Messages: 'ILLEGAL DEVICE NUMBER'

Jump from $F65A:

F65F: 20 D0 F7  JSR $F7D0     ; Get Buffer Address
F662: 90 8D     BCC $F5F1     ; Save RAM
F664: 20 38 F8  JSR $F838     ; Print "PRESS RECORD..."
F667: B0 25     BCS $F68E
F669: 20 8F F6  JSR $F68F     ; Print "SAVING"
F66C: A2 03     LDX #$03
F66E: A5 B9     LDA $B9       ; Current File - Secondary Address
F670: 29 01     AND #$01
F672: D0 02     BNE $F676
F674: A2 01     LDX #$01

Jump from $F672:

F676: 8A        TXA
F677: 20 6A F7  JSR $F76A     ; Write Tape Header
F67A: B0 12     BCS $F68E
F67C: 20 67 F8  JSR $F867     ; Initiate Tape Write
F67F: B0 0D     BCS $F68E
F681: A5 B9     LDA $B9       ; Current File - Secondary Address
F683: 29 02     AND #$02
F685: F0 06     BEQ $F68D
F687: A9 05     LDA #$05
F689: 20 6A F7  JSR $F76A     ; Write Tape Header
F68C: 24        .BYTE $24

Jump from $F685:

F68D: 18        CLC

Jump from $F667, $F67A, $F67F, $F691:

F68E: 60        RTS



 $F68F/63119:   Print "SAVING"

Jump from $F608, $F669:

F68F: A5 9D     LDA $9D       ; Error-Mode-Flag
F691: 10 FB     BPL $F68E     ; Save to Tape
F693: A0 51     LDY #$51
F695: 20 2F F1  JSR $F12F     ; Print Message
F698: 4C C1 F5  JMP $F5C1     ; Print Filename



 $F69B/63131:   Bump Clock

Jump from $FFEA:

F69B: A2 00     LDX #$00
F69D: E6 A2     INC $A2       ; Real-time jiffy Clock
F69F: D0 06     BNE $F6A7
F6A1: E6 A1     INC $A1       ; Real-time jiffy Clock
F6A3: D0 02     BNE $F6A7
F6A5: E6 A0     INC $A0       ; Real-time jiffy Clock

Jump from $F69F, $F6A3:

F6A7: 38        SEC
F6A8: A5 A2     LDA $A2       ; Real-time jiffy Clock
F6AA: E9 01     SBC #$01
F6AC: A5 A1     LDA $A1       ; Real-time jiffy Clock
F6AE: E9 1A     SBC #$1A
F6B0: A5 A0     LDA $A0       ; Real-time jiffy Clock
F6B2: E9 4F     SBC #$4F
F6B4: 90 06     BCC $F6BC
F6B6: 86 A0     STX $A0       ; Real-time jiffy Clock
F6B8: 86 A1     STX $A1       ; Real-time jiffy Clock
F6BA: 86 A2     STX $A2       ; Real-time jiffy Clock

Jump from $F6B4, $F6C2, $F8CA, $FE5E:

F6BC: AD 01 DC  LDA $DC01     ; CIA1: Data Port B (Keyboard, Joystick, Paddles)
F6BF: CD 01 DC  CMP $DC01     ; CIA1: Data Port B (Keyboard, Joystick, Paddles)
F6C2: D0 F8     BNE $F6BC
F6C4: AA        TAX
F6C5: 30 13     BMI $F6DA
F6C7: A2 BD     LDX #$BD
F6C9: 8E 00 DC  STX $DC00     ; CIA1: Data Port A (Keyboard, Joystick, Paddles)

Jump from $F6D2:

F6CC: AE 01 DC  LDX $DC01     ; CIA1: Data Port B (Keyboard, Joystick, Paddles)
F6CF: EC 01 DC  CPX $DC01     ; CIA1: Data Port B (Keyboard, Joystick, Paddles)
F6D2: D0 F8     BNE $F6CC
F6D4: 8D 00 DC  STA $DC00     ; CIA1: Data Port A (Keyboard, Joystick, Paddles)
F6D7: E8        INX
F6D8: D0 02     BNE $F6DC

Jump from $F6C5:

F6DA: 85 91     STA $91       ; Flag: $7F = STOP key

Jump from $F6D8:

F6DC: 60        RTS



 $F6DD/63197:   Get Time

Jump from $FFDE:

F6DD: 78        SEI
F6DE: A5 A2     LDA $A2       ; Real-time jiffy Clock
F6E0: A6 A1     LDX $A1       ; Real-time jiffy Clock
F6E2: A4 A0     LDY $A0       ; Real-time jiffy Clock



 $F6E4/63204:   Set Time

Jump from $FFDB:

F6E4: 78        SEI
F6E5: 85 A2     STA $A2       ; Real-time jiffy Clock
F6E7: 86 A1     STX $A1       ; Real-time jiffy Clock
F6E9: 84 A0     STY $A0       ; Real-time jiffy Clock
F6EB: 58        CLI
F6EC: 60        RTS



 $F6ED/63213:   Check STOP Key

F6ED: A5 91     LDA $91       ; Flag: $7F = STOP key
F6EF: C9 7F     CMP #$7F
F6F1: D0 07     BNE $F6FA
F6F3: 08        PHP
F6F4: 20 CC FF  JSR $FFCC     ; Restore I/O Vector
F6F7: 85 C6     STA $C6       ; Number of Characters in Keyboard Buffer queue
F6F9: 28        PLP

Jump from $F6F1:

F6FA: 60        RTS



 $F6FB/63227:   Output I/O Error Messages: 'TOO MANY FILES'

Jump from $F35F:

F6FB: A9 01     LDA #$01
F6FD: 2C        .BYTE $2C



 $F6FE/63230:   Output I/O Error Messages: 'FILE OPEN'

Jump from $F356:

F6FE: A9 02     LDA #$02
F700: 2C        .BYTE $2C



 $F701/63233:   Output I/O Error Messages: 'FILE NOT OPEN'

Jump from $F213, $F255:

F701: A9 03     LDA #$03
F703: 2C        .BYTE $2C



 $F704/63236:   Output I/O Error Messages: 'FILE NOT FOUND'

Jump from $F3AC, $F530:

F704: A9 04     LDA #$04
F706: 2C        .BYTE $2C



 $F707/63239:   Output I/O Error Messages: 'DEVICE NOT PRESENT'

Jump from $F24D, $F28E, $F3F3:

F707: A9 05     LDA #$05
F709: 2C        .BYTE $2C



 $F70A/63242:   Output I/O Error Messages: 'NOT INPUT FILE'

Jump from $F230, $F34E:

F70A: A9 06     LDA #$06
F70C: 2C        .BYTE $2C



 $F70D/63245:   Output I/O Error Messages: 'NOT OUTPUT FILE'

Jump from $F25F:

F70D: A9 07     LDA #$07
F70F: 2C        .BYTE $2C



 $F710/63248:   Output I/O Error Messages: 'MISSING FILENAME'

Jump from $F4BC, $F602:

F710: A9 08     LDA #$08
F712: 2C        .BYTE $2C



 $F713/63251:   Output I/O Error Messages: 'ILLEGAL DEVICE NUMBER'

Jump from $F390, $F4AF, $F536, $F53E, $F5F1, $F65C:

F713: A9 09     LDA #$09
F715: 48        PHA
F716: 20 CC FF  JSR $FFCC     ; Restore I/O Vector
F719: A0 00     LDY #$00
F71B: 24 9D     BIT $9D       ; Error-Mode-Flag
F71D: 50 0A     BVC $F729
F71F: 20 2F F1  JSR $F12F     ; Print Message
F722: 68        PLA
F723: 48        PHA
F724: 09 30     ORA #$30
F726: 20 D2 FF  JSR $FFD2     ; Output Vector, chrout

Jump from $F71D:

F729: 68        PLA
F72A: 38        SEC
F72B: 60        RTS



 $F72C/63276:   Find Any Tape Header

Jump from $F749, $F3AF, $F556, $F7EA:

F72C: A5 93     LDA $93       ; Flag: 0 = Load, 1 = Verify
F72E: 48        PHA
F72F: 20 41 F8  JSR $F841     ; Initiate Tape Read
F732: 68        PLA
F733: 85 93     STA $93       ; Flag: 0 = Load, 1 = Verify
F735: B0 32     BCS $F769
F737: A0 00     LDY #$00
F739: B1 B2     LDA ($B2),Y   ; Pointer: Start Address of Tape Buffer
F73B: C9 05     CMP #$05
F73D: F0 2A     BEQ $F769
F73F: C9 01     CMP #$01
F741: F0 08     BEQ $F74B
F743: C9 03     CMP #$03
F745: F0 04     BEQ $F74B
F747: C9 04     CMP #$04
F749: D0 E1     BNE $F72C

Jump from $F741, $F745:

F74B: AA        TAX
F74C: 24 9D     BIT $9D       ; Error-Mode-Flag
F74E: 10 17     BPL $F767
F750: A0 63     LDY #$63
F752: 20 2F F1  JSR $F12F     ; Print Message
F755: A0 05     LDY #$05

Jump from $F75F:

F757: B1 B2     LDA ($B2),Y   ; Pointer: Start Address of Tape Buffer
F759: 20 D2 FF  JSR $FFD2     ; Output Vector, chrout
F75C: C8        INY
F75D: C0 15     CPY #$15
F75F: D0 F6     BNE $F757
F761: A5 A1     LDA $A1       ; Real-time jiffy Clock
F763: 20 E0 E4  JSR $E4E0     ; Pause After Finding Tape File
F766: EA        NOP

Jump from $F74E:

F767: 18        CLC
F768: 88        DEY

Jump from $F735, $F73D:

F769: 60        RTS



 $F76A/63338:   Write Tape Header

Jump from $F2E8, $F3BF, $F677, $F689:

F76A: 85 9E     STA $9E       ; Tape Error log pass 1
F76C: 20 D0 F7  JSR $F7D0     ; Get Buffer Address
F76F: 90 5E     BCC $F7CF
F771: A5 C2     LDA $C2       ; Start Address for LOAD and Cassette Write
F773: 48        PHA
F774: A5 C1     LDA $C1       ; Start Address for LOAD and Cassette Write
F776: 48        PHA
F777: A5 AF     LDA $AF       ; Tape End Address/End of Program
F779: 48        PHA
F77A: A5 AE     LDA $AE       ; Tape End Address/End of Program
F77C: 48        PHA
F77D: A0 BF     LDY #$BF
F77F: A9 20     LDA #$20

Jump from $F784:

F781: 91 B2     STA ($B2),Y   ; Pointer: Start Address of Tape Buffer
F783: 88        DEY
F784: D0 FB     BNE $F781
F786: A5 9E     LDA $9E       ; Tape Error log pass 1
F788: 91 B2     STA ($B2),Y   ; Pointer: Start Address of Tape Buffer
F78A: C8        INY
F78B: A5 C1     LDA $C1       ; Start Address for LOAD and Cassette Write
F78D: 91 B2     STA ($B2),Y   ; Pointer: Start Address of Tape Buffer
F78F: C8        INY
F790: A5 C2     LDA $C2       ; Start Address for LOAD and Cassette Write
F792: 91 B2     STA ($B2),Y   ; Pointer: Start Address of Tape Buffer
F794: C8        INY
F795: A5 AE     LDA $AE       ; Tape End Address/End of Program
F797: 91 B2     STA ($B2),Y   ; Pointer: Start Address of Tape Buffer
F799: C8        INY
F79A: A5 AF     LDA $AF       ; Tape End Address/End of Program
F79C: 91 B2     STA ($B2),Y   ; Pointer: Start Address of Tape Buffer
F79E: C8        INY
F79F: 84 9F     STY $9F       ; Tape Error log pass 2
F7A1: A0 00     LDY #$00
F7A3: 84 9E     STY $9E       ; Tape Error log pass 1

Jump from $F7B5:

F7A5: A4 9E     LDY $9E       ; Tape Error log pass 1
F7A7: C4 B7     CPY $B7       ; Number of Characters in Filename
F7A9: F0 0C     BEQ $F7B7
F7AB: B1 BB     LDA ($BB),Y   ; Pointer: Current File name Address
F7AD: A4 9F     LDY $9F       ; Tape Error log pass 2
F7AF: 91 B2     STA ($B2),Y   ; Pointer: Start Address of Tape Buffer
F7B1: E6 9E     INC $9E       ; Tape Error log pass 1
F7B3: E6 9F     INC $9F       ; Tape Error log pass 2
F7B5: D0 EE     BNE $F7A5

Jump from $F7A9:

F7B7: 20 D7 F7  JSR $F7D7     ; Set Buffer Stat / End Pointers
F7BA: A9 69     LDA #$69
F7BC: 85 AB     STA $AB       ; RS232 Input parity/Tape temporary
F7BE: 20 6B F8  JSR $F86B     ; Initiate Tape Write
F7C1: A8        TAY
F7C2: 68        PLA
F7C3: 85 AE     STA $AE       ; Tape End Address/End of Program
F7C5: 68        PLA
F7C6: 85 AF     STA $AF       ; Tape End Address/End of Program
F7C8: 68        PLA
F7C9: 85 C1     STA $C1       ; Start Address for LOAD and Cassette Write
F7CB: 68        PLA
F7CC: 85 C2     STA $C2       ; Start Address for LOAD and Cassette Write
F7CE: 98        TYA

Jump from $F76F:

F7CF: 60        RTS



 $F7D0/63440:   Get Buffer Address

Jump from $F2CE, $F38B, $F539, $F65F, $F76C, $F7D7, $F80D:

F7D0: A6 B2     LDX $B2       ; Pointer: Start Address of Tape Buffer
F7D2: A4 B3     LDY $B3       ; Pointer: Start Address of Tape Buffer
F7D4: C0 02     CPY #$02
F7D6: 60        RTS



 $F7D7/63447:   Set Buffer Stat / End Pointers

Jump from $F7B7, $F847, $F864:

F7D7: 20 D0 F7  JSR $F7D0     ; Get Buffer Address
F7DA: 8A        TXA
F7DB: 85 C1     STA $C1       ; Start Address for LOAD and Cassette Write
F7DD: 18        CLC
F7DE: 69 C0     ADC #$C0
F7E0: 85 AE     STA $AE       ; Tape End Address/End of Program
F7E2: 98        TYA
F7E3: 85 C2     STA $C2       ; Start Address for LOAD and Cassette Write
F7E5: 69 00     ADC #$00
F7E7: 85 AF     STA $AF       ; Tape End Address/End of Program
F7E9: 60        RTS



 $F7EA/63466:   Find Specific Tape Header

Jump from $F801, $F3A5, $F54D:

F7EA: 20 2C F7  JSR $F72C     ; Find Any Tape Header
F7ED: B0 1D     BCS $F80C
F7EF: A0 05     LDY #$05
F7F1: 84 9F     STY $9F       ; Tape Error log pass 2
F7F3: A0 00     LDY #$00
F7F5: 84 9E     STY $9E       ; Tape Error log pass 1

Jump from $F809:

F7F7: C4 B7     CPY $B7       ; Number of Characters in Filename
F7F9: F0 10     BEQ $F80B
F7FB: B1 BB     LDA ($BB),Y   ; Pointer: Current File name Address
F7FD: A4 9F     LDY $9F       ; Tape Error log pass 2
F7FF: D1 B2     CMP ($B2),Y   ; Pointer: Start Address of Tape Buffer
F801: D0 E7     BNE $F7EA
F803: E6 9E     INC $9E       ; Tape Error log pass 1
F805: E6 9F     INC $9F       ; Tape Error log pass 2
F807: A4 9E     LDY $9E       ; Tape Error log pass 1
F809: D0 EC     BNE $F7F7

Jump from $F7F9:

F80B: 18        CLC

Jump from $F7ED:

F80C: 60        RTS



 $F80D/63501:   Bump Tape Pointer

Jump from $F199, $F1E5:

F80D: 20 D0 F7  JSR $F7D0     ; Get Buffer Address
F810: E6 A6     INC $A6       ; Pointer: Tape I/O buffer
F812: A4 A6     LDY $A6       ; Pointer: Tape I/O buffer
F814: C0 C0     CPY #$C0
F816: 60        RTS



 $F817/63511:   Print "PRESS PLAY ON TAPE"

Jump from $F399, $F541, $F84A:

F817: 20 2E F8  JSR $F82E     ; Check Tape Status
F81A: F0 1A     BEQ $F836     ; Check Tape Status
F81C: A0 1B     LDY #$1B

Jump from $F83F:

F81E: 20 2F F1  JSR $F12F     ; Print Message

Jump from $F827:

F821: 20 D0 F8  JSR $F8D0     ; Check Tape Stop
F824: 20 2E F8  JSR $F82E     ; Check Tape Status
F827: D0 F8     BNE $F821
F829: A0 6A     LDY #$6A
F82B: 4C 2F F1  JMP $F12F     ; Print Message



 $F82E/63534:   Check Tape Status

Jump from $F817, $F824, $F838:

F82E: A9 10     LDA #$10
F830: 24 01     BIT $01       ; 6510 On-chip 8-bit Input/Output Register
F832: D0 02     BNE $F836
F834: 24 01     BIT $01       ; 6510 On-chip 8-bit Input/Output Register

Jump from $F832, $F81A, $F83B:

F836: 18        CLC
F837: 60        RTS



 $F838/63544:   Print "PRESS RECORD..."

Jump from $F3B8, $F664, $F86B:

F838: 20 2E F8  JSR $F82E     ; Check Tape Status
F83B: F0 F9     BEQ $F836     ; Check Tape Status
F83D: A0 2E     LDY #$2E
F83F: D0 DD     BNE $F81E     ; Print "PRESS PLAY ON TAPE"



 $F841/63553:   Initiate Tape Read

Jump from $F19E, $F72F:

F841: A9 00     LDA #$00
F843: 85 90     STA $90       ; Kernal I/O Status Word ST
F845: 85 93     STA $93       ; Flag: 0 = Load, 1 = Verify
F847: 20 D7 F7  JSR $F7D7     ; Set Buffer Stat / End Pointers

Jump from $F5A5:

F84A: 20 17 F8  JSR $F817     ; Print "PRESS PLAY ON TAPE"
F84D: B0 1F     BCS $F86E     ; Initiate Tape Write
F84F: 78        SEI
F850: A9 00     LDA #$00
F852: 85 AA     STA $AA       ; RS232 Input Byte Buffer/Tape temporary
F854: 85 B4     STA $B4       ; RS232 Write bit count/Tape Read timing Flag
F856: 85 B0     STA $B0       ; Tape timing Constants
F858: 85 9E     STA $9E       ; Tape Error log pass 1
F85A: 85 9F     STA $9F       ; Tape Error log pass 2
F85C: 85 9C     STA $9C       ; Flag: Byte received from Tape
F85E: A9 90     LDA #$90
F860: A2 0E     LDX #$0E
F862: D0 11     BNE $F875     ; Common Tape Code



 $F864/63588:   Initiate Tape Write

Jump from $F1EA, $F2D7:

F864: 20 D7 F7  JSR $F7D7     ; Set Buffer Stat / End Pointers

Jump from $F67C:

F867: A9 14     LDA #$14
F869: 85 AB     STA $AB       ; RS232 Input parity/Tape temporary

Jump from $F7BE:

F86B: 20 38 F8  JSR $F838     ; Print "PRESS RECORD..."

Jump from $F84D:

F86E: B0 6C     BCS $F8DC     ; Check Tape Stop
F870: 78        SEI
F871: A9 82     LDA #$82
F873: A2 08     LDX #$08



 $F875/63605:   Common Tape Code

Jump from $F862:

F875: A0 7F     LDY #$7F
F877: 8C 0D DC  STY $DC0D     ; CIA1: Interrupt (IRQ) Control Register
F87A: 8D 0D DC  STA $DC0D     ; CIA1: Interrupt (IRQ) Control Register
F87D: AD 0E DC  LDA $DC0E     ; CIA1: Control Register A
F880: 09 19     ORA #$19
F882: 8D 0F DC  STA $DC0F     ; CIA1: Control Register B
F885: 29 91     AND #$91
F887: 8D A2 02  STA $02A2     ; TOD sense during Tape I/O
F88A: 20 A4 F0  JSR $F0A4     ; Serial Bus Idle
F88D: AD 11 D0  LDA $D011     ; VIC: Control Register 1
F890: 29 EF     AND #$EF
F892: 8D 11 D0  STA $D011     ; VIC: Control Register 1
F895: AD 14 03  LDA $0314     ; Vector: Hardware IRQ Interrupt Address
F898: 8D 9F 02  STA $029F     ; Temp. store for IRQ Vector during Tape I/O
F89B: AD 15 03  LDA $0315     ; Vector: Hardware IRQ Interrupt Address
F89E: 8D A0 02  STA $02A0     ; Temp. store for IRQ Vector during Tape I/O
F8A1: 20 BD FC  JSR $FCBD     ; Set IRQ Vector
F8A4: A9 02     LDA #$02
F8A6: 85 BE     STA $BE       ; Tape Input/Output Block count
F8A8: 20 97 FB  JSR $FB97     ; New Character Setup
F8AB: A5 01     LDA $01       ; 6510 On-chip 8-bit Input/Output Register
F8AD: 29 1F     AND #$1F
F8AF: 85 01     STA $01       ; 6510 On-chip 8-bit Input/Output Register
F8B1: 85 C0     STA $C0       ; Tape Motor Switch
F8B3: A2 FF     LDX #$FF

Jump from $F8BB:

F8B5: A0 FF     LDY #$FF

Jump from $F8B8:

F8B7: 88        DEY
F8B8: D0 FD     BNE $F8B7
F8BA: CA        DEX
F8BB: D0 F8     BNE $F8B5
F8BD: 58        CLI

Jump from $F8CD:

F8BE: AD A0 02  LDA $02A0     ; Temp. store for IRQ Vector during Tape I/O
F8C1: CD 15 03  CMP $0315     ; Vector: Hardware IRQ Interrupt Address
F8C4: 18        CLC
F8C5: F0 15     BEQ $F8DC     ; Check Tape Stop
F8C7: 20 D0 F8  JSR $F8D0     ; Check Tape Stop
F8CA: 20 BC F6  JSR $F6BC     ; Bump Clock
F8CD: 4C BE F8  JMP $F8BE



 $F8D0/63696:   Check Tape Stop

Jump from $F821, $F8C7:

F8D0: 20 E1 FF  JSR $FFE1     ; Test-Stop Vector
F8D3: 18        CLC
F8D4: D0 0B     BNE $F8E1
F8D6: 20 93 FC  JSR $FC93     ; Restore Normal IRQ
F8D9: 38        SEC
F8DA: 68        PLA
F8DB: 68        PLA

Jump from $F86E, $F8C5:

F8DC: A9 00     LDA #$00
F8DE: 8D A0 02  STA $02A0     ; Temp. store for IRQ Vector during Tape I/O

Jump from $F8D4:

F8E1: 60        RTS



 $F8E2/63714:   Set Read Timing

Jump from $F9CB, $FA0A, $FA2A, $FA67:

F8E2: 86 B1     STX $B1       ; Tape timing Constants
F8E4: A5 B0     LDA $B0       ; Tape timing Constants
F8E6: 0A        ASL
F8E7: 0A        ASL
F8E8: 18        CLC
F8E9: 65 B0     ADC $B0       ; Tape timing Constants
F8EB: 18        CLC
F8EC: 65 B1     ADC $B1       ; Tape timing Constants
F8EE: 85 B1     STA $B1       ; Tape timing Constants
F8F0: A9 00     LDA #$00
F8F2: 24 B0     BIT $B0       ; Tape timing Constants
F8F4: 30 01     BMI $F8F7
F8F6: 2A        ROL

Jump from $F8F4:

F8F7: 06 B1     ASL $B1       ; Tape timing Constants
F8F9: 2A        ROL
F8FA: 06 B1     ASL $B1       ; Tape timing Constants
F8FC: 2A        ROL
F8FD: AA        TAX

Jump from $F903:

F8FE: AD 06 DC  LDA $DC06     ; CIA1: Timer B Low-Byte  (Tape, Serial Port)
F901: C9 16     CMP #$16
F903: 90 F9     BCC $F8FE
F905: 65 B1     ADC $B1       ; Tape timing Constants
F907: 8D 04 DC  STA $DC04     ; CIA1: Timer A Low-Byte  (Kernal-IRQ, Tape)
F90A: 8A        TXA
F90B: 6D 07 DC  ADC $DC07     ; CIA1: Timer B High-Byte (Tape, Serial Port)
F90E: 8D 05 DC  STA $DC05     ; CIA1: Timer A High-Byte (Kernal-IRQ, Tape)
F911: AD A2 02  LDA $02A2     ; TOD sense during Tape I/O
F914: 8D 0E DC  STA $DC0E     ; CIA1: Control Register A
F917: 8D A4 02  STA $02A4     ; Temporary D1IRQ Indicator during Tape READ
F91A: AD 0D DC  LDA $DC0D     ; CIA1: Interrupt (IRQ) Control Register
F91D: 29 10     AND #$10
F91F: F0 09     BEQ $F92A
F921: A9 F9     LDA #$F9
F923: 48        PHA
F924: A9 2A     LDA #$2A
F926: 48        PHA
F927: 4C 43 FF  JMP $FF43     ; Fake IRQ Entry

Jump from $F91F:

F92A: 58        CLI
F92B: 60        RTS



 $F92C/63788:   Read Tape Bits

Jump from $F938:

F92C: AE 07 DC  LDX $DC07     ; CIA1: Timer B High-Byte (Tape, Serial Port)
F92F: A0 FF     LDY #$FF
F931: 98        TYA
F932: ED 06 DC  SBC $DC06     ; CIA1: Timer B Low-Byte  (Tape, Serial Port)
F935: EC 07 DC  CPX $DC07     ; CIA1: Timer B High-Byte (Tape, Serial Port)
F938: D0 F2     BNE $F92C
F93A: 86 B1     STX $B1       ; Tape timing Constants
F93C: AA        TAX
F93D: 8C 06 DC  STY $DC06     ; CIA1: Timer B Low-Byte  (Tape, Serial Port)
F940: 8C 07 DC  STY $DC07     ; CIA1: Timer B High-Byte (Tape, Serial Port)
F943: A9 19     LDA #$19
F945: 8D 0F DC  STA $DC0F     ; CIA1: Control Register B
F948: AD 0D DC  LDA $DC0D     ; CIA1: Interrupt (IRQ) Control Register
F94B: 8D A3 02  STA $02A3     ; Temporary storage during Tape READ
F94E: 98        TYA
F94F: E5 B1     SBC $B1       ; Tape timing Constants
F951: 86 B1     STX $B1       ; Tape timing Constants
F953: 4A        LSR
F954: 66 B1     ROR $B1       ; Tape timing Constants
F956: 4A        LSR
F957: 66 B1     ROR $B1       ; Tape timing Constants
F959: A5 B0     LDA $B0       ; Tape timing Constants
F95B: 18        CLC
F95C: 69 3C     ADC #$3C
F95E: C5 B1     CMP $B1       ; Tape timing Constants
F960: B0 4A     BCS $F9AC
F962: A6 9C     LDX $9C       ; Flag: Byte received from Tape
F964: F0 03     BEQ $F969
F966: 4C 60 FA  JMP $FA60     ; Store Tape Characters

Jump from $F964:

F969: A6 A3     LDX $A3       ; Serial Bus EOI (End Of Input) Flag
F96B: 30 1B     BMI $F988
F96D: A2 00     LDX #$00
F96F: 69 30     ADC #$30
F971: 65 B0     ADC $B0       ; Tape timing Constants
F973: C5 B1     CMP $B1       ; Tape timing Constants
F975: B0 1C     BCS $F993
F977: E8        INX
F978: 69 26     ADC #$26
F97A: 65 B0     ADC $B0       ; Tape timing Constants
F97C: C5 B1     CMP $B1       ; Tape timing Constants
F97E: B0 17     BCS $F997
F980: 69 2C     ADC #$2C
F982: 65 B0     ADC $B0       ; Tape timing Constants
F984: C5 B1     CMP $B1       ; Tape timing Constants
F986: 90 03     BCC $F98B

Jump from $F96B, $F9C7:

F988: 4C 10 FA  JMP $FA10

Jump from $F986, $F9D0, $F9E9:

F98B: A5 B4     LDA $B4       ; RS232 Write bit count/Tape Read timing Flag
F98D: F0 1D     BEQ $F9AC
F98F: 85 A8     STA $A8       ; RS232 Input Bit count/Tape temporary
F991: D0 19     BNE $F9AC

Jump from $F975:

F993: E6 A9     INC $A9       ; RS232 Flag: Start Bit check/Tape temporary
F995: B0 02     BCS $F999

Jump from $F97E, $FA1C:

F997: C6 A9     DEC $A9       ; RS232 Flag: Start Bit check/Tape temporary

Jump from $F995:

F999: 38        SEC
F99A: E9 13     SBC #$13
F99C: E5 B1     SBC $B1       ; Tape timing Constants
F99E: 65 92     ADC $92       ; Timing Constant for Tape
F9A0: 85 92     STA $92       ; Timing Constant for Tape
F9A2: A5 A4     LDA $A4       ; Serial Bus shift Counter
F9A4: 49 01     EOR #$01
F9A6: 85 A4     STA $A4       ; Serial Bus shift Counter
F9A8: F0 2B     BEQ $F9D5
F9AA: 86 D7     STX $D7       ; Current Input Character/Last Character Output

Jump from $F960, $F98D, $F991, $F9ED, $F9F1, $F9F5:

F9AC: A5 B4     LDA $B4       ; RS232 Write bit count/Tape Read timing Flag
F9AE: F0 22     BEQ $F9D2
F9B0: AD A3 02  LDA $02A3     ; Temporary storage during Tape READ
F9B3: 29 01     AND #$01
F9B5: D0 05     BNE $F9BC
F9B7: AD A4 02  LDA $02A4     ; Temporary D1IRQ Indicator during Tape READ
F9BA: D0 16     BNE $F9D2

Jump from $F9B5:

F9BC: A9 00     LDA #$00
F9BE: 85 A4     STA $A4       ; Serial Bus shift Counter
F9C0: 8D A4 02  STA $02A4     ; Temporary D1IRQ Indicator during Tape READ
F9C3: A5 A3     LDA $A3       ; Serial Bus EOI (End Of Input) Flag
F9C5: 10 30     BPL $F9F7
F9C7: 30 BF     BMI $F988

Jump from $FA02:

F9C9: A2 A6     LDX #$A6
F9CB: 20 E2 F8  JSR $F8E2     ; Set Read Timing
F9CE: A5 9B     LDA $9B       ; Parity of Byte Output to Tape
F9D0: D0 B9     BNE $F98B

Jump from $F9AE, $F9BA, $F9FE:

F9D2: 4C BC FE  JMP $FEBC     ; Exit Interrupt

Jump from $F9A8:

F9D5: A5 92     LDA $92       ; Timing Constant for Tape
F9D7: F0 07     BEQ $F9E0
F9D9: 30 03     BMI $F9DE
F9DB: C6 B0     DEC $B0       ; Tape timing Constants
F9DD: 2C        .BYTE $2C

Jump from $F9D9:

F9DE: E6 B0     INC $B0       ; Tape timing Constants

Jump from $F9D7:

F9E0: A9 00     LDA #$00
F9E2: 85 92     STA $92       ; Timing Constant for Tape
F9E4: E4 D7     CPX $D7       ; Current Input Character/Last Character Output
F9E6: D0 0F     BNE $F9F7
F9E8: 8A        TXA
F9E9: D0 A0     BNE $F98B
F9EB: A5 A9     LDA $A9       ; RS232 Flag: Start Bit check/Tape temporary
F9ED: 30 BD     BMI $F9AC
F9EF: C9 10     CMP #$10
F9F1: 90 B9     BCC $F9AC
F9F3: 85 96     STA $96       ; Cassette Sync number
F9F5: B0 B5     BCS $F9AC

Jump from $F9C5, $F9E6:

F9F7: 8A        TXA
F9F8: 45 9B     EOR $9B       ; Parity of Byte Output to Tape
F9FA: 85 9B     STA $9B       ; Parity of Byte Output to Tape
F9FC: A5 B4     LDA $B4       ; RS232 Write bit count/Tape Read timing Flag
F9FE: F0 D2     BEQ $F9D2
FA00: C6 A3     DEC $A3       ; Serial Bus EOI (End Of Input) Flag
FA02: 30 C5     BMI $F9C9
FA04: 46 D7     LSR $D7       ; Current Input Character/Last Character Output
FA06: 66 BF     ROR $BF       ; Serial Word Buffer
FA08: A2 DA     LDX #$DA
FA0A: 20 E2 F8  JSR $F8E2     ; Set Read Timing
FA0D: 4C BC FE  JMP $FEBC     ; Exit Interrupt

Jump from $F988:

FA10: A5 96     LDA $96       ; Cassette Sync number
FA12: F0 04     BEQ $FA18
FA14: A5 B4     LDA $B4       ; RS232 Write bit count/Tape Read timing Flag
FA16: F0 07     BEQ $FA1F

Jump from $FA12:

FA18: A5 A3     LDA $A3       ; Serial Bus EOI (End Of Input) Flag
FA1A: 30 03     BMI $FA1F
FA1C: 4C 97 F9  JMP $F997

Jump from $FA16, $FA1A:

FA1F: 46 B1     LSR $B1       ; Tape timing Constants
FA21: A9 93     LDA #$93
FA23: 38        SEC
FA24: E5 B1     SBC $B1       ; Tape timing Constants
FA26: 65 B0     ADC $B0       ; Tape timing Constants
FA28: 0A        ASL
FA29: AA        TAX
FA2A: 20 E2 F8  JSR $F8E2     ; Set Read Timing
FA2D: E6 9C     INC $9C       ; Flag: Byte received from Tape
FA2F: A5 B4     LDA $B4       ; RS232 Write bit count/Tape Read timing Flag
FA31: D0 11     BNE $FA44
FA33: A5 96     LDA $96       ; Cassette Sync number
FA35: F0 26     BEQ $FA5D
FA37: 85 A8     STA $A8       ; RS232 Input Bit count/Tape temporary
FA39: A9 00     LDA #$00
FA3B: 85 96     STA $96       ; Cassette Sync number
FA3D: A9 81     LDA #$81
FA3F: 8D 0D DC  STA $DC0D     ; CIA1: Interrupt (IRQ) Control Register
FA42: 85 B4     STA $B4       ; RS232 Write bit count/Tape Read timing Flag

Jump from $FA31:

FA44: A5 96     LDA $96       ; Cassette Sync number
FA46: 85 B5     STA $B5       ; RS232 Next Bit to send/Tape Read - End of Tape
FA48: F0 09     BEQ $FA53
FA4A: A9 00     LDA #$00
FA4C: 85 B4     STA $B4       ; RS232 Write bit count/Tape Read timing Flag
FA4E: A9 01     LDA #$01
FA50: 8D 0D DC  STA $DC0D     ; CIA1: Interrupt (IRQ) Control Register

Jump from $FA48:

FA53: A5 BF     LDA $BF       ; Serial Word Buffer
FA55: 85 BD     STA $BD       ; RS232 Output Parity/Tape Byte temporary
FA57: A5 A8     LDA $A8       ; RS232 Input Bit count/Tape temporary
FA59: 05 A9     ORA $A9       ; RS232 Flag: Start Bit check/Tape temporary
FA5B: 85 B6     STA $B6       ; RS232 Output Byte Buffer/Tape Read Error Flag

Jump from $FA35:

FA5D: 4C BC FE  JMP $FEBC     ; Exit Interrupt



 $FA60/64096:   Store Tape Characters

Jump from $F966:

FA60: 20 97 FB  JSR $FB97     ; New Character Setup
FA63: 85 9C     STA $9C       ; Flag: Byte received from Tape
FA65: A2 DA     LDX #$DA
FA67: 20 E2 F8  JSR $F8E2     ; Set Read Timing
FA6A: A5 BE     LDA $BE       ; Tape Input/Output Block count
FA6C: F0 02     BEQ $FA70
FA6E: 85 A7     STA $A7       ; Tape temporary

Jump from $FA6C:

FA70: A9 0F     LDA #$0F
FA72: 24 AA     BIT $AA       ; RS232 Input Byte Buffer/Tape temporary
FA74: 10 17     BPL $FA8D
FA76: A5 B5     LDA $B5       ; RS232 Next Bit to send/Tape Read - End of Tape
FA78: D0 0C     BNE $FA86
FA7A: A6 BE     LDX $BE       ; Tape Input/Output Block count
FA7C: CA        DEX
FA7D: D0 0B     BNE $FA8A
FA7F: A9 08     LDA #$08
FA81: 20 1C FE  JSR $FE1C     ; Control OS Messages
FA84: D0 04     BNE $FA8A

Jump from $FA78:

FA86: A9 00     LDA #$00
FA88: 85 AA     STA $AA       ; RS232 Input Byte Buffer/Tape temporary

Jump from $FA7D, $FA84, $FA93, $FA97, $FAAB, $FAB8, $FABE:

FA8A: 4C BC FE  JMP $FEBC     ; Exit Interrupt

Jump from $FA74:

FA8D: 70 31     BVS $FAC0
FA8F: D0 18     BNE $FAA9
FA91: A5 B5     LDA $B5       ; RS232 Next Bit to send/Tape Read - End of Tape
FA93: D0 F5     BNE $FA8A
FA95: A5 B6     LDA $B6       ; RS232 Output Byte Buffer/Tape Read Error Flag
FA97: D0 F1     BNE $FA8A
FA99: A5 A7     LDA $A7       ; Tape temporary
FA9B: 4A        LSR
FA9C: A5 BD     LDA $BD       ; RS232 Output Parity/Tape Byte temporary
FA9E: 30 03     BMI $FAA3
FAA0: 90 18     BCC $FABA
FAA2: 18        CLC

Jump from $FA9E:

FAA3: B0 15     BCS $FABA
FAA5: 29 0F     AND #$0F
FAA7: 85 AA     STA $AA       ; RS232 Input Byte Buffer/Tape temporary

Jump from $FA8F:

FAA9: C6 AA     DEC $AA       ; RS232 Input Byte Buffer/Tape temporary
FAAB: D0 DD     BNE $FA8A
FAAD: A9 40     LDA #$40
FAAF: 85 AA     STA $AA       ; RS232 Input Byte Buffer/Tape temporary
FAB1: 20 8E FB  JSR $FB8E     ; Reset Tape Pointer
FAB4: A9 00     LDA #$00
FAB6: 85 AB     STA $AB       ; RS232 Input parity/Tape temporary
FAB8: F0 D0     BEQ $FA8A

Jump from $FAA0, $FAA3:

FABA: A9 80     LDA #$80
FABC: 85 AA     STA $AA       ; RS232 Input Byte Buffer/Tape temporary
FABE: D0 CA     BNE $FA8A

Jump from $FA8D:

FAC0: A5 B5     LDA $B5       ; RS232 Next Bit to send/Tape Read - End of Tape
FAC2: F0 0A     BEQ $FACE
FAC4: A9 04     LDA #$04
FAC6: 20 1C FE  JSR $FE1C     ; Control OS Messages
FAC9: A9 00     LDA #$00
FACB: 4C 4A FB  JMP $FB4A

Jump from $FAC2:

FACE: 20 D1 FC  JSR $FCD1     ; Check Read / Write Pointer
FAD1: 90 03     BCC $FAD6
FAD3: 4C 48 FB  JMP $FB48

Jump from $FAD1:

FAD6: A6 A7     LDX $A7       ; Tape temporary
FAD8: CA        DEX
FAD9: F0 2D     BEQ $FB08
FADB: A5 93     LDA $93       ; Flag: 0 = Load, 1 = Verify
FADD: F0 0C     BEQ $FAEB
FADF: A0 00     LDY #$00
FAE1: A5 BD     LDA $BD       ; RS232 Output Parity/Tape Byte temporary
FAE3: D1 AC     CMP ($AC),Y   ; Pointer: Tape Buffer/Screen scrolling
FAE5: F0 04     BEQ $FAEB
FAE7: A9 01     LDA #$01
FAE9: 85 B6     STA $B6       ; RS232 Output Byte Buffer/Tape Read Error Flag

Jump from $FADD, $FAE5:

FAEB: A5 B6     LDA $B6       ; RS232 Output Byte Buffer/Tape Read Error Flag
FAED: F0 4B     BEQ $FB3A
FAEF: A2 3D     LDX #$3D
FAF1: E4 9E     CPX $9E       ; Tape Error log pass 1
FAF3: 90 3E     BCC $FB33
FAF5: A6 9E     LDX $9E       ; Tape Error log pass 1
FAF7: A5 AD     LDA $AD       ; Pointer: Tape Buffer/Screen scrolling
FAF9: 9D 01 01  STA $0101,X   ; 6510 Hardware Stack Area
FAFC: A5 AC     LDA $AC       ; Pointer: Tape Buffer/Screen scrolling
FAFE: 9D 00 01  STA $0100,X   ; 6510 Hardware Stack Area
FB01: E8        INX
FB02: E8        INX
FB03: 86 9E     STX $9E       ; Tape Error log pass 1
FB05: 4C 3A FB  JMP $FB3A

Jump from $FAD9:

FB08: A6 9F     LDX $9F       ; Tape Error log pass 2
FB0A: E4 9E     CPX $9E       ; Tape Error log pass 1
FB0C: F0 35     BEQ $FB43
FB0E: A5 AC     LDA $AC       ; Pointer: Tape Buffer/Screen scrolling
FB10: DD 00 01  CMP $0100,X   ; 6510 Hardware Stack Area
FB13: D0 2E     BNE $FB43
FB15: A5 AD     LDA $AD       ; Pointer: Tape Buffer/Screen scrolling
FB17: DD 01 01  CMP $0101,X   ; 6510 Hardware Stack Area
FB1A: D0 27     BNE $FB43
FB1C: E6 9F     INC $9F       ; Tape Error log pass 2
FB1E: E6 9F     INC $9F       ; Tape Error log pass 2
FB20: A5 93     LDA $93       ; Flag: 0 = Load, 1 = Verify
FB22: F0 0B     BEQ $FB2F
FB24: A5 BD     LDA $BD       ; RS232 Output Parity/Tape Byte temporary
FB26: A0 00     LDY #$00
FB28: D1 AC     CMP ($AC),Y   ; Pointer: Tape Buffer/Screen scrolling
FB2A: F0 17     BEQ $FB43
FB2C: C8        INY
FB2D: 84 B6     STY $B6       ; RS232 Output Byte Buffer/Tape Read Error Flag

Jump from $FB22:

FB2F: A5 B6     LDA $B6       ; RS232 Output Byte Buffer/Tape Read Error Flag
FB31: F0 07     BEQ $FB3A

Jump from $FAF3:

FB33: A9 10     LDA #$10
FB35: 20 1C FE  JSR $FE1C     ; Control OS Messages
FB38: D0 09     BNE $FB43

Jump from $FAED, $FB05, $FB31:

FB3A: A5 93     LDA $93       ; Flag: 0 = Load, 1 = Verify
FB3C: D0 05     BNE $FB43
FB3E: A8        TAY
FB3F: A5 BD     LDA $BD       ; RS232 Output Parity/Tape Byte temporary
FB41: 91 AC     STA ($AC),Y   ; Pointer: Tape Buffer/Screen scrolling

Jump from $FB0C, $FB13, $FB1A, $FB2A, $FB38, $FB3C:

FB43: 20 DB FC  JSR $FCDB     ; Bump Read / Write Pointer
FB46: D0 43     BNE $FB8B

Jump from $FAD3:

FB48: A9 80     LDA #$80

Jump from $FACB:

FB4A: 85 AA     STA $AA       ; RS232 Input Byte Buffer/Tape temporary
FB4C: 78        SEI
FB4D: A2 01     LDX #$01
FB4F: 8E 0D DC  STX $DC0D     ; CIA1: Interrupt (IRQ) Control Register
FB52: AE 0D DC  LDX $DC0D     ; CIA1: Interrupt (IRQ) Control Register
FB55: A6 BE     LDX $BE       ; Tape Input/Output Block count
FB57: CA        DEX
FB58: 30 02     BMI $FB5C
FB5A: 86 BE     STX $BE       ; Tape Input/Output Block count

Jump from $FB58:

FB5C: C6 A7     DEC $A7       ; Tape temporary
FB5E: F0 08     BEQ $FB68
FB60: A5 9E     LDA $9E       ; Tape Error log pass 1
FB62: D0 27     BNE $FB8B
FB64: 85 BE     STA $BE       ; Tape Input/Output Block count
FB66: F0 23     BEQ $FB8B

Jump from $FB5E:

FB68: 20 93 FC  JSR $FC93     ; Restore Normal IRQ
FB6B: 20 8E FB  JSR $FB8E     ; Reset Tape Pointer
FB6E: A0 00     LDY #$00
FB70: 84 AB     STY $AB       ; RS232 Input parity/Tape temporary

Jump from $FB7E:

FB72: B1 AC     LDA ($AC),Y   ; Pointer: Tape Buffer/Screen scrolling
FB74: 45 AB     EOR $AB       ; RS232 Input parity/Tape temporary
FB76: 85 AB     STA $AB       ; RS232 Input parity/Tape temporary
FB78: 20 DB FC  JSR $FCDB     ; Bump Read / Write Pointer
FB7B: 20 D1 FC  JSR $FCD1     ; Check Read / Write Pointer
FB7E: 90 F2     BCC $FB72
FB80: A5 AB     LDA $AB       ; RS232 Input parity/Tape temporary
FB82: 45 BD     EOR $BD       ; RS232 Output Parity/Tape Byte temporary
FB84: F0 05     BEQ $FB8B
FB86: A9 20     LDA #$20
FB88: 20 1C FE  JSR $FE1C     ; Control OS Messages

Jump from $FB46, $FB62, $FB66, $FB84:

FB8B: 4C BC FE  JMP $FEBC     ; Exit Interrupt



 $FB8E/64398:   Reset Tape Pointer

Jump from $F617, $FAB1, $FB6B, $FC88:

FB8E: A5 C2     LDA $C2       ; Start Address for LOAD and Cassette Write
FB90: 85 AD     STA $AD       ; Pointer: Tape Buffer/Screen scrolling
FB92: A5 C1     LDA $C1       ; Start Address for LOAD and Cassette Write
FB94: 85 AC     STA $AC       ; Pointer: Tape Buffer/Screen scrolling
FB96: 60        RTS



 $FB97/64407:   New Character Setup

Jump from $F8A8, $FA60, $FC16, $FC75:

FB97: A9 08     LDA #$08
FB99: 85 A3     STA $A3       ; Serial Bus EOI (End Of Input) Flag
FB9B: A9 00     LDA #$00
FB9D: 85 A4     STA $A4       ; Serial Bus shift Counter
FB9F: 85 A8     STA $A8       ; RS232 Input Bit count/Tape temporary
FBA1: 85 9B     STA $9B       ; Parity of Byte Output to Tape
FBA3: 85 A9     STA $A9       ; RS232 Flag: Start Bit check/Tape temporary
FBA5: 60        RTS



 $FBA6/64422:   Send Tone to Tape

Jump from $FBF0:

FBA6: A5 BD     LDA $BD       ; RS232 Output Parity/Tape Byte temporary
FBA8: 4A        LSR
FBA9: A9 60     LDA #$60
FBAB: 90 02     BCC $FBAF

Jump from $FBE7:

FBAD: A9 B0     LDA #$B0

Jump from $FBAB, $FC6C:

FBAF: A2 00     LDX #$00

Jump from $FBD5:

FBB1: 8D 06 DC  STA $DC06     ; CIA1: Timer B Low-Byte  (Tape, Serial Port)
FBB4: 8E 07 DC  STX $DC07     ; CIA1: Timer B High-Byte (Tape, Serial Port)
FBB7: AD 0D DC  LDA $DC0D     ; CIA1: Interrupt (IRQ) Control Register
FBBA: A9 19     LDA #$19
FBBC: 8D 0F DC  STA $DC0F     ; CIA1: Control Register B
FBBF: A5 01     LDA $01       ; 6510 On-chip 8-bit Input/Output Register
FBC1: 49 08     EOR #$08
FBC3: 85 01     STA $01       ; 6510 On-chip 8-bit Input/Output Register
FBC5: 29 08     AND #$08
FBC7: 60        RTS



 $FBC8/64456:   Write Data to Tape

Jump from $FC35:

FBC8: 38        SEC
FBC9: 66 B6     ROR $B6       ; RS232 Output Byte Buffer/Tape Read Error Flag
FBCB: 30 3C     BMI $FC09     ; IRQ Entry Point



 $FBCD/64461:   IRQ Entry Point

FBCD: A5 A8     LDA $A8       ; RS232 Input Bit count/Tape temporary
FBCF: D0 12     BNE $FBE3
FBD1: A9 10     LDA #$10
FBD3: A2 01     LDX #$01
FBD5: 20 B1 FB  JSR $FBB1     ; Send Tone to Tape
FBD8: D0 2F     BNE $FC09
FBDA: E6 A8     INC $A8       ; RS232 Input Bit count/Tape temporary
FBDC: A5 B6     LDA $B6       ; RS232 Output Byte Buffer/Tape Read Error Flag
FBDE: 10 29     BPL $FC09
FBE0: 4C 57 FC  JMP $FC57     ; Write Tape Leader

Jump from $FBCF:

FBE3: A5 A9     LDA $A9       ; RS232 Flag: Start Bit check/Tape temporary
FBE5: D0 09     BNE $FBF0
FBE7: 20 AD FB  JSR $FBAD     ; Send Tone to Tape
FBEA: D0 1D     BNE $FC09
FBEC: E6 A9     INC $A9       ; RS232 Flag: Start Bit check/Tape temporary
FBEE: D0 19     BNE $FC09

Jump from $FBE5:

FBF0: 20 A6 FB  JSR $FBA6     ; Send Tone to Tape
FBF3: D0 14     BNE $FC09
FBF5: A5 A4     LDA $A4       ; Serial Bus shift Counter
FBF7: 49 01     EOR #$01
FBF9: 85 A4     STA $A4       ; Serial Bus shift Counter
FBFB: F0 0F     BEQ $FC0C
FBFD: A5 BD     LDA $BD       ; RS232 Output Parity/Tape Byte temporary
FBFF: 49 01     EOR #$01
FC01: 85 BD     STA $BD       ; RS232 Output Parity/Tape Byte temporary
FC03: 29 01     AND #$01
FC05: 45 9B     EOR $9B       ; Parity of Byte Output to Tape
FC07: 85 9B     STA $9B       ; Parity of Byte Output to Tape

Jump from $FBD8, $FBDE, $FBEA, $FBEE, $FBF3, $FC14, $FC2E, $FC3D, $FC4C, $FBCB:

FC09: 4C BC FE  JMP $FEBC     ; Exit Interrupt

Jump from $FBFB:

FC0C: 46 BD     LSR $BD       ; RS232 Output Parity/Tape Byte temporary
FC0E: C6 A3     DEC $A3       ; Serial Bus EOI (End Of Input) Flag
FC10: A5 A3     LDA $A3       ; Serial Bus EOI (End Of Input) Flag
FC12: F0 3A     BEQ $FC4E
FC14: 10 F3     BPL $FC09

Jump from $FC91:

FC16: 20 97 FB  JSR $FB97     ; New Character Setup
FC19: 58        CLI
FC1A: A5 A5     LDA $A5       ; Tape Synchronising count down
FC1C: F0 12     BEQ $FC30
FC1E: A2 00     LDX #$00
FC20: 86 D7     STX $D7       ; Current Input Character/Last Character Output
FC22: C6 A5     DEC $A5       ; Tape Synchronising count down
FC24: A6 BE     LDX $BE       ; Tape Input/Output Block count
FC26: E0 02     CPX #$02
FC28: D0 02     BNE $FC2C
FC2A: 09 80     ORA #$80

Jump from $FC28:

FC2C: 85 BD     STA $BD       ; RS232 Output Parity/Tape Byte temporary
FC2E: D0 D9     BNE $FC09

Jump from $FC1C:

FC30: 20 D1 FC  JSR $FCD1     ; Check Read / Write Pointer
FC33: 90 0A     BCC $FC3F
FC35: D0 91     BNE $FBC8     ; Write Data to Tape
FC37: E6 AD     INC $AD       ; Pointer: Tape Buffer/Screen scrolling
FC39: A5 D7     LDA $D7       ; Current Input Character/Last Character Output
FC3B: 85 BD     STA $BD       ; RS232 Output Parity/Tape Byte temporary
FC3D: B0 CA     BCS $FC09

Jump from $FC33:

FC3F: A0 00     LDY #$00
FC41: B1 AC     LDA ($AC),Y   ; Pointer: Tape Buffer/Screen scrolling
FC43: 85 BD     STA $BD       ; RS232 Output Parity/Tape Byte temporary
FC45: 45 D7     EOR $D7       ; Current Input Character/Last Character Output
FC47: 85 D7     STA $D7       ; Current Input Character/Last Character Output
FC49: 20 DB FC  JSR $FCDB     ; Bump Read / Write Pointer
FC4C: D0 BB     BNE $FC09

Jump from $FC12:

FC4E: A5 9B     LDA $9B       ; Parity of Byte Output to Tape
FC50: 49 01     EOR #$01
FC52: 85 BD     STA $BD       ; RS232 Output Parity/Tape Byte temporary

Jump from $FC68, $FC6F, $FC73, $FC7A, $FCBB:

FC54: 4C BC FE  JMP $FEBC     ; Exit Interrupt



 $FC57/64599:   Write Tape Leader

Jump from $FBE0:

FC57: C6 BE     DEC $BE       ; Tape Input/Output Block count
FC59: D0 03     BNE $FC5E
FC5B: 20 CA FC  JSR $FCCA     ; Stop Tape Motor

Jump from $FC59:

FC5E: A9 50     LDA #$50
FC60: 85 A7     STA $A7       ; Tape temporary
FC62: A2 08     LDX #$08
FC64: 78        SEI
FC65: 20 BD FC  JSR $FCBD     ; Set IRQ Vector
FC68: D0 EA     BNE $FC54     ; IRQ Entry Point
FC6A: A9 78     LDA #$78
FC6C: 20 AF FB  JSR $FBAF     ; Send Tone to Tape
FC6F: D0 E3     BNE $FC54     ; IRQ Entry Point
FC71: C6 A7     DEC $A7       ; Tape temporary
FC73: D0 DF     BNE $FC54     ; IRQ Entry Point
FC75: 20 97 FB  JSR $FB97     ; New Character Setup
FC78: C6 AB     DEC $AB       ; RS232 Input parity/Tape temporary
FC7A: 10 D8     BPL $FC54     ; IRQ Entry Point
FC7C: A2 0A     LDX #$0A
FC7E: 20 BD FC  JSR $FCBD     ; Set IRQ Vector
FC81: 58        CLI
FC82: E6 AB     INC $AB       ; RS232 Input parity/Tape temporary
FC84: A5 BE     LDA $BE       ; Tape Input/Output Block count
FC86: F0 30     BEQ $FCB8     ; Set IRQ Vector
FC88: 20 8E FB  JSR $FB8E     ; Reset Tape Pointer
FC8B: A2 09     LDX #$09
FC8D: 86 A5     STX $A5       ; Tape Synchronising count down
FC8F: 86 B6     STX $B6       ; RS232 Output Byte Buffer/Tape Read Error Flag
FC91: D0 83     BNE $FC16     ; IRQ Entry Point



 $FC93/64659:   Restore Normal IRQ

Jump from $F8D6, $FB68, $FCB8:

FC93: 08        PHP
FC94: 78        SEI
FC95: AD 11 D0  LDA $D011     ; VIC: Control Register 1
FC98: 09 10     ORA #$10
FC9A: 8D 11 D0  STA $D011     ; VIC: Control Register 1
FC9D: 20 CA FC  JSR $FCCA     ; Stop Tape Motor
FCA0: A9 7F     LDA #$7F
FCA2: 8D 0D DC  STA $DC0D     ; CIA1: Interrupt (IRQ) Control Register
FCA5: 20 DD FD  JSR $FDDD     ; Enable Timer
FCA8: AD A0 02  LDA $02A0     ; Temp. store for IRQ Vector during Tape I/O
FCAB: F0 09     BEQ $FCB6
FCAD: 8D 15 03  STA $0315     ; Vector: Hardware IRQ Interrupt Address
FCB0: AD 9F 02  LDA $029F     ; Temp. store for IRQ Vector during Tape I/O
FCB3: 8D 14 03  STA $0314     ; Vector: Hardware IRQ Interrupt Address

Jump from $FCAB:

FCB6: 28        PLP
FCB7: 60        RTS



 $FCB8/64696:   Set IRQ Vector

Jump from $FC86:

FCB8: 20 93 FC  JSR $FC93     ; Restore Normal IRQ
FCBB: F0 97     BEQ $FC54     ; IRQ Entry Point

Jump from $F8A1, $FC65, $FC7E:

FCBD: BD 93 FD  LDA $FD93,X   ; Initialise System Constants
FCC0: 8D 14 03  STA $0314     ; Vector: Hardware IRQ Interrupt Address
FCC3: BD 94 FD  LDA $FD94,X   ; Initialise System Constants
FCC6: 8D 15 03  STA $0315     ; Vector: Hardware IRQ Interrupt Address
FCC9: 60        RTS



 $FCCA/64714:   Stop Tape Motor

Jump from $FC5B, $FC9D:

FCCA: A5 01     LDA $01       ; 6510 On-chip 8-bit Input/Output Register
FCCC: 09 20     ORA #$20
FCCE: 85 01     STA $01       ; 6510 On-chip 8-bit Input/Output Register
FCD0: 60        RTS



 $FCD1/64721:   Check Read / Write Pointer

Jump from $F624, $FACE, $FB7B, $FC30:

FCD1: 38        SEC
FCD2: A5 AC     LDA $AC       ; Pointer: Tape Buffer/Screen scrolling
FCD4: E5 AE     SBC $AE       ; Tape End Address/End of Program
FCD6: A5 AD     LDA $AD       ; Pointer: Tape Buffer/Screen scrolling
FCD8: E5 AF     SBC $AF       ; Tape End Address/End of Program
FCDA: 60        RTS



 $FCDB/64731:   Bump Read / Write Pointer

Jump from $F63A, $FB43, $FB78, $FC49:

FCDB: E6 AC     INC $AC       ; Pointer: Tape Buffer/Screen scrolling
FCDD: D0 02     BNE $FCE1
FCDF: E6 AD     INC $AD       ; Pointer: Tape Buffer/Screen scrolling

Jump from $FCDD:

FCE1: 60        RTS



 $FCE2/64738:   Power-Up RESET Entry

FCE2: A2 FF     LDX #$FF
FCE4: 78        SEI
FCE5: 9A        TXS
FCE6: D8        CLD
FCE7: 20 02 FD  JSR $FD02     ; Check For 8-ROM
FCEA: D0 03     BNE $FCEF
FCEC: 6C 00 80  JMP ($8000)

Jump from $FCEA:

FCEF: 8E 16 D0  STX $D016     ; VIC: Control Register 2
FCF2: 20 A3 FD  JSR $FDA3     ; Initialise I/O
FCF5: 20 50 FD  JSR $FD50     ; Initialise System Constants
FCF8: 20 15 FD  JSR $FD15     ; Restore Kernal Vectors
FCFB: 20 5B FF  JSR $FF5B     ; Initialize screen editor
FCFE: 58        CLI
FCFF: 6C 00 A0  JMP ($A000)   ; Restart Vectors



 $FD02/64770:   Check For 8-ROM

Jump from $FCE7, $FE56:

FD02: A2 05     LDX #$05

Jump from $FD0D:

FD04: BD 0F FD  LDA $FD0F,X
FD07: DD 03 80  CMP $8003,X
FD0A: D0 03     BNE $FD0F
FD0C: CA        DEX
FD0D: D0 F5     BNE $FD04

Jump from $FD0A:

FD0F: 60        RTS


Kernal-Reference:

 LDA $FD0F,X : $FD04


 $FD10/64784:   8-ROM Mask 'CBM80'

FD10: C3 C2 CD 38 30             'CBM80'



 $FD15/64789:   Restore Kernal Vectors

Jump from $FCF8, $FE66, $FF8A:

FD15: A2 30     LDX #$30
FD17: A0 FD     LDY #$FD
FD19: 18        CLC



 $FD1A/64794:   Change Vectors For User

Jump from $FF8D:

FD1A: 86 C3     STX $C3       ; Pointer: Type 3 Tape LOAD and general use
FD1C: 84 C4     STY $C4       ; Pointer: Type 3 Tape LOAD and general use
FD1E: A0 1F     LDY #$1F

Jump from $FD2D:

FD20: B9 14 03  LDA $0314,Y   ; Vector: Hardware IRQ Interrupt Address
FD23: B0 02     BCS $FD27
FD25: B1 C3     LDA ($C3),Y   ; Pointer: Type 3 Tape LOAD and general use

Jump from $FD23:

FD27: 91 C3     STA ($C3),Y   ; Pointer: Type 3 Tape LOAD and general use
FD29: 99 14 03  STA $0314,Y   ; Vector: Hardware IRQ Interrupt Address
FD2C: 88        DEY
FD2D: 10 F1     BPL $FD20
FD2F: 60        RTS



 $FD30/64816:   Kernal Reset Vectors

FD30: 31 EA 66 FE 47 FE 4A F3    $EA31,$FE66,$FE47,$F34A
FD38: 91 F2 0E F2 50 F2 33 F3    $F291,$F20E,$F250,$F333
FD40: 57 F1 CA F1 ED F6 3E F1    $F157,$F1CA,$F6ED,$F13E
FD48: 2F F3 66 FE A5 F4 ED F5    $F32F,$FE66,$F4A5,$F5ED



 $FD50/64848:   Initialise System Constants

Jump from $FCF5, $FF87:

FD50: A9 00     LDA #$00
FD52: A8        TAY

Jump from $FD5D:

FD53: 99 02 00  STA $0002,Y   ; Unused
FD56: 99 00 02  STA $0200,Y   ; BASIC Input Buffer (Input Line from Screen)
FD59: 99 00 03  STA $0300,Y   ; Vector: BASIC Error Message
FD5C: C8        INY
FD5D: D0 F4     BNE $FD53
FD5F: A2 3C     LDX #$3C
FD61: A0 03     LDY #$03
FD63: 86 B2     STX $B2       ; Pointer: Start Address of Tape Buffer
FD65: 84 B3     STY $B3       ; Pointer: Start Address of Tape Buffer
FD67: A8        TAY
FD68: A9 03     LDA #$03
FD6A: 85 C2     STA $C2       ; Start Address for LOAD and Cassette Write

Jump from $FD86:

FD6C: E6 C2     INC $C2       ; Start Address for LOAD and Cassette Write

Jump from $FD84:

FD6E: B1 C1     LDA ($C1),Y   ; Start Address for LOAD and Cassette Write
FD70: AA        TAX
FD71: A9 55     LDA #$55
FD73: 91 C1     STA ($C1),Y   ; Start Address for LOAD and Cassette Write
FD75: D1 C1     CMP ($C1),Y   ; Start Address for LOAD and Cassette Write
FD77: D0 0F     BNE $FD88
FD79: 2A        ROL
FD7A: 91 C1     STA ($C1),Y   ; Start Address for LOAD and Cassette Write
FD7C: D1 C1     CMP ($C1),Y   ; Start Address for LOAD and Cassette Write
FD7E: D0 08     BNE $FD88
FD80: 8A        TXA
FD81: 91 C1     STA ($C1),Y   ; Start Address for LOAD and Cassette Write
FD83: C8        INY
FD84: D0 E8     BNE $FD6E
FD86: F0 E4     BEQ $FD6C

Jump from $FD77, $FD7E:

FD88: 98        TYA
FD89: AA        TAX
FD8A: A4 C2     LDY $C2       ; Start Address for LOAD and Cassette Write
FD8C: 18        CLC
FD8D: 20 2D FE  JSR $FE2D     ; Read / Set Top of Memory
FD90: A9 08     LDA #$08
FD92: 8D 82 02  STA $0282     ; Pointer: Bottom of Memory for Operating System
FD95: A9 04     LDA #$04
FD97: 8D 88 02  STA $0288     ; High Byte of Screen Memory Address
FD9A: 60        RTS


Kernal-Reference:

 LDA $FD93,X : $FCBD

 LDA $FD94,X : $FCC3


 $FD9B/64923:   IRQ Vectors For Tape I/O

FD9B: 6A FC CD FB 31 EA 2C F9    $FC6A,$FBCD,$EA31,$F92C



 $FDA3/64931:   Initialise I/O

Jump from $FCF2, $FE69, $FF84:

FDA3: A9 7F     LDA #$7F
FDA5: 8D 0D DC  STA $DC0D     ; CIA1: Interrupt (IRQ) Control Register
FDA8: 8D 0D DD  STA $DD0D     ; CIA2: Interrupt (NMI) Control Register
FDAB: 8D 00 DC  STA $DC00     ; CIA1: Data Port A (Keyboard, Joystick, Paddles)
FDAE: A9 08     LDA #$08
FDB0: 8D 0E DC  STA $DC0E     ; CIA1: Control Register A
FDB3: 8D 0E DD  STA $DD0E     ; CIA2: Control Register A
FDB6: 8D 0F DC  STA $DC0F     ; CIA1: Control Register B
FDB9: 8D 0F DD  STA $DD0F     ; CIA2: Control Register B
FDBC: A2 00     LDX #$00
FDBE: 8E 03 DC  STX $DC03     ; CIA1: Data Direction Register B
FDC1: 8E 03 DD  STX $DD03     ; CIA2: Data Direction Register B
FDC4: 8E 18 D4  STX $D418     ; SID: Select Filter Mode and Volume
FDC7: CA        DEX
FDC8: 8E 02 DC  STX $DC02     ; CIA1: Data Direction Register A
FDCB: A9 07     LDA #$07
FDCD: 8D 00 DD  STA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
FDD0: A9 3F     LDA #$3F
FDD2: 8D 02 DD  STA $DD02     ; CIA2: Data Direction Register A
FDD5: A9 E7     LDA #$E7
FDD7: 85 01     STA $01       ; 6510 On-chip 8-bit Input/Output Register
FDD9: A9 2F     LDA #$2F
FDDB: 85 00     STA $00       ; 6510 On-chip Data Direction Register



 $FDDD/64989:   Enable Timer

Jump from $FCA5, $FF6B:

FDDD: AD A6 02  LDA $02A6     ; Flag: TV Standard
FDE0: F0 0A     BEQ $FDEC
FDE2: A9 25     LDA #$25
FDE4: 8D 04 DC  STA $DC04     ; CIA1: Timer A Low-Byte  (Kernal-IRQ, Tape)
FDE7: A9 40     LDA #$40
FDE9: 4C F3 FD  JMP $FDF3

Jump from $FDE0:

FDEC: A9 95     LDA #$95
FDEE: 8D 04 DC  STA $DC04     ; CIA1: Timer A Low-Byte  (Kernal-IRQ, Tape)
FDF1: A9 42     LDA #$42

Jump from $FDE9:

FDF3: 8D 05 DC  STA $DC05     ; CIA1: Timer A High-Byte (Kernal-IRQ, Tape)
FDF6: 4C 6E FF  JMP $FF6E     ; Initialize screen editor



 $FDF9/65017:   Set Filename

Jump from $FFBD:

FDF9: 85 B7     STA $B7       ; Number of Characters in Filename
FDFB: 86 BB     STX $BB       ; Pointer: Current File name Address
FDFD: 84 BC     STY $BC       ; Pointer: Current File name Address
FDFF: 60        RTS



 $FE00/65024:   Set Logical File Parameters

Jump from $FFBA:

FE00: 85 B8     STA $B8       ; Current File - Logical File number
FE02: 86 BA     STX $BA       ; Current File - First Address (Device number)
FE04: 84 B9     STY $B9       ; Current File - Secondary Address
FE06: 60        RTS



 $FE07/65031:   Get I/O Status Word

Jump from $FFB7:

FE07: A5 BA     LDA $BA       ; Current File - First Address (Device number)
FE09: C9 02     CMP #$02
FE0B: D0 0D     BNE $FE1A     ; Control OS Messages
FE0D: AD 97 02  LDA $0297     ; RS232 Pseudo 6551 Status Register Image
FE10: 48        PHA
FE11: A9 00     LDA #$00
FE13: 8D 97 02  STA $0297     ; RS232 Pseudo 6551 Status Register Image
FE16: 68        PLA
FE17: 60        RTS



 $FE18/65048:   Control OS Messages

Jump from $FF90:

FE18: 85 9D     STA $9D       ; Error-Mode-Flag

Jump from $FE0B:

FE1A: A5 90     LDA $90       ; Kernal I/O Status Word ST

Jump from $EDB2, $EE4F, $F18A, $F518, $FA81, $FAC6, $FB35, $FB88:

FE1C: 05 90     ORA $90       ; Kernal I/O Status Word ST
FE1E: 85 90     STA $90       ; Kernal I/O Status Word ST
FE20: 60        RTS



 $FE21/65057:   Set IEEE Timeout

Jump from $FFA2:

FE21: 8D 85 02  STA $0285     ; Serial IEEE Bus timeout defeat Flag
FE24: 60        RTS



 $FE25/65061:   Read / Set Top of Memory

Jump from $FF99:

FE25: 90 06     BCC $FE2D

Jump from $F2B2, $F468:

FE27: AE 83 02  LDX $0283     ; Pointer: Top of Memory for Operating System
FE2A: AC 84 02  LDY $0284     ; Pointer: Top of Memory for Operating System

Jump from $FE25, $F480, $FD8D:

FE2D: 8E 83 02  STX $0283     ; Pointer: Top of Memory for Operating System
FE30: 8C 84 02  STY $0284     ; Pointer: Top of Memory for Operating System
FE33: 60        RTS



 $FE34/65076:   Read / Set Bottom of Memory

Jump from $FF9C:

FE34: 90 06     BCC $FE3C
FE36: AE 81 02  LDX $0281     ; Pointer: Bottom of Memory for Operating System
FE39: AC 82 02  LDY $0282     ; Pointer: Bottom of Memory for Operating System

Jump from $FE34:

FE3C: 8E 81 02  STX $0281     ; Pointer: Bottom of Memory for Operating System
FE3F: 8C 82 02  STY $0282     ; Pointer: Bottom of Memory for Operating System
FE42: 60        RTS



 $FE43/65091:   NMI Transfer Entry

FE43: 78        SEI
FE44: 6C 18 03  JMP ($0318)   ; Vector: Hardware NMI Interrupt Address
FE47: 48        PHA
FE48: 8A        TXA
FE49: 48        PHA
FE4A: 98        TYA
FE4B: 48        PHA
FE4C: A9 7F     LDA #$7F
FE4E: 8D 0D DD  STA $DD0D     ; CIA2: Interrupt (NMI) Control Register
FE51: AC 0D DD  LDY $DD0D     ; CIA2: Interrupt (NMI) Control Register
FE54: 30 1C     BMI $FE72     ; Warm Start Basic
FE56: 20 02 FD  JSR $FD02     ; Check For 8-ROM
FE59: D0 03     BNE $FE5E
FE5B: 6C 02 80  JMP ($8002)

Jump from $FE59:

FE5E: 20 BC F6  JSR $F6BC     ; Bump Clock
FE61: 20 E1 FF  JSR $FFE1     ; Test-Stop Vector
FE64: D0 0C     BNE $FE72     ; Warm Start Basic



 $FE66/65126:   Warm Start Basic

FE66: 20 15 FD  JSR $FD15     ; Restore Kernal Vectors
FE69: 20 A3 FD  JSR $FDA3     ; Initialise I/O
FE6C: 20 18 E5  JSR $E518     ; Initialize I/O
FE6F: 6C 02 A0  JMP ($A002)   ; Restart Vectors

Jump from $FE54, $FE64:

FE72: 98        TYA
FE73: 2D A1 02  AND $02A1     ; RS232 Enables
FE76: AA        TAX
FE77: 29 01     AND #$01
FE79: F0 28     BEQ $FEA3
FE7B: AD 00 DD  LDA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
FE7E: 29 FB     AND #$FB
FE80: 05 B5     ORA $B5       ; RS232 Next Bit to send/Tape Read - End of Tape
FE82: 8D 00 DD  STA $DD00     ; CIA2: Data Port A (Serial Bus, RS232, VIC Base Mem.)
FE85: AD A1 02  LDA $02A1     ; RS232 Enables
FE88: 8D 0D DD  STA $DD0D     ; CIA2: Interrupt (NMI) Control Register
FE8B: 8A        TXA
FE8C: 29 12     AND #$12
FE8E: F0 0D     BEQ $FE9D
FE90: 29 02     AND #$02
FE92: F0 06     BEQ $FE9A
FE94: 20 D6 FE  JSR $FED6     ; NMI RS232 In
FE97: 4C 9D FE  JMP $FE9D

Jump from $FE92:

FE9A: 20 07 FF  JSR $FF07     ; NMI RS232 Out

Jump from $FE8E, $FE97:

FE9D: 20 BB EE  JSR $EEBB     ; RS232 Send
FEA0: 4C B6 FE  JMP $FEB6

Jump from $FE79:

FEA3: 8A        TXA
FEA4: 29 02     AND #$02
FEA6: F0 06     BEQ $FEAE
FEA8: 20 D6 FE  JSR $FED6     ; NMI RS232 In
FEAB: 4C B6 FE  JMP $FEB6

Jump from $FEA6:

FEAE: 8A        TXA
FEAF: 29 10     AND #$10
FEB1: F0 03     BEQ $FEB6
FEB3: 20 07 FF  JSR $FF07     ; NMI RS232 Out

Jump from $FEA0, $FEAB, $FEB1:

FEB6: AD A1 02  LDA $02A1     ; RS232 Enables
FEB9: 8D 0D DD  STA $DD0D     ; CIA2: Interrupt (NMI) Control Register



 $FEBC/65212:   Exit Interrupt

Jump from $F9D2, $FA0D, $FA5D, $FA8A, $FB8B, $FC09, $FC54:

FEBC: 68        PLA
FEBD: A8        TAY
FEBE: 68        PLA
FEBF: AA        TAX
FEC0: 68        PLA
FEC1: 40        RTI


Kernal-Reference:

 LDA $FEC0,X : $F434

 LDY $FEC1,X : $F431


 $FEC2/65218:   RS232 Timing Table - NTSC

FEC2: C1 27 3E 1A C5 11 74 0E
FECA: ED 0C 45 06 F0 02 46 01
FED2: B8 00 71 00



 $FED6/65238:   NMI RS232 In

Jump from $FE94, $FEA8:

FED6: AD 01 DD  LDA $DD01     ; CIA2: Data Port B (User Port, RS232)
FED9: 29 01     AND #$01
FEDB: 85 A7     STA $A7       ; Tape temporary
FEDD: AD 06 DD  LDA $DD06     ; CIA2: Timer B Low-Byte  (RS232)
FEE0: E9 1C     SBC #$1C
FEE2: 6D 99 02  ADC $0299     ; RS232 Baud Rate; Full Bit time microseconds
FEE5: 8D 06 DD  STA $DD06     ; CIA2: Timer B Low-Byte  (RS232)
FEE8: AD 07 DD  LDA $DD07     ; CIA2: Timer B High-Byte (RS232)
FEEB: 6D 9A 02  ADC $029A     ; RS232 Baud Rate; Full Bit time microseconds
FEEE: 8D 07 DD  STA $DD07     ; CIA2: Timer B High-Byte (RS232)
FEF1: A9 11     LDA #$11
FEF3: 8D 0F DD  STA $DD0F     ; CIA2: Control Register B
FEF6: AD A1 02  LDA $02A1     ; RS232 Enables
FEF9: 8D 0D DD  STA $DD0D     ; CIA2: Interrupt (NMI) Control Register
FEFC: A9 FF     LDA #$FF
FEFE: 8D 06 DD  STA $DD06     ; CIA2: Timer B Low-Byte  (RS232)
FF01: 8D 07 DD  STA $DD07     ; CIA2: Timer B High-Byte (RS232)
FF04: 4C 59 EF  JMP $EF59     ; RS232 Receive



 $FF07/65287:   NMI RS232 Out

Jump from $FE9A, $FEB3:

FF07: AD 95 02  LDA $0295     ; RS232 Non-standard Bits/Second
FF0A: 8D 06 DD  STA $DD06     ; CIA2: Timer B Low-Byte  (RS232)
FF0D: AD 96 02  LDA $0296     ; RS232 Non-standard Bits/Second
FF10: 8D 07 DD  STA $DD07     ; CIA2: Timer B High-Byte (RS232)
FF13: A9 11     LDA #$11
FF15: 8D 0F DD  STA $DD0F     ; CIA2: Control Register B
FF18: A9 12     LDA #$12
FF1A: 4D A1 02  EOR $02A1     ; RS232 Enables
FF1D: 8D A1 02  STA $02A1     ; RS232 Enables
FF20: A9 FF     LDA #$FF
FF22: 8D 06 DD  STA $DD06     ; CIA2: Timer B Low-Byte  (RS232)
FF25: 8D 07 DD  STA $DD07     ; CIA2: Timer B High-Byte (RS232)
FF28: AE 98 02  LDX $0298     ; RS232 Number of Bits left to send
FF2B: 86 A8     STX $A8       ; RS232 Input Bit count/Tape temporary
FF2D: 60        RTS

Jump from $F44A:

FF2E: AA        TAX
FF2F: AD 96 02  LDA $0296     ; RS232 Non-standard Bits/Second
FF32: 2A        ROL
FF33: A8        TAY
FF34: 8A        TXA
FF35: 69 C8     ADC #$C8
FF37: 8D 99 02  STA $0299     ; RS232 Baud Rate; Full Bit time microseconds
FF3A: 98        TYA
FF3B: 69 00     ADC #$00
FF3D: 8D 9A 02  STA $029A     ; RS232 Baud Rate; Full Bit time microseconds
FF40: 60        RTS
FF41: EA        NOP
FF42: EA        NOP



 $FF43/65347:   Fake IRQ Entry

Jump from $F927:

FF43: 08        PHP
FF44: 68        PLA
FF45: 29 EF     AND #$EF
FF47: 48        PHA



 $FF48/65352:   IRQ Entry

FF48: 48        PHA
FF49: 8A        TXA
FF4A: 48        PHA
FF4B: 98        TYA
FF4C: 48        PHA
FF4D: BA        TSX
FF4E: BD 04 01  LDA $0104,X   ; 6510 Hardware Stack Area
FF51: 29 10     AND #$10
FF53: F0 03     BEQ $FF58
FF55: 6C 16 03  JMP ($0316)   ; Vector: BRK Instruction Interrupt Address

Jump from $FF53:

FF58: 6C 14 03  JMP ($0314)   ; Vector: Hardware IRQ Interrupt Address



 $FF5B/65371:   Initialize screen editor

Jump from $FCFB, $FF81:

FF5B: 20 18 E5  JSR $E518     ; Initialize I/O

Jump from $FF61:

FF5E: AD 12 D0  LDA $D012     ; VIC: Raster Position
FF61: D0 FB     BNE $FF5E
FF63: AD 19 D0  LDA $D019     ; VIC: Interrupt Request Register (IRR)
FF66: 29 01     AND #$01
FF68: 8D A6 02  STA $02A6     ; Flag: TV Standard
FF6B: 4C DD FD  JMP $FDDD     ; Enable Timer

Jump from $FDF6:

FF6E: A9 81     LDA #$81
FF70: 8D 0D DC  STA $DC0D     ; CIA1: Interrupt (IRQ) Control Register
FF73: AD 0E DC  LDA $DC0E     ; CIA1: Control Register A
FF76: 29 80     AND #$80
FF78: 09 11     ORA #$11
FF7A: 8D 0E DC  STA $DC0E     ; CIA1: Control Register A
FF7D: 4C 8E EE  JMP $EE8E     ; Serial Clock Off



 $FF80/65408:   Kernal Version Number

FF80:   00 = Revision 2 (old)
        03 = Revision 3 (new)
        43 = SX64

  Note: Revision 1 was just a prototype.



 $FF81/65409:   Init Editor & Video Chips

FF81: 4C 5B FF  JMP $FF5B     ; Initialize screen editor



 $FF84/65412:   Init I/O Devices, Ports & Timers

FF84: 4C A3 FD  JMP $FDA3     ; Initialise I/O



 $FF87/65415:   Init Ram & Buffers

FF87: 4C 50 FD  JMP $FD50     ; Initialise System Constants



 $FF8A/65418:   Restore Vectors

FF8A: 4C 15 FD  JMP $FD15     ; Restore Kernal Vectors



 $FF8D/65421:   Change Vectors For User

FF8D: 4C 1A FD  JMP $FD1A     ; Change Vectors For User



 $FF90/65424:   Control OS Messages

Jump from $A47D, $A874:

FF90: 4C 18 FE  JMP $FE18     ; Control OS Messages



 $FF93/65427:   Send SA After Listen

FF93: 4C B9 ED  JMP $EDB9     ; Send LISTEN Secondary Address



 $FF96/65430:   Send SA After Talk

FF96: 4C C7 ED  JMP $EDC7     ; Send TALK Secondary Address



 $FF99/65433:   Set/Read System RAM Top

Jump from $E40B:

FF99: 4C 25 FE  JMP $FE25     ; Read / Set Top of Memory



 $FF9C/65436:   Set/Read System RAM Bottom

Jump from $E403:

FF9C: 4C 34 FE  JMP $FE34     ; Read / Set Bottom of Memory



 $FF9F/65439:   Scan Keyboard

FF9F: 4C 87 EA  JMP $EA87     ; Scan Keyboard



 $FFA2/65442:   Set Timeout In IEEE

FFA2: 4C 21 FE  JMP $FE21     ; Set IEEE Timeout



 $FFA5/65445:   Handshake Serial Byte In

FFA5: 4C 13 EE  JMP $EE13     ; Receive From Serial Bus



 $FFA8/65448:   Handshake Serial Byte Out

FFA8: 4C DD ED  JMP $EDDD     ; Send Serial Deferred



 $FFAB/65451:   Command Serial Bus UNTALK

FFAB: 4C EF ED  JMP $EDEF     ; Send UNTALK



 $FFAE/65454:   Command Serial Bus UNLISTEN

FFAE: 4C FE ED  JMP $EDFE     ; Send UNLISTEN



 $FFB1/65457:   Command Serial Bus LISTEN

FFB1: 4C 0C ED  JMP $ED0C     ; Send LISTEN Command on Serial Bus



 $FFB4/65460:   Command Serial Bus TALK

FFB4: 4C 09 ED  JMP $ED09     ; Send TALK Command on Serial Bus



 $FFB7/65463:   Read I/O Status Word

Jump from $ABDD, $AF9A, $E180, $E195:

FFB7: 4C 07 FE  JMP $FE07     ; Get I/O Status Word



 $FFBA/65466:   Set Logical File Parameters

Jump from $E1DD, $E1F0, $E1FD, $E22B, $E23F, $E24E:

FFBA: 4C 00 FE  JMP $FE00     ; Set Logical File Parameters



 $FFBD/65469:   Set Filename

Jump from $E1D6, $E21B, $E261:

FFBD: 4C F9 FD  JMP $FDF9     ; Set Filename



 $FFC0/65472:   Open Vector

Jump from $E1C1:

FFC0: 6C 1A 03  JMP ($031A)   ; Vector: Kernal OPEN Routine



 $FFC3/65475:   Close Vector

Jump from $E1CC:

FFC3: 6C 1C 03  JMP ($031C)   ; Vector: Kernal CLOSE Routine



 $FFC6/65478:   Set Input

Jump from $E11E:

FFC6: 6C 1E 03  JMP ($031E)   ; Vector: Kernal CHKIN Routine



 $FFC9/65481:   Set Output

Jump from $E4AE:

FFC9: 6C 20 03  JMP ($0320)   ; Vector: Kernal CHKOUT Routine



 $FFCC/65484:   Restore I/O Vector

Jump from $A447, $ABB7, $E37B, $F6F4, $F716:

FFCC: 6C 22 03  JMP ($0322)   ; Vector: Kernal CLRCHN Routine



 $FFCF/65487:   Input Vector, chrin

Jump from $E112:

FFCF: 6C 24 03  JMP ($0324)   ; Vector: Kernal CHRIN Routine



 $FFD2/65490:   Output Vector, chrout

Jump from $E10C, $F135, $F5C9, $F726, $F759:

FFD2: 6C 26 03  JMP ($0326)   ; Vector: Kernal CHROUT Routine



 $FFD5/65493:   Load RAM From Device

Jump from $E175:

FFD5: 4C 9E F4  JMP $F49E     ; Load RAM



 $FFD8/65496:   Save RAM To Device

Jump from $E15F:

FFD8: 4C DD F5  JMP $F5DD     ; Save RAM



 $FFDB/65499:   Set Real-Time Clock

Jump from $AA1A:

FFDB: 4C E4 F6  JMP $F6E4     ; Set Time



 $FFDE/65502:   Read Real-Time Clock

Jump from $AF84:

FFDE: 4C DD F6  JMP $F6DD     ; Get Time



 $FFE1/65505:   Test-Stop Vector

Jump from $A82C, $F4F9, $F62E, $F8D0, $FE61:

FFE1: 6C 28 03  JMP ($0328)   ; Vector: Kernal STOP Routine



 $FFE4/65508:   Get From Keyboad

Jump from $E124:

FFE4: 6C 2A 03  JMP ($032A)   ; Vector: Kernal GETIN Routine



 $FFE7/65511:   Close All Channels And Files

Jump from $A660:

FFE7: 6C 2C 03  JMP ($032C)   ; Vector: Kernal CLALL Routine



 $FFEA/65514:   Increment Real-Time Clock

Jump from $EA31:

FFEA: 4C 9B F6  JMP $F69B     ; Bump Clock



 $FFED/65517:   Return Screen Organization

FFED: 4C 05 E5  JMP $E505     ; Get Screen Size



 $FFF0/65520:   Read / Set Cursor X/Y Position

Jump from $AAE9, $AAFA, $B39F:

FFF0: 4C 0A E5  JMP $E50A     ; Put / Get Row And Column



 $FFF3/65523:   Return I/O Base Address

Jump from $E09E:

FFF3: 4C 00 E5  JMP $E500     ; Get I/O Address



 $FFF6/65526:   -

FFF6: 52 52                      $5252



 $FFF8/65528:   SYSTEM

FFF8: 42 59                      $5942



 $FFFA/65530:   Vector: NMI

FFFA: 43 FE                      $FE43



 $FFFC/65532:   Vector: RESET

FFFC: E2 FC                      $FCE2



 $FFFE/65534:   Vector: IRQ

FFFE: 48 FF                      $FF48



 KERNAL Versions:

   Revision 1 (prototype, not mentioned in AAY64)
   Revision 2 ("old", used until 1983(?))
   Revision 3 ("new", used from 1983(?) on)
   SX64       (like Rev. 3, but adapted for the SX64)

   AAY64 contains a disassembly of the new version, but differences
   are also stated. They are at:

  +-------------------------------------------------------------------------
  |   Rev. 2 <> Rev. 3
  +-------------+-----------------------------------------------------------
  | $E4AC       | Version Indicator(?)
  | $E4D3-$E4D9 | Patch for RS232-Routines:
  |             |   Old Kernal didn't set Input Parity at $AB
  | $E4DA-$E4DC | Reset Character Color:
  |             |   Old Kernal gets Color from $D021 instead of $0286.
  | $E57C-$E599 | Set Screen Pointers:
  |             |   Old Kernal lacks some error-checks
  | $E622+$E623 | Input From Keyboard:
  |             |   Old Kernal doesn't check if cursor line = 0
  | $EA07-$EA12 | Clear Screen Line:
  |             |   Just a differnce in order of code
  | $EF94-$EF96 | Process RS232 Byte:
  |             |   Apply patch at $E4D3 in newer version
  | $FF80       | Version number
  +-------------+-----------------------------------------------------------

  +-------------------------------------------------------------------------
  |   SX64 <> Rev. 3
  +-------------+-----------------------------------------------------------
  | $E479-$E4AC | Power-Up Message:
  |             |   Adapted for SX64
  | $E4AC       | Version Indicator(?)
  | $E535       | Initialize I/O:
  |             |   Text-Color is Blue instead of Light Blue
  | $E5EF       | Input From Keyboard:
  |/$E5F4+$E5F5 |   Other parameters for RUN/STOP-String
  | $ECD9+$ECDA | Video Chip Setup Table:
  |             |   Cyan Border and White Background
  | $F0D8-$F0E6 | Table of Kernal I/O Messages:
  |             |   New RUN/STOP-String (loads from disk as SX64 has no tape)
  | $F387       | Open File:
  |             |   Tape access will cause error
  | $F4B7       | Load RAM:
  |             |   Tape access will cause error
  | $F5F9       | Save RAM:
  |             |   Tape access will cause error
  | $FF80       | Version number
  +-------------+-----------------------------------------------------------


 +----------------------------------------+
 | CHR$/ASC-Table for Upper Case/Graphics |
 +----------------------------------------+

  This table shows you, what CHR$(x) will result in and which value you get
  using ASC(). Codes in brackets are those not available through key-presses.
  "ScrC." means Screen Code.
+------------------+------------------+------------------+------------------+
|CHR$() :  Result  |CHR$() :  Result  |CHR$() :  Result  |CHR$() :  Result  |
+------------------+------------------+------------------+------------------+
|$00/000:          |$40/064:    @     |$80/128:          |$C0/192: ScrC.$40 |
|$01/001:          |$41/065:    A     |$81/129:Orange    |$C1/193: ScrC.$41 |
|$02/002:          |$42/066:    B     |$82/130:          |$C2/194: ScrC.$42 |
|$03/003:          |$43/067:    C     |$83/131:          |$C3/195: ScrC.$43 |
|$04/004:          |$44/068:    D     |$84/132:          |$C4/196: ScrC.$44 |
|$05/005:White     |$45/069:    E     |$85/133:    F1    |$C5/197: ScrC.$45 |
|$06/006:          |$46/070:    F     |$86/134:    F3    |$C6/198: ScrC.$46 |
|$07/007:          |$47/071:    G     |$87/135:    F5    |$C7/199: ScrC.$47 |
|$08/008:Dis.C=/Shf|$48/072:    H     |$88/136:    F7    |$C8/200: ScrC.$48 |
|$09/009:En.C=/Shft|$49/073:    I     |$89/137:    F2    |$C9/201: ScrC.$49 |
|$0A/010:          |$4A/074:    J     |$8A/138:    F4    |$CA/202: ScrC.$4A |
|$0B/011:          |$4B/075:    K     |$8B/139:    F6    |$CB/203: ScrC.$4B |
|$0C/012:          |$4C/076:    L     |$8C/140:    F8    |$CC/204: ScrC.$4C |
|$0D/013:Return(CR)|$4D/077:    M     |$8D/141:Shft+Retrn|$CD/205: ScrC.$4D |
|$0E/014:Lower Case|$4E/078:    N     |$8E/142:Upper Case|$CE/206: ScrC.$4E |
|$0F/015:          |$4F/079:    O     |$8F/143:          |$CF/207: ScrC.$4F |
|$10/016:          |$50/080:    P     |$90/144:Black     |$D0/208: ScrC.$50 |
|$11/017:Crsr down |$51/081:    Q     |$91/145:Crsr up   |$D1/209: ScrC.$51 |
|$12/018:Revers on |$52/082:    R     |$92/146:Revers off|$D2/210: ScrC.$52 |
|$13/019:Home      |$53/083:    S     |$93/147:Clear     |$D3/211: ScrC.$53 |
|$14/020:Delete    |$54/084:    T     |$94/148:Insert    |$D4/212: ScrC.$54 |
|$15/021:          |$55/085:    U     |$95/149:Brown     |$D5/213: ScrC.$55 |
|$16/022:          |$56/086:    V     |$96/150:Light Red |$D6/214: ScrC.$56 |
|$17/023:          |$57/087:    W     |$97/151:Dark Gray |$D7/215: ScrC.$57 |
|$18/024:          |$58/088:    X     |$98/152:Gray      |$D8/216: ScrC.$58 |
|$19/025:          |$59/089:    Y     |$99/153:Lght Green|$D9/217: ScrC.$59 |
|$1A/026:          |$5A/090:    Z     |$9A/154:Light Blue|$DA/218: ScrC.$5A |
|$1B/027:          |$5B/091:    [     |$9B/155:Light Gray|$DB/219: ScrC.$5B |
|$1C/028:Red       |$5C/092:  Pound   |$9C/156:Purple    |$DC/220: ScrC.$5C |
|$1D/029:Crsr right|$5D/093:    ]     |$9D/157:Crsr left |$DD/221: ScrC.$5D |
|$1E/030:Green     |$5E/094: Arrow up |$9E/158:Yellow    |$DE/222:(ScrC.$5E)|
|$1F/031:Blue      |$5F/095:Arrow left|$9F/159:Cyan      |$DF/223: ScrC.$5F |
|$20/032:  SPACE   |$60/096:(ScrC.$40)|$A0/160:ShiftSpace|$E0/224:(ScrC.$60)|
|$21/033:    !     |$61/097:(ScrC.$41)|$A1/161: ScrC.$61 |$E1/225:(ScrC.$61)|
|$22/034:    "     |$62/098:(ScrC.$42)|$A2/162: ScrC.$62 |$E2/226:(ScrC.$62)|
|$23/035:    #     |$63/099:(ScrC.$43)|$A3/163: ScrC.$63 |$E3/227:(ScrC.$63)|
|$24/036:    $     |$64/100:(ScrC.$44)|$A4/164: ScrC.$64 |$E4/228:(ScrC.$64)|
|$25/037:    %     |$65/101:(ScrC.$45)|$A5/165: ScrC.$65 |$E5/229:(ScrC.$65)|
|$26/038:    &     |$66/102:(ScrC.$46)|$A6/166: ScrC.$66 |$E6/230:(ScrC.$66)|
|$27/039:    '     |$67/103:(ScrC.$47)|$A7/167: ScrC.$67 |$E7/231:(ScrC.$67)|
|$28/040:    (     |$68/104:(ScrC.$48)|$A8/168: ScrC.$68 |$E8/232:(ScrC.$68)|
|$29/041:    )     |$69/105:(ScrC.$49)|$A9/169: ScrC.$69 |$E9/233:(ScrC.$69)|
|$2A/042:    *     |$6A/106:(ScrC.$4A)|$AA/170: ScrC.$6A |$EA/234:(ScrC.$6A)|
|$2B/043:    +     |$6B/107:(ScrC.$4B)|$AB/171: ScrC.$6B |$EB/235:(ScrC.$6B)|
|$2C/044:    ,     |$6C/108:(ScrC.$4C)|$AC/172: ScrC.$6C |$EC/236:(ScrC.$6C)|
|$2D/045:    -     |$6D/109:(ScrC.$4D)|$AD/173: ScrC.$6D |$ED/237:(ScrC.$6D)|
|$2E/046:    .     |$6E/110:(ScrC.$4E)|$AE/174: ScrC.$6E |$EE/238:(ScrC.$6E)|
|$2F/047:    /     |$6F/111:(ScrC.$4F)|$AF/175: ScrC.$6F |$EF/239:(ScrC.$6F)|
|$30/048:    0     |$70/112:(ScrC.$50)|$B0/176: ScrC.$70 |$F0/240:(ScrC.$70)|
|$31/049:    1     |$71/113:(ScrC.$51)|$B1/177: ScrC.$71 |$F1/241:(ScrC.$71)|
|$32/050:    2     |$72/114:(ScrC.$52)|$B2/178: ScrC.$72 |$F2/242:(ScrC.$72)|
|$33/051:    3     |$73/115:(ScrC.$53)|$B3/179: ScrC.$73 |$F3/243:(ScrC.$73)|
|$34/052:    4     |$74/116:(ScrC.$54)|$B4/180: ScrC.$74 |$F4/244:(ScrC.$74)|
|$35/053:    5     |$75/117:(ScrC.$55)|$B5/181: ScrC.$75 |$F5/245:(ScrC.$75)|
|$36/054:    6     |$76/118:(ScrC.$56)|$B6/182: ScrC.$76 |$F6/246:(ScrC.$76)|
|$37/055:    7     |$77/119:(ScrC.$57)|$B7/183: ScrC.$77 |$F7/247:(ScrC.$77)|
|$38/056:    8     |$78/120:(ScrC.$58)|$B8/184: ScrC.$78 |$F8/248:(ScrC.$78)|
|$39/057:    9     |$79/121:(ScrC.$59)|$B9/185: ScrC.$79 |$F9/249:(ScrC.$79)|
|$3A/058:    :     |$7A/122:(ScrC.$5A)|$BA/186: ScrC.$7A |$FA/250:(ScrC.$7A)|
|$3B/059:    ;     |$7B/123:(ScrC.$5B)|$BB/187: ScrC.$7B |$FB/251:(ScrC.$7B)|
|$3C/060:    <     |$7C/124:(ScrC.$5C)|$BC/188: ScrC.$7C |$FC/252:(ScrC.$7C)|
|$3D/061:    =     |$7D/125:(ScrC.$5D)|$BD/189: ScrC.$7D |$FD/253:(ScrC.$7D)|
|$3E/062:    >     |$7E/126:(ScrC.$5E)|$BE/190: ScrC.$7E |$FE/254:(ScrC.$7E)|
|$3F/063:    ?     |$7F/127:(ScrC.$5F)|$BF/191: ScrC.$7F |$FF/255:    Pi    |
+------------------+------------------+------------------+------------------+
Notes: Codes 192-223 look the same as codes 96-127.
       Codes 224-254 look the same as codes 160-190.
       Code 255 looks the same as code 126 (and code 222).


 +------------------------------------------+
 | CHR$/ASC-Table for Lower Case/Upper Case |
 +------------------------------------------+

  This table shows you, what CHR$(x) will result in and which value you get
  using ASC(). Codes in brackets are those not available through key-presses.
  "ScrC." means Screen Code.
+------------------+------------------+------------------+------------------+
|CHR$() :  Result  |CHR$() :  Result  |CHR$() :  Result  |CHR$() :  Result  |
+------------------+------------------+------------------+------------------+
|$00/000:          |$40/064:    @     |$80/128:          |$C0/192: ScrC.$40 |
|$01/001:          |$41/065:    a     |$81/129:Orange    |$C1/193:    A     |
|$02/002:          |$42/066:    b     |$82/130:          |$C2/194:    B     |
|$03/003:          |$43/067:    c     |$83/131:          |$C3/195:    C     |
|$04/004:          |$44/068:    d     |$84/132:          |$C4/196:    D     |
|$05/005:White     |$45/069:    e     |$85/133:    F1    |$C5/197:    E     |
|$06/006:          |$46/070:    f     |$86/134:    F3    |$C6/198:    F     |
|$07/007:          |$47/071:    g     |$87/135:    F5    |$C7/199:    G     |
|$08/008:Dis.C=/Shf|$48/072:    h     |$88/136:    F7    |$C8/200:    H     |
|$09/009:En.C=/Shft|$49/073:    i     |$89/137:    F2    |$C9/201:    I     |
|$0A/010:          |$4A/074:    j     |$8A/138:    F4    |$CA/202:    J     |
|$0B/011:          |$4B/075:    k     |$8B/139:    F6    |$CB/203:    K     |
|$0C/012:          |$4C/076:    l     |$8C/140:    F8    |$CC/204:    L     |
|$0D/013:Return(CR)|$4D/077:    m     |$8D/141:Shft+Retrn|$CD/205:    M     |
|$0E/014:Lower Case|$4E/078:    n     |$8E/142:Upper Case|$CE/206:    N     |
|$0F/015:          |$4F/079:    o     |$8F/143:          |$CF/207:    O     |
|$10/016:          |$50/080:    p     |$90/144:Black     |$D0/208:    P     |
|$11/017:Crsr down |$51/081:    q     |$91/145:Crsr up   |$D1/209:    Q     |
|$12/018:Revers on |$52/082:    r     |$92/146:Revers off|$D2/210:    R     |
|$13/019:Home      |$53/083:    s     |$93/147:Clear     |$D3/211:    S     |
|$14/020:Delete    |$54/084:    t     |$94/148:Insert    |$D4/212:    T     |
|$15/021:          |$55/085:    u     |$95/149:Brown     |$D5/213:    U     |
|$16/022:          |$56/086:    v     |$96/150:Light Red |$D6/214:    V     |
|$17/023:          |$57/087:    w     |$97/151:Dark Gray |$D7/215:    W     |
|$18/024:          |$58/088:    x     |$98/152:Gray      |$D8/216:    X     |
|$19/025:          |$59/089:    y     |$99/153:Lght Green|$D9/217:    Y     |
|$1A/026:          |$5A/090:    z     |$9A/154:Light Blue|$DA/218:    Z     |
|$1B/027:          |$5B/091:    [     |$9B/155:Light Gray|$DB/219: ScrC.$5B |
|$1C/028:Red       |$5C/092:  Pound   |$9C/156:Purple    |$DC/220: ScrC.$5C |
|$1D/029:Crsr right|$5D/093:    ]     |$9D/157:Crsr left |$DD/221: ScrC.$5D |
|$1E/030:Green     |$5E/094: Arrow up |$9E/158:Yellow    |$DE/222:(ScrC.$5E)|
|$1F/031:Blue      |$5F/095:Arrow left|$9F/159:Cyan      |$DF/223: ScrC.$5F |
|$20/032:  SPACE   |$60/096:(ScrC.$40)|$A0/160:ShiftSpace|$E0/224:(ScrC.$60)|
|$21/033:    !     |$61/097:(   A    )|$A1/161: ScrC.$61 |$E1/225:(ScrC.$61)|
|$22/034:    "     |$62/098:(   B    )|$A2/162: ScrC.$62 |$E2/226:(ScrC.$62)|
|$23/035:    #     |$63/099:(   C    )|$A3/163: ScrC.$63 |$E3/227:(ScrC.$63)|
|$24/036:    $     |$64/100:(   D    )|$A4/164: ScrC.$64 |$E4/228:(ScrC.$64)|
|$25/037:    %     |$65/101:(   E    )|$A5/165: ScrC.$65 |$E5/229:(ScrC.$65)|
|$26/038:    &     |$66/102:(   F    )|$A6/166: ScrC.$66 |$E6/230:(ScrC.$66)|
|$27/039:    '     |$67/103:(   G    )|$A7/167: ScrC.$67 |$E7/231:(ScrC.$67)|
|$28/040:    (     |$68/104:(   H    )|$A8/168: ScrC.$68 |$E8/232:(ScrC.$68)|
|$29/041:    )     |$69/105:(   I    )|$A9/169: ScrC.$69 |$E9/233:(ScrC.$69)|
|$2A/042:    *     |$6A/106:(   J    )|$AA/170: ScrC.$6A |$EA/234:(ScrC.$6A)|
|$2B/043:    +     |$6B/107:(   K    )|$AB/171: ScrC.$6B |$EB/235:(ScrC.$6B)|
|$2C/044:    ,     |$6C/108:(   L    )|$AC/172: ScrC.$6C |$EC/236:(ScrC.$6C)|
|$2D/045:    -     |$6D/109:(   M    )|$AD/173: ScrC.$6D |$ED/237:(ScrC.$6D)|
|$2E/046:    .     |$6E/110:(   N    )|$AE/174: ScrC.$6E |$EE/238:(ScrC.$6E)|
|$2F/047:    /     |$6F/111:(   O    )|$AF/175: ScrC.$6F |$EF/239:(ScrC.$6F)|
|$30/048:    0     |$70/112:(   P    )|$B0/176: ScrC.$70 |$F0/240:(ScrC.$70)|
|$31/049:    1     |$71/113:(   Q    )|$B1/177: ScrC.$71 |$F1/241:(ScrC.$71)|
|$32/050:    2     |$72/114:(   R    )|$B2/178: ScrC.$72 |$F2/242:(ScrC.$72)|
|$33/051:    3     |$73/115:(   S    )|$B3/179: ScrC.$73 |$F3/243:(ScrC.$73)|
|$34/052:    4     |$74/116:(   T    )|$B4/180: ScrC.$74 |$F4/244:(ScrC.$74)|
|$35/053:    5     |$75/117:(   U    )|$B5/181: ScrC.$75 |$F5/245:(ScrC.$75)|
|$36/054:    6     |$76/118:(   V    )|$B6/182: ScrC.$76 |$F6/246:(ScrC.$76)|
|$37/055:    7     |$77/119:(   W    )|$B7/183: ScrC.$77 |$F7/247:(ScrC.$77)|
|$38/056:    8     |$78/120:(   X    )|$B8/184: ScrC.$78 |$F8/248:(ScrC.$78)|
|$39/057:    9     |$79/121:(   Y    )|$B9/185: ScrC.$79 |$F9/249:(ScrC.$79)|
|$3A/058:    :     |$7A/122:(   Z    )|$BA/186: ScrC.$7A |$FA/250:(ScrC.$7A)|
|$3B/059:    ;     |$7B/123:(ScrC.$5B)|$BB/187: ScrC.$7B |$FB/251:(ScrC.$7B)|
|$3C/060:    <     |$7C/124:(ScrC.$5C)|$BC/188: ScrC.$7C |$FC/252:(ScrC.$7C)|
|$3D/061:    =     |$7D/125:(ScrC.$5D)|$BD/189: ScrC.$7D |$FD/253:(ScrC.$7D)|
|$3E/062:    >     |$7E/126:(ScrC.$5E)|$BE/190: ScrC.$7E |$FE/254:(ScrC.$7E)|
|$3F/063:    ?     |$7F/127:(ScrC.$5F)|$BF/191: ScrC.$7F |$FF/255:    Pi    |
+------------------+------------------+------------------+------------------+
Notes: Codes 192-223 look the same as codes 96-127.
       Codes 224-254 look the same as codes 160-190.
       Code 255 looks the same as code 126 (and code 222).


  +------------------------------------------------------------------------
  |
  |      SUPERCPU - REGISTER DESCRIPTIONS
  |
  +------------------------------------------------------------------------
  |
  |   $D074/53364/SCPU+4        GEOS Optimization
  |   $D075/53365/SCPU+5        VIC Bank 01 Optimization
  |   $D076/53366/SCPU+6        BASIC Optimization
  |   $D077/53367/SCPU+7        No Optimization (V1: Default)
  |   $D079/53369/SCPU+9        Duplicate: Speed Select - Turbo (20 MHz)
  |   $D07A/53370/SCPU+10       Speed Select - Normal (1 MHz)
  |   $D07B/53371/SCPU+11       Speed Select - Turbo (20 MHz)
  |   $D07D/53373/SCPU+13       Duplicate: Hardware Register Disable
  |   $D07E/53374/SCPU+14       Hardware Register Enable
  |   $D07F/53375/SCPU+15       Hardware Register Disable
  |
  |   $D0B0/53424/SCPU+64       SuperCPU Mode Detect Register
  |   $D0B2/53426/SCPU+66       Hardware Register-/System Flag
  |   $D0B3/53427/SCPU+67       Enhanced Optimization Register (V2 only!)
  |   $D0B4/53428/SCPU+68       Optimization Mode Flags
  |   $D0B5/53429/SCPU+69       JiffyDOS-/Speed Switch Flag
  |   $D0B6/53430/SCPU+70       Processor Emulation-/Reset Flag
  |   $D0B8/53432/SCPU+72       Software 1 MHz-/Master 1MHz Flag
  |   $D0BC/53433/SCPU+76       DOS Extension-/RAMLink Hardware Reg. Flag
  |
  |
  |   $D200-$D2FF/53760-54015   System-RAM:
  |   $D27B/53883/SCPURAM+123    SIMM-Type
  |   $D27C/53884/SCPURAM+124    First Available Page of SuperRAM
  |   $D27D/53885/SCPURAM+125    Bank of First Available Page of SuperRAM
  |   $D27E/53886/SCPURAM+126    Last Available Page of SuperRAM + 1
  |   $D27F/53887/SCPURAM+127    Bank of Last Available Page of SuperRAM + 1
  |
  |   $D300-$D3FF/54016-54271   User-RAM
  |
  +------------------------------------------------------------------------



 $D074/53364/SCPU+4:   GEOS Optimization

   Mirrors VIC-Bank 02 ($8000-$BFFF). This register is write only,
   hardware registers must be enabled to activate location (see $D07E).


 $D075/53365/SCPU+5:   VIC Bank 01 Optimization

   Mirrors VIC-Bank 01 ($4000-$7FFF). This register is write only,
   hardware registers must be enabled to activate location (see $D07E).


 $D076/53366/SCPU+6:   BASIC Optimization

   Mirrors Standard Screen ($0400-$07FF). This register is write only,
   hardware registers must be enabled to activate location (see $D07E).


 $D077/53367/SCPU+7:   No Optimization (V1: Default)

   Mirrors all memory ($0000-$FFFF). This register is write only,
   hardware registers must be enabled to activate location (see $D07E).


 $D079/53369/SCPU+9:   Duplicate: Speed Select - Turbo (20 MHz)

   This register is write only, active with hardware registers enabled or
   disabled, but does not over-ride hardware Speed switch.


 $D07A/53370/SCPU+10:   Speed Select - Normal (1 MHz)

   This register is write only, active with hardware registers enabled
   or disabled.

   Note: On a C128 with 2 MHz-mode enabled the speed will be 2 MHz.


 $D07B/53371/SCPU+11:   Speed Select - Turbo (20 MHz)

   This register is write only, active with hardware registers enabled or
   disabled, but does not over-ride hardware Speed switch.


 $D07D/53373/SCPU+13:   Duplicate: Hardware Register Disable

   This register is write only, active with hardware registers enabled
   or disabled.


 $D07E/53374/SCPU+14:   Hardware Register Enable

   This register is write only, active with hardware registers enabled
   or disabled.

   IMPORTANT NOTE: Enabling the SuperCPU hardware registers also
   causes some changes in the Kernal ROM memory map ($E000-$FFFF).
   To avoid problems, do not leave the hardware registers enabled
   any longer than necessary.


 $D07F/53375/SCPU+15:   Hardware Register Disable

   This register is write only, active with hardware registers enabled
   or disabled.


 $D0B0/53424/SCPU+64:   SuperCPU Mode Detect Register

   +----------+---------------------------------------------------+
   | Bits 7+6 |   00 = SuperCPU V2 in 128 mode                    |                                    |
   |          |   01 = SuperCPU V2 in 64 mode                     |
   |          |   11 = SuperCPU V1, no or disabled SuperCPU       |
   +----------+---------------------------------------------------+

     This register is read only with hardware registers enabled or
     disabled (write with hardware registers enabled has no effect).


 $D0B2/53426/SCPU+66:   Hardware Register-/System Flag

   +-------+--------------------------------------------------------+
   | Bit 7 |   Hardware Register Enable Flag: 1 = Enabled           |
   | Bit 6 |   System 1 MHz Flag: 1 = Enabled                       |
   +-------+--------------------------------------------------------+

     This register is read only with hardware registers disabled,
     Read/Write with hardware registers enabled, write access reserved
     for system only.


 $D0B3/53427/SCPU+67:   Enhanced Optimization Register (V2 only!)

   +----------+---------------------------------------------------+
   | Bits 7-0 |   00xxx1BZ = VIC-Bank 0, $0000 - $3FFF            |                                    |
   |          |   01xxx0B0 = VIC-Bank 1, $4000 - $7FFF            |
   |          |   00xxx0B0 = VIC-Bank 2, $8000 - $BFFF (GEOS)     |
   |          |   01xxx1B0 = VIC-Bank 3, $C000 - $FFFF            |
   |          |   10xxx0B0 = BASIC Opt., $0400 - $07FF            |
   |          |   11xxx00Z = No Opt all mem, $0:0000 - $1:FFFF    |
   |          |               V2: Default                         |
   |          |   11xxx1BZ = No Opt per bank, $0000 - $FFFF       |
   |          |   10xxx100 = Full optimization (no mirroring)     |
   +----------+---------------------------------------------------+

     This register is read only with hardware registers disabled,
     Read/Write with hardware registers enabled.

     Changing values in this area affects all other optimization mode
     registers, and changing other optimization mode registers affect
     this location. The B-flag assigns control of this register to a
     specific C128 bank (0 = Bank 0, 1 = Bank 1), while the Z-flag
     controls mirroring of ZeroPage and Stack memory ($0000 - $01FF)
     (0 = mirroring on, 1 = mirroring off). Default for Z is 1, B is 0.


 $D0B4/53428/SCPU+68:   Optimization Mode Flags

   +----------+---------------------------------------------------+
   | Bits 7+6 |   00 = GEOS Optimization Enabled                  |                                     |
   |          |   01 = VIC Bank 01 Optimization Enabled           |
   |          |   10 = BASIC Optimization Enabled                 |
   |          |   11 = No Optimization                            |
   +----------+---------------------------------------------------+

     This register is read only with hardware registers disabled,
     Read/Write with hardware registers enabled.


 $D0B5/53429/SCPU+69:   JiffyDOS-/Speed Switch Flag

   +-------+--------------------------------------------------------+
   | Bit 7 |   JiffyDOS Switch Flag: 1 = Enabled                    |
   | Bit 6 |   Speed Switch Flag: 1 = 1 MHz                         |
   +-------+--------------------------------------------------------+

     This register is read only with hardware registers enabled or
     disabled (write with hardware registers enabled has no effect).


 $D0B6/53430/SCPU+70:   Processor Emulation-/Reset Flag

   +-------+--------------------------------------------------------+
   | Bit 7 |   Processor Emulation Mode Flag: 1 = Emulation         |
   | Bit 6 |   Reset Switch Flag: 1 = Switch Pressed (V1 only!)     |
   +-------+--------------------------------------------------------+

     This register is read only with hardware registers disabled,
     Read/Write with hardware registers enabled, write access reserved
     for system only.


 $D0B8/53432/SCPU+72:   Software 1 MHz-/Master 1MHz Flag

   +-------+--------------------------------------------------------+
   | Bit 7 |   Software 1 MHz Flag: 1 = 1 MHz                       |
   | Bit 6 |   Master 1 MHz Flag: 1 = 1 MHz via any source          |
   +-------+--------------------------------------------------------+

     This register is read only with hardware registers disabled,
     Read/Write with hardware registers enabled, write access reserved
     for system only.


 $D0BC/53433/SCPU+76:   DOS Extension-/RAMLink Hardware Reg. Flag

   +-------+--------------------------------------------------------+
   | Bit 7 |   DOS Extension Mode Flag: 1 = Enabled                 |
   | Bit 6 |   RAMLink Hardware Registers Flag: 1 = Enabled         |
   +-------+--------------------------------------------------------+

     This register is read only with hardware registers disabled,
     Read/Write with hardware registers enabled.


  $D200-$D2FF/53760-54015:   System-RAM


 $D27B/53883/SCPU+123:   SIMM-Type

   +-------+---------+----------+---------------+----------+---------------+
   | Value |SIMM-Type| Number   | Length of one | Number   | Total memory  |
   |       |         | of Cells | row (in Byte) | of Rows  | (in Byte)     |
   +-------+---------+----------+---------------+----------+---------------+
   |   0   |   9/9   |  2^9=512 | 512*4=2048=2K |  2^9=512 |  512*2K=1024K |
   |       |         |          |               |          |      (1MB)    |
   +-------+---------+----------+---------------+----------+---------------+
   |   1   |  10/10  | 2^10=1024| 1024*4=4096=4K| 2^10=1024|  1024*4K=4096K|
   |       |         |          |               |          |      (4MB)    |
   +-------+---------+----------+---------------+----------+---------------+
   |   2   |  11/10  | 2^10=1024| 1024*4=4096=4K| 2^11=2048|  2048*4K=8192K|
   |       |         |          |               |          |      (8MB)    |
   +-------+---------+----------+---------------+----------+---------------+
   |   3   |  12/10  | 2^10=1024| 1024*4=4096=4K| 2^12=4096| 4096*4K=16384K|
   |       |         |          |               |          |     (16MB)    |
   +-------+---------+----------+---------------+----------+---------------+
   |   4   |  11/11  | 2^11=2048| 2048*4=8192=8K| 2^11=2048| 2048*8K=16384K|
   |       |         |          |               |          |     (16MB)    |
   +-------+---------+----------+---------------+----------+---------------+
   |  $FF  |    -    |     -    |       -       |     -    |No SIMM present|
   +-------+---------+----------+---------------+----------+---------------+

   Note: One cell always has 4 bytes of memory.


 $D27C/53884/SCPU+124:   First Available Page of SuperRAM

   This register is read only with hardware registers disabled,
   Read/Write with hardware registers enabled.

   Register is mirrored in bank $01.


 $D27D/53885/SCPU+125:   Bank of First Available Page of SuperRAM

   This register is read only with hardware registers disabled,
   Read/Write with hardware registers enabled.

   Register is mirrored in bank $01.


 $D27E/53886/SCPU+126:   Last Available Page of SuperRAM + 1

   This register is read only with hardware registers disabled,
   Read/Write with hardware registers enabled.

   Register is mirrored in bank $01.


 $D27F/53887/SCPU+127:   Bank of Last Available Page of SuperRAM + 1

   This register is read only with hardware registers disabled,
   Read/Write with hardware registers enabled.

   Register is mirrored in bank $01.


  $D300-$D3FF/54016-54271:   User-RAM


  +------------------------------------------------------------------------
  |
  |      Information about various Hardware Expansions:
  |
  +------------------------------------------------------------------------
  |
  |  +60K-Ram-Expansion (60K)
  |  Action Replay (AR)
  |  Final Cartridge III (FC3)
  |  MMC64-Cartridge
  |  RAM Expansion Unit (REU)
  |  RAMLink (RL)
  |  Retro Replay (RR)
  |  SuperCPU (SCPU)
  |  SwiftLink (SL) & Turbo232 (T232)
  |
  +------------------------------------------------------------------------



  +------------------------------------------------------------------------
  |
  |      ACTION-REPLAY-Cartridge (tested with V6):
  |
  +------------------------------------------------------------------------
  |
  | Used I/O-Area:
  |
  |   $DE00/56832/AR+0           I/O-Register
  |   $DF00-$DFFF/57088-57343    Mirrored ROM ($9F00-$9FFF)
  |
  | Used KERNAL-vectors:
  |
  |   $0302-$0303/770-771        BASIC Input Line and Decode   (-> $DF01)
  |   $030A-$030B/778-779        BASIC Token evaluation        (-> $DFB1)
  |   $0316-$0317/790-791        BRK Interrupt Address         (-> $DFCD)
  |   $0330-$0331/816-817        Kernal LOAD Routine           (-> $DF6D)
  |   $0332-$0333/818-819        Kernal SAVE Routine           (-> $DF6F)
  |
  +------------------------------------------------------------------------


 $DE00/56832/AR+0:   I/O-Register

   +-------+--------------------------------------------------------+
   | Bit 7 |   extra ROM bank selector (A15) (unused)               |
   | Bit 6 |   1 = resets FREEZE-mode (turns back to normal mode)   |
   | Bit 5 |   1 = enable RAM at ROML ($8000-$9FFF) &               |
   |       |       I/O2 ($DF00-$DFFF = $9F00-$9FFF)                 |
   | Bit 4 |   ROM bank selector high (A14)                         |
   | Bit 3 |   ROM bank selector low  (A13)                         |
   | Bit 2 |   1 = disable cartridge (turn off $DE00)               |
   | Bit 1 |   1 = /EXROM high                                      |
   | Bit 0 |   1 = /GAME low                                        |
   +-------+--------------------------------------------------------+

   Careful: Even a read-access will cause data to be written here!
   And note that the register is mirrored from $DE00-$DEFF.


  +------------------------------------------------------------------------
  |
  |      RETRO-REPLAY-Cartridge [http://rr.c64.org]:
  |
  +------------------------------------------------------------------------
  |
  | Used I/O-Area:
  |
  |   $DE00/56832/RR+0       Control-Register
  |   $DE01/56833/RR+1       Extended Control-Register
  |
  |  If SilverSurfer(RS232) present:
  |
  |   $DE08/56840/RR+8       Receive/Transmit Buffer
  |                          Baud Rate Divisor LSB
  |   $DE09/56841/RR+9       Interrupt Enable Register
  |                          Baud Rate Divisor MSB
  |   $DE0A/56842/RR+10      Interrupt Identification Register (read)
  |                          FIFO Control Register (write)
  |   $DE0B/56843/RR+11      Line Control Register
  |   $DE0C/56844/RR+12      Modem Control Register
  |   $DE0D/56845/RR+13      Line Status Register (read only)
  |   $DE0E/56846/RR+14      Modem Status Register (read only)
  |   $DE0F/56847/RR+15      Scratch Pad Register
  |
  | Used KERNAL-vectors:
  |
  |   (Software is still under development, so vectors will change
  |    between releases.)
  |
  | Memory Maps
  |
  +------------------------------------------------------------------------


 $DE00/56832/RR+0:   Control-Register

  On read:

   +-------+--------------------------------------------------------+
   | Bit 7 |   ROM bank selector (A15)                              |
   | Bit 6 |   1 = REU compatible memory map active                 |
   | Bit 5 |   ROM bank selector (A16)                              |
   | Bit 4 |   ROM bank selector (A14)                              |
   | Bit 3 |   ROM bank selector (A13)                              |
   | Bit 2 |   1 = Freeze button pressed                            |
   | Bit 1 |   AllowBank bit (see $DE01 / Write)                    |
   | Bit 0 |   1 = Flashmode active (jumper set)                    |
   +-------+--------------------------------------------------------+

  On write:

   +-------+--------------------------------------------------------+
   | Bit 7 |   ROM bank selector (A15)                              |
   | Bit 6 |   1 = exit from Freeze mode (if not in, no effect)     |
   | Bit 5 |   0 = select ROM, 1 = select RAM                       |
   | Bit 4 |   ROM bank selector (A14)                              |
   | Bit 3 |   ROM bank selector (A13)                              |
   | Bit 2 |   1 = disable cartridge                                |
   | Bit 1 |   1 = /EXROM high                                      |
   | Bit 0 |   1 = /GAME low                                        |
   +-------+--------------------------------------------------------+

      Default value is $00(%00000000) ($02 (%00000010) when Flashmode active).


 $DE01/56833/RR+1:   Extended Control-Register

  On read:

   +-------+--------------------------------------------------------+
   | Bit 7 |   ROM bank selector (A15)                              |
   | Bit 6 |   1 = REU compatible memory map active                 |
   | Bit 5 |   ROM bank selector (A16)                              |
   | Bit 4 |   ROM bank selector (A14)                              |
   | Bit 3 |   ROM bank selector (A13)                              |
   | Bit 2 |   1 = Freeze button pressed                            |
   | Bit 1 |   AllowBank bit (see Write)                            |
   | Bit 0 |   1 = Flashmode active (jumper set)                    |
   +-------+--------------------------------------------------------+

  On write:

   +-------+--------------------------------------------------------+
   | Bit 7 |   ROM bank selector (A15) - mirror of $DE00            |
   | Bit 6 |   1 = REU compatible memory map                        |
   | Bit 5 |   ROM bank selector (A16) - only in Flashmode          |
   | Bit 4 |   ROM bank selector (A14) - mirror of $DE00            |
   | Bit 3 |   ROM bank selector (A13) - mirror of $DE00            |
   | Bit 2 |   1 = disables Freeze function                         |
   | Bit 1 |   AllowBank bit (1 = allows banking of RAM in          |
   |       |   $DE02/$DF00 areas)                                   |
   | Bit 0 |   1 = enable accessory connector (SilverSurfer)        |
   +-------+--------------------------------------------------------+

   If not in Flash mode: Bits 1, 2, 6 can only be written once.
                         Bit 5 is always 0.

   If in Flash mode:     Bit 6 cannot be set.
                         Register will not be disabled by the first write.


 $DE08/56840/RR+8:   SilverSurfer: Receive/Transmit Buffer
                                   Baud Rate Divisor LSB

  Receive/Transmit Buffer    (if Bit 7 of $DE0B is 0)

  Baud Rate Divisor Low Byte (if Bit 7 of $DE0B is 1)

   Baud rate divisors can be calculated by taking the oscillating frequency
   (7,372,800) and dividing by the quantity of the desired baud rate times
   the UART clocking factor (16). Use the following formula (avoid 0!):

   Divisor = 7372800 / (BaudRate * 16)

   Examples:

    BaudRate     Divisor               BaudRate     Divisor
              dec.     hex.                      dec.     hex.

       300    1536    $0600              19200     24    $0018
       600     768    $0300              38400     12    $000c
      1200     384    $0180              57600      8    $0008
      1800     256    $0100             115200      4    $0004
      2400     192    $00c0             153600      3    $0003
      4800      96    $0060             230400      2    $0002
      9600      48    $0030             460800      1    $0001


 $DE09/56841/RR+9:   SilverSurfer: Interrupt Enable Register
                                   Baud Rate Divisor MSB

  Receive/Transmit Buffer     (if Bit 7 of $DE0B is 0)

   +-------+--------------------------------------------------------+
   | Bit 3 |   1 = enable Modem Status change-Interrupt             |
   | Bit 2 |   1 = enable Reciever Line Status-Interrupt            |
   | Bit 1 |   1 = enable Transmit Holding Register empty (THRE)    |
   | Bit 0 |   1 = enable Data available-Interrupt (and Timeout) (*)|
   +-------+--------------------------------------------------------+

   (*) 16550 will interrupt if data exists in the FIFO and isn't read
       within the time it takes to receive four bytes or if no data
       is received within the time it takes to receive four bytes.

  Baud Rate Divisor High Byte (if Bit 7 of $DE0B is 1)

   See $DE08 for details.


 $DE0A/56842/RR+10:  SilverSurfer: Interrupt Identification Register (read)
                                   FIFO Control Register (write)
  On read:

   +----------+--------------------------------------------------------+
   | Bit  7   |   1 = FIFO queues enabled                              |
   | Bits 6-4 |   reserved                                             |
   | Bit  3   |   1 = Timeout Interrupt pending                        |
   | Bits 2+1 |   Interrupt ID Bits:                                   |
   |          |             Meaning           |Priority   |  To reset  |
   |          |   00 = Modem Status change    | lowest    | read $DE0E |
   |          |   01 = Transmit Register empty| low       | read $DE0A/|
   |          |                               |           |write $DE08 |
   |          |   10 = Data available         | high      | read $DE08 |
   |          |   11 = Line Status            | highest   | read $DE0D |
   | Bit  0   |   0(!) = Interrupt pending                             |
   +----------+--------------------------------------------------------+

  On write:

   +----------+--------------------------------------------------------+
   | Bits 7+6 |   Trigger Level: 00,01,10,11 = 1,4,8,14 Bytes          |
   | Bits 5-4 |   reserved                                             |
   | Bit  3   |   1 = change RXRDY & TXRDY pins to DMA Mode (unused?)  |
   | Bit  2   |   1 = clear Transmit FIFO                              |
   | Bit  1   |   1 = clear Reciever FIFO                              |
   | Bit  0   |   1 = enable FIFO and clear FIFO queues                |
   +----------+--------------------------------------------------------+

   Bit 0 must be set in order to write to any other bits.

   When Bits 1 or 2 are set, the FIFO is cleared and the bit is reset.
   The corresponding shift register is not cleared.


 $DE0B/56843/RR+11:  SilverSurfer: Line Control Register

   +----------+--------------------------------------------------------+
   | Bit  7   |   1 = Baud Rate Divisor Latch at $DE08 and $DE09       |
   | Bit  6   |   0 = turn Break off, 1 = force spacing Break State    |
   | Bit  5   |   Parity: 0 = disabled, 1 = enabled                    |
   | Bit  4   |   Parity: 0 = odd, 1 = even                            |
   | Bit  3   |   Parity: 0 = no parity, 1 = parity                    |
   | Bit  2   |   Stop Bits: 0 = 1, 1 = 1.5 or 2 (*)                   |
   | Bits 1+0 |   Word Length select: 00,01,10,11 = 5,6,7,8 bits/char. |
   +----------+--------------------------------------------------------+
   (*) Stop Bits are 1.5 for 5 bit words or 2 for 6, 7 or 8 bit words.


 $DE0C/56844/RR+12:  SilverSurfer: Modem Control Register

   +----------+--------------------------------------------------------+
   | Bit  7-5 |   reserved                                             |
   | Bit  4   |   0 = Normal, 1 = Loop Back Test (*)                   |
   | Bit  3   |   OUT2                                                 |
   | Bit  2   |   OUT1                                                 |
   | Bit  1   |   1 = activate RTS                                     |
   | Bit  0   |   1 = activate DTR                                     |
   +----------+--------------------------------------------------------+
   (*)  Loop Back Test means data from the Transmit Shift Register is
        received in the Receiver Shift Register. The SOUT line is set to
        logic high, the SIN line and control lines are disconnected. CTS,
        DSR, RI and CD inputs are disconnected. DTR, RTS, OUT1 and OUT2
        are then connected internally.


 $DE0D/56845/RR+13:  SilverSurfer: Line Status Register (read only)

   +-------+--------------------------------------------------------+
   | Bit 7 |   1 = PE/FE/Break in FIFO queue                        |
   | Bit 6 |   1 = Transmitter Shift Register empty (TSRE)          |
   | Bit 5 |   1 = Transmitter Holding Register empty (THRE)        |
   | Bit 4 |   1 = Break Interrupt (BI)                             |
   | Bit 3 |   1 = Framing Error (FE)                               |
   | Bit 2 |   1 = Parity Error (PE)                                |
   | Bit 1 |   1 = Overrun Error (OE)                               |
   | Bit 0 |   1 = Data Ready                                       |
   +-------+--------------------------------------------------------+

   Bit 0 is set when a byte is placed in $DE08 and cleared when the
   byte is read by the CPU or when the FIFO is cleared. Results in Data
   Available Interrupts if enabled.

   Bits 1-4 indicate errors and result in Line Status Interrupts if enabled.

     Bit 1 is set when the queue is full and the byte in the Receiver Shift
     Register hasn't been moved into the queue. This bit is reset when the
     CPU reads the LSR.

     Bit 2 is set whenever a byte at top of the FIFO queue doesn't match the
     requested parity. Reset upon reading the LSR.

     Bit 3 is set when a character at top of the FIFO queue is received
     without proper stop bits. Upon detecting a framing error the UART
     attempts to resynchronize. Reset by reading the LSR.

     Bit 4 is set when a break condition is sensed (when space is
     detected for longer than 1 fullword).  A zero byte is placed in
     the FIFO queue. Reset by reading the LSR.

   Bit 5 is set when the XMIT FIFO queue is empty and is cleared when a byte
   is written to the XMIT FIFO. Results in Transmit Holding Register Empty
   interrupts if enabled.

   Bit 6 is set when the XMIT FIFO and Transmitter Shift Register are empty.

   Bit 7 indicates there is a byte in the FIFO queue that was received with
   a Parity, Framing or Break error.


 $DE0E/56846/RR+14:  SilverSurfer: Modem Status Register (read only)

   +-------+--------------------------------------------------------+
   | Bit 7 |   1 = DCD  (Data Carrier Detect)                       |
   | Bit 6 |   1 = RI   (Ring Indicator)                            |
   | Bit 5 |   1 = DSR  (Data Set Ready)                            |
   | Bit 4 |   1 = CTS  (Clear To Send)                             |
   | Bit 3 |   1 = DDCD (Delta Data Carrier Detect = DCD changed)   |
   | Bit 2 |   1 = TERI (Ring Indicator changed)                    |
   | Bit 1 |   1 = DDSR (Delta DSR = DSR changed)                   |
   | Bit 0 |   1 = DCTS (Delta CTS = CTS changed)                   |
   +-------+--------------------------------------------------------+
   Bits 0-3 are reset when read.
   Bit 4 is the $DE0C's RTS during loopback test.
   Bit 5 is the $DE0C's DTR during loopback test.
   Bit 6 is the $DE0C's OUT1 during loopback test.
   Bit 7 is the $DE0C's OUT2 during loopback test.


 $DE0F/56847/RR+15:  SilverSurfer: Scratch Pad Register

   This 8-bit register does not control the UART in any way. It is intended
   as a scratchpad register to be used by a programmer to hold data
   temporarily.


 Standard:

   $DE00 and $DE01 registers are active. $DF00-$DFFF contain the last page
   of the selected 8K-bank of either ROM or RAM, whatever is selected. RAM
   can only be accessed in $8000-$9FFF. ROM can be mapped to $8000, $A000 or
   $E000 with the corresponding status on GAME and EXROM.

   Note: If the AllowBank bit ($DE01, Bit 1) is not set, the $DF00-$DFFF area
   will always access bank 0 of the RAM, so the older cartridge images will
   work. The AllowBank bit does not have any effect on the ROM mirror in that
   area.

 Freeze:

   ROM is mapped to $E000-$FFFF, bank 0 is active directly after Freeze.
   Writing to bits 0 and 1 of the $DE00 register will have no effect on GAME
   and EXROM. RAM can be selected and used in $DE02 or $DF00, respectively,
   but not in $8000. Banking bits work, so you have full read access to the
   ROM, and access to up to four RAM pages with the AllowBank bit set (minus
   2 bytes if REU compatible bit is set). You should leave this memory map
   as soon as possible by setting bit 6 of $DE00 because C64 RAM in the
   $E000 area is not available, and you don't have control of the GAME and
   EXROM lines.

 REU compatible:

   $DE00 and $DE01 registers are active. $DE02-$DEFF contain a mirror of
   $9E02-$9EFF of the selected 8K-bank of either ROM or RAM, whatever is
   selected. RAM can only be accessed in $8000-$9FFF. ROM can be mapped to
   $8000, $A000 or $E000 with the corresponding status on GAME and EXROM.
   $DF00 stays free for use with the 17xx Ram Expansion Unit (REU).

   Note: If the AllowBank bit ($DE01, Bit 1) is not set, the $DF00-$DFFF area
   will always access bank 0 of the RAM, so the older cartridge images will
   work. The AllowBank bit does not have any effect on the ROM mirror in that
   area.


  +------------------------------------------------------------------------
  |
  |      MMC64-Cartridge:
  |
  +------------------------------------------------------------------------
  |
  | Used I/O-Area:
  |
  |   $DF10/57104/MMC+0        SPI Transfer Register
  |   $DF11/57105/MMC+1        Control Register
  |   $DF12/57106/MMC+2        Status Register (read only)
  |   $DF13/57107/MMC+3        Identification Register
  |
  | If Clock Port is used (Location depends on Bit 3 of $DF11):
  |
  |   $DF21/57121              Clock Port En-/Disable
  |   $DF22-$DF2F/57122-57135  Clock Port I/O-Area
  |    (or $DE01/56833 and $DE02-$DE0F/56384-56847)
  |
  | Memory Map:
  |
  |   $8000-$9FFF/32768-40959  MMC64-BIOS ROM
  |     ROM is active when Bit 0 of $DF11 and the Flash jumper is not set
  |     ROM is write enabled when Bit 4 of $DF11 and Flash jumper is set
  |
  +------------------------------------------------------------------------


 $DF10/57104/MMC+0:      SPI Transfer Register

  A byte written is sent to the card and response from the card is read here.


 $DF11/57105/MMC+1:      Control Register

   +-------+---------------------------------------------------------+
   | Bit 7 |   Unused                                                |
   | Bit 6 |   0 = SPI write trigger mode, 1 = SPI read trigger mode |
   | Bit 5 |   0 = allow external ROM when MMC64-BIOS is disabled,   |
   |       |   1 = disable external ROM                              |
   | Bit 4 |   0 = Normal Operation, 1 = Flash Mode (*)              |
   | Bit 3 |   0 = clock port at $DE00, 1 = clock port at $DF20      |
   |       |   Shadow: 0 = MMC64 active, 1 = MMC64 disabled (**)     |
   | Bit 2 |   0 = 250KHz transfer, 1 = 8MHz transfer                |
   | Bit 1 |   0 = Card selected, 1 = Card not selected              |
   | Bit 0 |   0 = MMC64-BIOS active, 1 = external ROM active        |
   +-------+---------------------------------------------------------+
   Notes: (*)  Bit 4 can only be written when flash jumper is set
          (**) The shadow of Bit 3 can only be modified after
               unlocking at $DF13


 $DF12/57106/MMC+2:      Status Register (read only)

   +-------+---------------------------------------------------------+
   | Bit 5 |   0 = Flash jumper not set, 1 = Flash jumper set        |
   | Bit 4 |   0 = Card write enabled, 1 = Card write disabled       |
   | Bit 3 |   0 = card inserted, 1 = no card inserted               |
   | Bit 2 |   external EXROM line                                   |
   | Bit 1 |   external GAME line                                    |
   | Bit 0 |   0 = SPI ready, 1 = SPI busy                           |
   +-------+---------------------------------------------------------+


 $DF13/57107/MMC+3:      Identification Register

  On Read:   #$64 when Bit 1 of $DF11 is 0
             #$01 when Bit 1 of $DF11 is 1 and REV A hardware is used
             #$02 when Bit 1 of $DF11 is 1 and REV B hardware is used

  On Write:  Write #$55 & #$AA into this register to unlock Bit 3 of $DF11
             Write #$0A & #$1C into this register to re-enable MMC64 hardware


 $DF21/57121:            Clock Port En-/Disable
 (or $DE01/56833)

   +-------+---------------------------------------------------------+
   | Bit 0 | 0 = disable Clock Port, 1 = enable Clock Port           |
   +-------+---------------------------------------------------------+
   Note: Location depends on Bit 3 of $DF11.


  +------------------------------------------------------------------------
  |
  |      FINAL-CARTRIDGE III:
  |
  +------------------------------------------------------------------------
  |
  | Used I/O-Area:
  |
  |   $DE00-$DFFE/56832-57342    Mirrored ROM (Bank 0: $9E00-$9FFE)
  |   $DFFF/57343                I/O-Register
  |
  | Used KERNAL-vectors:
  |
  |   $0302-$0303/770-771        BASIC Input Line and Decode   (-> $DE41)
  |   $0304-$0305/772-773        BASIC Tokenise Routine        (-> $DF8D)
  |   $0306-$0307/774-775        BASIC LIST Routine            (-> $DE49)
  |   $0308-$0309/776-777        BASIC Char dispatch Routine   (-> $DE73)
  |   $030A-$030B/778-779        BASIC Token evaluation        (-> $DFB1)
  |   $0330-$0331/816-817        Kernal LOAD Routine           (-> $DE21)
  |   $0332-$0333/818-819        Kernal SAVE Routine           (-> $DE35)
  |
  +------------------------------------------------------------------------


 $DFFF/57343:   FC3-I/O-Register

 Read:

 Depends on the last value written:

   +-------------+-----------------------------------------------------+
   | Bit 7 was 1 |   value = $FF                                       |
   | Bit 7 was 0 |   value = ((last value-1) and 2)/2*$FF              |
   +-------------+-----------------------------------------------------+

 Write:

   +----------+--------------------------------------------------------+
   | Bit  7   |   1 = always show 16KB of Bank 0 (for Reset-routine)   |
   | Bit  6   |   unused (usually set to 1)                            |
   | Bits 5+4 |   00 = turn on all 16 KB of FC3 ROM                    |
   |          |   01 = start Freezer immediately                       |
   |          |   10 = turn on first 8 KB of FC3 ROM                   |
   |          |   11 = turn off FC3 ROM                                |
   | Bits 3+2 |   unused (usually set to 0)                            |
   | Bits 1+0 |   number of bank to show at $8000                      |
   +----------+--------------------------------------------------------+

  Bank 0:  BASIC, Monitor, Disk-Turbo
  Bank 1:  Notepad, BASIC (Menu Bar)
  Bank 2:  Desktop, Freezer/Print
  Bank 3:  Freezer, Compression


  +------------------------------------------------------------------------
  |
  |      TURBO232, SWIFTLINK AND COMPATIBLES
  |
  +------------------------------------------------------------------------
  |
  | (Note: Other Base-Addresses may be: $D700/55040 or $DF00/57088)
  |
  |   $DE00/56832/SWIFTLINK+0        Data Register
  |   $DE01/56833/SWIFTLINK+1        Status Register
  |   $DE02/56834/SWIFTLINK+2        Command Register
  |   $DE03/56835/SWIFTLINK+3        Control Register
  |   $DE04/56836/SWIFTLINK+4        Undefined Register
  |   $DE05/56837/SWIFTLINK+5        Undefined Register
  |   $DE06/56838/SWIFTLINK+6        Undefined Register
  |
  | Turbo-232 only:
  |
  |   $DE07/56839/TURBO232+7         Enhanced-Speed Register
  |
  +------------------------------------------------------------------------


 $DE00/56832/SWIFTLINK+0:   Data Register

   Bytes to be send or received are stored in this register.


 $DE01/56833/SWIFTLINK+1:   Status Register

 Read:

   +-------+--------------------------------------------------------+
   | Bit 7 |   Interrupt Flag: 1 = Interrupt caused by SwiftLink    |
   | Bit 6 |   Carrier Detect: 1 = Carrier present                  |
   | Bit 5 |   DSR:            1 = High, 0 = Low                    |
   | Bit 4 |   Transmit Flag:  1 = Ready to get next Byte to        |
   |       |                       transmit in Data Register        |
   |       |                   0 = Chip currently sending Byte      |
   | Bit 3 |   Receive Flag:   1 = Byte received in Data Register   |
   |       |                   0 = Nothing received                 |
   | Bit 2 |   Overrun:        1 = Overrun occured (*)              |
   | Bit 1 |   Frame Error:    1 = Frame Error occured (*)          |
   | Bit 0 |   Parity Error:   1 = Parity Error occured (*)         |
   +-------+--------------------------------------------------------+

    (*) = Self-Clearing when read

 Write:
         Any write access will reset SwiftLink.


 $DE02/56834/SWIFTLINK+2:   Command Register

   +----------+---------------------------------------------------+
   | Bits 7-5 |   Parity: 000 = None            101 = Mark        |
   |          |           001 = Odd             111 = Space       |
   |          |           011 = Even                              |
   | Bit  4   |   Echo: 1 = On                                    |
   | Bit  3-2 |         Transmitter IRQ |  RTS  | Transmitter     |
   |          |         ----------------+-------+------------     |
   |          |    00 =     Disabled    |  High |    Off          |
   |          |    01 =     Enabled     |  Low  |    On           |
   |          |    10 =     Disabled    |  Low  |    On           |
   |          |    11 =     Disabled    |  Low  |    BRK          |
   | Bit  1   |   Receiver Interrupt: 1 = Disabled                |
   | Bit  0   |   Master IRQ Control: 1 = On                      |
   +----------+---------------------------------------------------+


 $DE03/56835/SWIFTLINK+3:   Control Register

   +----------+---------------------------------------------------+
   | Bit  7   |   Stop Bits: 1 = 2, 0 = 1 or 1.5                  |
   | Bit  6-5 |   Words: 00 = 8 Bit       10 = 6 Bit              |
   |          |          01 = 7 Bit       11 = 5 Bit              |
   | Bit  4   |   Baud Rate Generator: 1 = Internal, 0 = External |
   | Bits 3-0 |   Baud Rate: 0101 =  300 Bd      1011 =  7200 Bd  |
   |          |              0110 =  600 Bd      1100 =  9600 Bd  |
   |          |              0111 = 1200 Bd      1101 = 14400 Bd  |
   |          |              1000 = 2400 Bd      1110 = 19200 Bd  |
   |          |              1001 = 3600 Bd      1111 = 38400 Bd  |
   |          |              1010 = 4800 Bd                       |
   |          |              0000 = enable Enhanced Speed ($DE07) |
   +----------+---------------------------------------------------+


 $DE04/56836/SWIFTLINK+4:   Undefined Register
 $DE05/56837/SWIFTLINK+5:   Undefined Register
 $DE06/56838/SWIFTLINK+6:   Undefined Register


 $DE07/56839/TURBO232+7:   Enhanced-Speed Register

 Turbo232 only!

   +----------+---------------------------------------------------+
   | Bit  7-3 |   Unused                                          |
   | Bit  2   |   Mode Bit (read only): 1 = Bits 0-3 of $DE03 are |
   |          |   cleared and enhaced speed is enabled            |
   | Bits 1-0 |   Enhanced Baud Rate (read only if Mode Bit = 0): |
   |          |              00 = 230400 Bd       10 = 57600 Bd   |
   |          |              01 = 115200 Bd                       |
   |          |              11 = reserved for future expansions  |
   +----------+---------------------------------------------------+


  +------------------------------------------------------------------------
  |
  |      RAM EXPANSION UNIT (REU) 1700/1764/1750
  |
  +------------------------------------------------------------------------
  |
  |   $DF00/57088/REU+0        Status Register (read only)
  |   $DF01/57089/REU+1        Command Register
  |   $DF02/57090/REU+2        C64 Base Address - Low-Byte
  |   $DF03/57091/REU+3        C64 Base Address - High-Byte
  |   $DF04/57092/REU+4        REU Base Address - Low-Byte
  |   $DF05/57093/REU+5        REU Base Address - High-Byte
  |   $DF06/57094/REU+6        REU Base Address - Bank-Number
  |   $DF07/57095/REU+7        Transfer Length - Low-Byte
  |   $DF08/57096/REU+8        Transfer-Length - High-Byte
  |   $DF09/57097/REU+9        Interrupt Mask Register
  |   $DF0A/57098/REU+10       Address Control Register
  |
  +------------------------------------------------------------------------


 $DF00/57088/REU+0:   Status Register (read only)

   +----------+---------------------------------------------------+
   | Bit  7   |   Interrupt Pending: 1 = Interrupt occured        |
   |          |   (always 0 with RAMLink)                         |
   | Bit  6   |   End-of-Block: 1 = Transfer complete             |
   | Bit  5   |   Fault: 1 = Block Verify Error                   |
   | Bit  4   |   Size: 1 = min. 256 KB, 0 = 64 KB                |
   |          |   (always 1 with RAMLink)                         |
   | Bits 3-0 |   Version (always 0?)                             |
   +----------+---------------------------------------------------+


 $DF01/57089/REU+1:   Command Register

   +----------+---------------------------------------------------+
   | Bit  7   |   Execute: 1 = Transfer current Configuration     |
   |          |   (not used with RAMLink)                         |
   | Bit  6   |   Reserved (normally 0)                           |
   | Bit  5   |   Load: 1 = enable autoload option (addresses and |
   |          |             transfer-length are restored to       |
   |          |             values at beginning of transfer)      |
   |          |         0 = addresses stay at last_byte_used+1    |
   |          |             and transfer-length is $0001          |
   | Bit  4   |   FF00: 1 = start immediately                     |
   |          |         0 = wait for write access to $FF00        |
   |          |   (not used with RAMLink)                         |
   | Bits 3-2 |   Reserved (normally 0)                           |
   | Bits 1-0 |   Transfer Type:  00 = transfer C64 -> REU        |
   |          |                   01 = transfer REU -> C64        |
   |          |                   10 = swap C64 <-> REU           |
   |          |                   11 = compare C64 - REU          |
   +----------+---------------------------------------------------+


 $DF02/57090/REU+2:   C64 Base Address - Low-Byte


 $DF03/57091/REU+3:   C64 Base Address - High-Byte


 $DF04/57092/REU+4:   REU Base Address - Low-Byte


 $DF05/57093/REU+5:   REU Base Address - High-Byte


 $DF06/57094/REU+6:   REU Base Address - Bank Number


 $DF07/57095/REU+7:   Transfer Length - Low-Byte


 $DF08/57096/REU+8:   Transfer Length - High-Byte


 $DF09/57097/REU+9:   Interrupt Mask Register

   +----------+---------------------------------------------------+
   | Bit  7   |   Interrupt Enable: 1 = Interrupt enabled         |
   | Bit  6   |   End-of-Block Mask: 1 = Interrupt on End         |
   | Bit  5   |   Verify Error: 1 = Interrupt on Verify Error     |
   | Bits 4-0 |   Unused (normally 1)                             |
   +----------+---------------------------------------------------+


 $DF0A/57098/REU+10:  Address Control Register

   +----------+---------------------------------------------------+
   | Bit  7   |   C64 Address Control: 1 = fix C64 address        |
   | Bit  6   |   REU Address Control: 1 = fix REU address        |
   | Bits 5-0 |   Unused (normally 1)                             |
   +----------+---------------------------------------------------+


  +------------------------------------------------------------------------
  |
  |      +60K-RAM-Expansion
  |
  +------------------------------------------------------------------------

  $D100/53504/60K+0:  +60K-Register

   +--------+---------------------------------------------------+
   | Bit  7 |   0 = use original RAM, 1 = use additional RAM    |
   +--------+---------------------------------------------------+

  +60K is a hardware modification by Mr Fiz/Samar. It basically installs
  another set of RAM chips. Then the memory range from $1000 to $FFFF can
  be switched using a register. The rest can be used to store bank switching
  routines. Schematics can be found at [ftp://ftp.elysium.pl/tools/60k/]



  +------------------------------------------------------------------------
  |
  |      RAMLINK - REGISTER DESCRIPTIONS
  |
  +------------------------------------------------------------------------
  |
  |  Registers:
  |
  |   $DF7E/57214    Activate Hardware
  |   $DF7F/57215    Deactivate Hardware
  |
  |   Select page from internal RAM area (see $DFC0):
  |   $DF80/57216    Select Variables page
  |   $DF81/57217    Select DOS RAM page 0
  |   $DF82/57218    Select DOS RAM page 1
  |   $DF83/57219    Select DOS RAM page 2
  |   $DF84/57220    Select DOS RAM page 3
  |   and so on... (until $DF??)
  |
  |   $DFA0/57248    Low-Byte of requested RAMCard memory page
  |   $DFA1/57249    High-Byte of requested RAMCard memory page
  |
  |   $DFC0/57280    Show internal RAM page at $DE00 (default)
  |   $DFC1/57281    Show RAMCard memory page at $DE00
  |   $DFC2/57282    Show RAM Port device IO1 at $DE00
  |   $DFC3/57283    Show Pass-Thru Port device IO1 at $DE00
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |      VARIOUS FORMAT DESCRIPTIONS
  |
  +------------------------------------------------------------------------
  |
  | Graphics:
  |
  |  Hires                            Hires Interlaced
  |
  |   Doodle                           Hi.Interlace V1
  |   Hi-Eddi                          Hires-Lace V1.5
  |   Image System Hires               Shi-Editor V1.3
  |   OCP Art Studio V1
  |
  |  MultiColor                       MultiColor Interlaced
  |
  |   Amica Paint                      Drazlace V1
  |   Artist 64                        Drazlace V2
  |   Blazing Paddles                  TruePaint
  |   CDU Paint
  |   Image System
  |   Koala Painter
  |   OCP Art Studio V2
  |   Paint Magic
  |   Run Paint
  |   Saracen Paint
  |   Vidcom
  |
  |  Hires-FLI                       Hires-FLI Interlaced
  |
  |   AFLI-Editor (Topaz)             ECI Graph V1.0
  |   EAFLI Editor                    SHIFLI RAW
  |   Hires Manager (Cosmos)          UIFLI RAW
  |   HiresFli (Crest)
  |   SHFLI RAW
  |   SHFLI-XL RAW
  |   UFLI RAW
  |
  |  MultiColor-FLI                  MultiColor-FLI Interlaced
  |
  |   Blackmail FLI Editor            FunPaint 1
  |   FLI Designer 1+2                FunPaint 2
  |   FLIPROFI (Crest)                GunPaint
  |
  +------------------------------------------------------------------------



  +------------------------------------------------------------------------
  |
  |  Doodle
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 1 Screen-RAM
  |  - Hires pixels
  |
  |  Memory-Structure ($1C00-$4000, 9216 Bytes, 37 Blocks):
  |
  |   $1C00 - $1FE7: Screen-RAM
  |   $2000 - $3F3F: Bitmap
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  OCP Art Studio V1
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 1 Screen-RAM
  |  - Hires pixels
  |
  |  Memory-Structure ($2000-$4328, 9000 Bytes, 36 Blocks):
  |
  |   $2000 - $3F3F: Bitmap
  |   $3F40 - $4327: Screen-RAM
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  Hi-Eddi
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 1 Screen-RAM
  |  - Hires pixels
  |
  |  Memory-Structure ($2000-$4400, 9216 Bytes, 37 Blocks):
  |
  |   $2000 - $3F3F: Bitmap
  |   $4000 - $43E7: Screen-RAM
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  Image System Hires
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 1 Screen-RAM
  |  - Hires pixels
  |
  |  Memory-Structure ($4000-$63E8, 9192 Bytes, 37 Blocks):
  |
  |   $4000 - $5F3F: Bitmap
  |   $6000 - $63E7: Screen-RAM
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  Hires-Lace V1.5
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap (Int.), 1 Screen-RAM (Int.)
  |  - Hires pixels
  |  - Interlace without X-shifting
  |
  |  Memory-Structure ($4000-$C000, 32768 Bytes, 130 Blocks):
  |
  |   $4000 - $5F3F: Bitmap
  |   $6000 - $63E7: Screen-RAM
  |   $8000 - $83E7: Screen-RAM
  |   $A000 - $BF3F: Bitmap
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  Hi.Interlace V1
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap (Int.), 1 Screen-RAM (Int.)
  |  - Hires pixels
  |  - Interlace without X-shifting
  |
  |  Memory-Structure ($4000-$8000, 16384 Bytes, 65 Blocks):
  |
  |   $2000 - $3F3F: Bitmap
  |   $4400 - $47E7: Screen-RAM
  |   $4800 - $4BE7: Screen-RAM
  |   $6000 - $7F3F: Bitmap
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  Artist 64
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 1 Screen-RAM, Color-RAM
  |  - Multicolor pixels
  |
  |  Memory-Structure ($4000-$6800, 10240 Bytes, 41 Blocks):
  |
  |   $4000 - $5F3F: Bitmap
  |   $6000 - $63E7: Screen-RAM
  |   $6400 - $67E7: Color-RAM
  |   $67FF        : Background-Color
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  Vidcom
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 1 Screen-RAM, Color-RAM
  |  - Multicolor pixels
  |
  |  Memory-Structure ($5800-$7F40, 10048 Bytes, 40 Blocks):
  |
  |   $5800 - $5BE7: Color-RAM
  |   $5C00 - $5FE7: Screen-RAM
  |   $5FE8        : Background-Color
  |   $6000 - $7F3F: Bitmap
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  Image System
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 1 Screen-RAM, Color-RAM
  |  - Multicolor pixels
  |
  |  Memory-Structure ($3C00-$63E8, 10216 Bytes, 41 Blocks):
  |
  |   $3C00 - $3FE7: Color-RAM
  |   $4000 - $5F3F: Bitmap
  |   $5FFF        : Background-Color
  |   $6000 - $63E7: Screen-RAM
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  Saracen Paint
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 1 Screen-RAM, Color-RAM
  |  - Multicolor pixels
  |
  |  Memory-Structure ($7800-$9FE8, 10216 Bytes, 41 Blocks):
  |
  |   $7800 - $7BE7: Screen-RAM
  |   $7BF0        : Background-Color
  |   $7C00 - $9B3F: Bitmap
  |   $9C00 - $9FE7: Color-RAM
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  Blazing Paddles
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 1 Screen-RAM, Color-RAM
  |  - Multicolor pixels
  |
  |  Memory-Structure ($A000-$C800, 10240 Bytes, 41 Blocks):
  |
  |   $A000 - $BF3F: Bitmap
  |   $BF80        : Background-Color
  |   $C000 - $C3E7: Screen-RAM
  |   $C400 - $C7E7: Color-RAM
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  Run Paint
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 1 Screen-RAM, Color-RAM
  |  - Multicolor pixels
  |
  |  Memory-Structure ($6000-$8711, 10001 Bytes, 40 Blocks):
  |
  |   $6000 - $7F3F: Bitmap
  |   $7F40 - $8327: Screen-RAM
  |   $8328 - $870F: Color-RAM
  |   $8710        : Background-Color
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  Koala Painter
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 1 Screen-RAM, Color-RAM
  |  - Multicolor pixels
  |
  |  Memory-Structure ($6000-$8711, 10001 Bytes, 40 Blocks):
  |
  |   $6000 - $7F3F: Bitmap
  |   $7F40 - $8327: Screen-RAM
  |   $8328 - $870F: Color-RAM
  |   $8710        : Background-Color
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  CDU Paint
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 1 Screen-RAM, Color-RAM
  |  - Multicolor pixels
  |
  |  Memory-Structure ($7EEF-$A714, 10277 Bytes, 41 Blocks):
  |
  |   $8000 - $9F3F: Bitmap
  |   $9F40 - $A327: Screen-RAM
  |   $A328 - $A70F: Color-RAM
  |   $A710        : Background-Color
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  OCP Art Studio V2
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 1 Screen-RAM, Color-RAM
  |  - Multicolor pixels
  |
  |  Memory-Structure ($2000-$4720, 10016 Bytes, 40 Blocks):
  |
  |   $2000 - $3F3F: Bitmap
  |   $3F40 - $4327: Screen-RAM
  |   $4329        : Background-Color
  |   $4338 - $471F: Color-RAM
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  Drazlace V1
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap (Int.), 1 Screen-RAM, Color-RAM
  |  - Multicolor pixels
  |  - Interlace with X-shifting
  |
  |  Memory-Structure ($5800-$9F40, 18240 Bytes, 72 Blocks):
  |
  |   $5800 - $5BE7: Color-RAM
  |   $5C00 - $5FE7: Screen-RAM
  |   $6000 - $7F3F: Bitmap
  |   $7F40        : Background-Color
  |   $8000 - $9F3F: Bitmap
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  Drazlace V2
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap (Int.), 1 Screen-RAM, Color-RAM
  |  - Multicolor pixels
  |  - Interlace without X-shifting
  |
  |  Memory-Structure ($5800-$9F40, 18240 Bytes, 72 Blocks):
  |
  |   $5800 - $5BE7: Color-RAM
  |   $5C00 - $5FE7: Screen-RAM
  |   $6000 - $7F3F: Bitmap
  |   $7F40        : Background-Color
  |   $8000 - $9F3F: Bitmap
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  TruePaint
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap (Int.), 1 Screen-RAM (Int.), Color-RAM
  |  - Multicolor pixels
  |  - Interlace with X-shifting
  |
  |  Memory-Structure ($9C00-$E7E8, 19432 Bytes, 77 Blocks):
  |
  |   $9C00 - $9FE7: Screen-RAM
  |   $9FE8        : Background-Color
  |   $A000 - $BF3F: Bitmap
  |   $C000 - $DF3F: Bitmap
  |   $E000 - $E3E7: Screen-RAM
  |   $E400 - $E7E7: Color-RAM
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  HiresFli (Crest)
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 8 Screen-RAMs (FLI)
  |  - Hires pixels
  |
  |  Memory-Structure ($4000-$8000, 16384 Bytes, 65 Blocks):
  |
  |   $4000 - $5F3F: Bitmap
  |   $6000 - $63E7: Screen-RAM
  |   $6400 - $67E7: Screen-RAM
  |   $6800 - $6BE7: Screen-RAM
  |   $6C00 - $6FE7: Screen-RAM
  |   $7000 - $73E7: Screen-RAM
  |   $7400 - $77E7: Screen-RAM
  |   $7800 - $7BE7: Screen-RAM
  |   $7C00 - $7FE7: Screen-RAM
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  Hires Manager (Cosmos)
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 8 Screen-RAMs (FLI)
  |  - Hires pixels
  |
  |  Memory-Structure ($4000-$7FFF, 16383 Bytes, 65 Blocks):
  |
  |   $4000 - $5F3F: Bitmap
  |   $6000 - $63E7: Screen-RAM
  |   $6400 - $67E7: Screen-RAM
  |   $6800 - $6BE7: Screen-RAM
  |   $6C00 - $6FE7: Screen-RAM
  |   $7000 - $73E7: Screen-RAM
  |   $7400 - $77E7: Screen-RAM
  |   $7800 - $7BE7: Screen-RAM
  |   $7C00 - $7FE7: Screen-RAM
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  AFLI-Editor (Topaz)
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 8 Screen-RAMs (FLI)
  |  - Hires pixels
  |
  |  Memory-Structure ($4000-$7FFF, 16383 Bytes, 65 Blocks):
  |
  |   $4000 - $43E7: Screen-RAM
  |   $4400 - $47E7: Screen-RAM
  |   $4800 - $4BE7: Screen-RAM
  |   $4C00 - $4FE7: Screen-RAM
  |   $5000 - $53E7: Screen-RAM
  |   $5400 - $57E7: Screen-RAM
  |   $5800 - $5BE7: Screen-RAM
  |   $5C00 - $5FE7: Screen-RAM
  |   $6000 - $7F3F: Bitmap
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  FLI Designer 1+2
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 8 Screen-RAMs (FLI), Color-RAM
  |  - Multicolor pixels
  |
  |  Memory-Structure ($3C00-$8000, 17408 Bytes, 69 Blocks):
  |
  |   $3C00 - $3FE7: Color-RAM
  |   $4000 - $43E7: Screen-RAM
  |   $4400 - $47E7: Screen-RAM
  |   $4800 - $4BE7: Screen-RAM
  |   $4C00 - $4FE7: Screen-RAM
  |   $5000 - $53E7: Screen-RAM
  |   $5400 - $57E7: Screen-RAM
  |   $5800 - $5BE7: Screen-RAM
  |   $5C00 - $5FE7: Screen-RAM
  |   $6000 - $7F3F: Bitmap
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  Blackmail FLI Editor
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 8 Screen-RAMs (FLI), Color-RAM
  |  - Multicolor pixels
  |
  |  Memory-Structure ($3B00-$8000, 17664 Bytes, 70 Blocks):
  |
  |   $3C00 - $3FE7: Color-RAM
  |   $4000 - $43E7: Screen-RAM
  |   $4400 - $47E7: Screen-RAM
  |   $4800 - $4BE7: Screen-RAM
  |   $4C00 - $4FE7: Screen-RAM
  |   $5000 - $53E7: Screen-RAM
  |   $5400 - $57E7: Screen-RAM
  |   $5800 - $5BE7: Screen-RAM
  |   $5C00 - $5FE7: Screen-RAM
  |   $6000 - $7F3F: Bitmap
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  ECI Graph V1.0
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap (Int.), 8 Screen-RAMs (FLI) (Int.)
  |  - Hires pixels
  |  - Interlace without X-shifting
  |
  |  Memory-Structure ($4000-$C000, 32768 Bytes, 130 Blocks):
  |
  |   $4000 - $5F3F: Bitmap
  |   $6000 - $63E7: Screen-RAM
  |   $6400 - $67E7: Screen-RAM
  |   $6800 - $6BE7: Screen-RAM
  |   $6C00 - $6FE7: Screen-RAM
  |   $7000 - $73E7: Screen-RAM
  |   $7400 - $77E7: Screen-RAM
  |   $7800 - $7BE7: Screen-RAM
  |   $7C00 - $7FE7: Screen-RAM
  |   $8000 - $9F3F: Bitmap
  |   $A000 - $A3E7: Screen-RAM
  |   $A400 - $A7E7: Screen-RAM
  |   $A800 - $ABE7: Screen-RAM
  |   $AC00 - $AFE7: Screen-RAM
  |   $B000 - $B3E7: Screen-RAM
  |   $B400 - $B7E7: Screen-RAM
  |   $B800 - $BBE7: Screen-RAM
  |   $BC00 - $BFE7: Screen-RAM
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  FunPaint 1
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap (Int.), 8 Screen-RAMs (FLI) (Int.), Color-RAM
  |  - Multicolor pixels
  |  - Interlace with X-shifting
  |
  |  Memory-Structure ($3FF0-$C38C, 33692 Bytes, 133 Blocks):
  |
  |   $3FF8        : Background-Color
  |   $4000 - $43E7: Screen-RAM
  |   $4400 - $47E7: Screen-RAM
  |   $4800 - $4BE7: Screen-RAM
  |   $4C00 - $4FE7: Screen-RAM
  |   $5000 - $53E7: Screen-RAM
  |   $5400 - $57E7: Screen-RAM
  |   $5800 - $5BE7: Screen-RAM
  |   $5C00 - $5FE7: Screen-RAM
  |   $6000 - $7F3F: Bitmap
  |   $8000 - $83E7: Color-RAM
  |   $83E8 - $87CF: Screen-RAM
  |   $87E8 - $8BCF: Screen-RAM
  |   $8BE8 - $8FCF: Screen-RAM
  |   $8FE8 - $93CF: Screen-RAM
  |   $93E8 - $97CF: Screen-RAM
  |   $97E8 - $9BCF: Screen-RAM
  |   $9BE8 - $9FCF: Screen-RAM
  |   $9FE8 - $A3CF: Screen-RAM
  |   $A3E8 - $C327: Bitmap
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  FunPaint 2
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap (Int.), 8 Screen-RAMs (FLI) (Int.), Color-RAM
  |  - Multicolor pixels
  |  - Background-Color per scanline
  |  - Interlace with X-shifting
  |
  |  Memory-Structure ($3FF0-$C38C, 33692 Bytes, 133 Blocks):
  |
  |   $4000 - $43E7: Screen-RAM
  |   $4400 - $47E7: Screen-RAM
  |   $4800 - $4BE7: Screen-RAM
  |   $4C00 - $4FE7: Screen-RAM
  |   $5000 - $53E7: Screen-RAM
  |   $5400 - $57E7: Screen-RAM
  |   $5800 - $5BE7: Screen-RAM
  |   $5C00 - $5FE7: Screen-RAM
  |   $6000 - $7F3F: Bitmap
  |   $7F48 - $7FAB: Background-Colors
  |   $8000 - $83E7: Color-RAM
  |   $83E8 - $87CF: Screen-RAM
  |   $87E8 - $8BCF: Screen-RAM
  |   $8BE8 - $8FCF: Screen-RAM
  |   $8FE8 - $93CF: Screen-RAM
  |   $93E8 - $97CF: Screen-RAM
  |   $97E8 - $9BCF: Screen-RAM
  |   $9BE8 - $9FCF: Screen-RAM
  |   $9FE8 - $A3CF: Screen-RAM
  |   $A3E8 - $C327: Bitmap
  |   $C328 - $C38B: Background-Colors
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  GunPaint
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap (Int.), 8 Screen-RAMs (FLI) (Int.), Color-RAM
  |  - Multicolor pixels
  |  - Background-Color per scanline
  |  - Interlace with X-shifting
  |
  |  Memory-Structure ($4000-$C340, 33600 Bytes, 133 Blocks):
  |
  |   $4000 - $43E7: Screen-RAM
  |   $4400 - $47E7: Screen-RAM
  |   $4800 - $4BE7: Screen-RAM
  |   $4C00 - $4FE7: Screen-RAM
  |   $5000 - $53E7: Screen-RAM
  |   $5400 - $57E7: Screen-RAM
  |   $5800 - $5BE7: Screen-RAM
  |   $5C00 - $5FE7: Screen-RAM
  |   $6000 - $7F3F: Bitmap
  |   $7F40 - $7FFF: Background-Colors
  |   $8000 - $83E7: Color-RAM
  |   $8400 - $87E7: Screen-RAM
  |   $87E8 - $87F9: Background-Colors
  |   $8800 - $8BE7: Screen-RAM
  |   $8C00 - $8FE7: Screen-RAM
  |   $9000 - $93E7: Screen-RAM
  |   $9400 - $97E7: Screen-RAM
  |   $9800 - $9BE7: Screen-RAM
  |   $9C00 - $9FE7: Screen-RAM
  |   $A000 - $A3E7: Screen-RAM
  |   $A400 - $C33F: Bitmap
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  FLIPROFI (Crest)
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 8 Screen-RAMs (FLI), Color-RAM
  |  - Multicolor pixels
  |  - Additional Sprite-Layer
  |
  |  Memory-Structure ($3780-$7F40, 18368 Bytes, 73 Blocks):
  |
  |   $3C00 - $3FE7: Color-RAM
  |   $4000 - $43E7: Screen-RAM
  |   $4400 - $47E7: Screen-RAM
  |   $4800 - $4BE7: Screen-RAM
  |   $4C00 - $4FE7: Screen-RAM
  |   $5000 - $53E7: Screen-RAM
  |   $5400 - $57E7: Screen-RAM
  |   $5800 - $5BE7: Screen-RAM
  |   $5C00 - $5FE7: Screen-RAM
  |   $6000 - $7F3F: Bitmap
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  Shi-Editor V1.3
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap (Int.), 1 Screen-RAM (Int.)
  |  - Hires pixels
  |  - Interlace without X-shifting
  |
  |  Memory-Structure ($7FFF-$BBF8, 15353 Bytes, 61 Blocks):
  |
  |   $8000 - $9F3F: Bitmap
  |   $A000 - $A3E7: Screen-RAM
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  EAFLI Editor
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 8 Screen-RAMs (FLI)
  |  - Hires pixels
  |  - Additional Sprite-Layer
  |
  |  Memory-Structure ($8000-$ADC0, 11712 Bytes, 47 Blocks):
  |
  |   $8000 - $83E7: Screen-RAM
  |   $8400 - $87E7: Screen-RAM
  |   $8800 - $8BE7: Screen-RAM
  |   $8C00 - $8FE7: Screen-RAM
  |   $9000 - $93E7: Screen-RAM
  |   $9400 - $97E7: Screen-RAM
  |   $9800 - $9BE7: Screen-RAM
  |   $9C00 - $9FE7: Screen-RAM
  |   $A000 - $BF3F: Bitmap
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  SHFLI RAW
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 8 Screen-RAMs (FLI)
  |  - Hires pixels
  |  - Additional Sprite-Layer
  |
  |  Memory-Structure ($4000-$7F3F, 16191 Bytes, 64 Blocks):
  |
  |   $4000 - $43E7: Screen-RAM
  |   $4400 - $47E7: Screen-RAM
  |   $4800 - $4BE7: Screen-RAM
  |   $4C00 - $4FE7: Screen-RAM
  |   $5000 - $53E7: Screen-RAM
  |   $5400 - $57E7: Screen-RAM
  |   $5800 - $5BE7: Screen-RAM
  |   $5C00 - $5FE7: Screen-RAM
  |   $6000 - $7F3F: Bitmap
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  SHFLI-XL RAW
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 8 Screen-RAMs (FLI)
  |  - Hires pixels
  |  - Additional Sprite-Layer
  |
  |  Memory-Structure ($4000-$7F3F, 16191 Bytes, 64 Blocks):
  |
  |   $4000 - $43E7: Screen-RAM
  |   $4400 - $47E7: Screen-RAM
  |   $4800 - $4BE7: Screen-RAM
  |   $4C00 - $4FE7: Screen-RAM
  |   $5000 - $53E7: Screen-RAM
  |   $5400 - $57E7: Screen-RAM
  |   $5800 - $5BE7: Screen-RAM
  |   $5C00 - $5FE7: Screen-RAM
  |   $6000 - $7F3F: Bitmap
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  UFLI RAW
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 4 Screen-RAMs (FLI)
  |  - Hires pixels
  |  - Additional Sprite-Layer
  |
  |  Memory-Structure ($4000-$7F40, 16192 Bytes, 64 Blocks):
  |
  |   $5000 - $53E7: Screen-RAM
  |   $5400 - $57E7: Screen-RAM
  |   $5800 - $5BE7: Screen-RAM
  |   $5C00 - $5FE7: Screen-RAM
  |   $6000 - $7F3F: Bitmap
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  SHIFLI RAW
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap (Int.), 8 Screen-RAMs (FLI) (Int.)
  |  - Hires pixels
  |  - Interlace without X-shifting
  |  - Additional Sprite-Layer
  |
  |  Memory-Structure ($4000-$FF3F, 48959 Bytes, 193 Blocks):
  |
  |   $4000 - $43E7: Screen-RAM
  |   $4400 - $47E7: Screen-RAM
  |   $4800 - $4BE7: Screen-RAM
  |   $4C00 - $4FE7: Screen-RAM
  |   $5000 - $53E7: Screen-RAM
  |   $5400 - $57E7: Screen-RAM
  |   $5800 - $5BE7: Screen-RAM
  |   $5C00 - $5FE7: Screen-RAM
  |   $6000 - $7F3F: Bitmap
  |   $C000 - $C3E7: Screen-RAM
  |   $C400 - $C7E7: Screen-RAM
  |   $C800 - $CBE7: Screen-RAM
  |   $CC00 - $CFE7: Screen-RAM
  |   $D000 - $D3E7: Screen-RAM
  |   $D400 - $D7E7: Screen-RAM
  |   $D800 - $DBE7: Screen-RAM
  |   $DC00 - $DFE7: Screen-RAM
  |   $E000 - $FF3F: Bitmap
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  Amica Paint
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 1 Screen-RAM, Color-RAM
  |  - Multicolor pixels
  |
  |  Depacking:
  |
  |    $C2 00    means End of Picture
  |    $C2 xx yy means copy Byte yy xx-times to Picture
  |    xx        copy Byte xx to Picture
  |
  |  Memory-Structure (e.g. $6000-$8811, 10257 Bytes, 41 Blocks):
  |
  |   $6000 - $7F3F: Bitmap
  |   $7F40 - $8327: Screen-RAM
  |   $8328 - $870F: Color-RAM
  |   $8710        : Background-Color
  |   $8711 - $8810: Color-Rotation-Table
  |
  +------------------------------------------------------------------------


  Explanations for Graphic Formats:

  - "(Int.)" means that the corresponding type of memory is interlaced.
  - "(FLI)" means that the Graphics mode uses FLI. The number of Screen-RAMs
    determines how often FLI needs to be achieved.
     E.g., 8 Screen-RAMs = every raster-line
           4 Screen-RAMs = every second raster-line...
  - "Hires" or "Multicolor" pixels define the type like Bit 4 of $D016.
  - "X-Shifting" means toggling Bit 0 of $D016 between frames.
  - "Background-Color per scanline" means you have to set $D021
     every rasterline.
  - Detailed infos about Sprite Layers still need to be done.


  +------------------------------------------------------------------------
  |
  |  Paint Magic
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap, 1 Screen-RAM, Color-RAM
  |  - Multicolor pixels
  |
  |  Memory-Structure ($3F8E-$63FF, 9329 Bytes, 37 Blocks):
  |
  |   $4000 - $5F3F: Bitmap
  |   $5F40        : Background-Color
  |   $5F43        : Color-RAM
  |   $6000 - $63E7: Screen-RAM
  |
  +------------------------------------------------------------------------


  +------------------------------------------------------------------------
  |
  |  UIFLI RAW
  |
  +------------------------------------------------------------------------
  |
  |  Features (see Explanations for details):
  |
  |  - 1 Bitmap (Int.), 4 Screen-RAMs (FLI) (Int.)
  |  - Hires pixels
  |  - Interlace without X-shifting
  |  - Additional Sprite-Layer
  |
  |  Memory-Structure ($4000-$FF40, 48960 Bytes, 193 Blocks):
  |
  |   $4000 - $43E7: Screen-RAM
  |   $4400 - $47E7: Screen-RAM
  |   $4800 - $4BE7: Screen-RAM
  |   $4C00 - $4FE7: Screen-RAM
  |   $6000 - $7F3F: Bitmap
  |   $C000 - $C3E7: Screen-RAM
  |   $C400 - $C7E7: Screen-RAM
  |   $C800 - $CBE7: Screen-RAM
  |   $CC00 - $CFE7: Screen-RAM
  |   $E000 - $FF3F: Bitmap
  |
  +------------------------------------------------------------------------

